<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='一、并发编程概述 1.1 并行和并发 1.1.1 并行 parallel 在同一时刻，有多条指令在多个处理器上同时执行。
1.1.1.1 并行的两大特性 1.多进程、多核心。 2.物理上同时发生的过程。
1.1.1.2 并行的简要示例图 并行需要硬件的支持，有块 128 核的 CPU 就能同时处理 128 个任务。
1.1.2 并发 concurrency 并发是时间片轮转。在同一时刻只能有一条指令执行，但多个进程指令被快速地轮换执行，使得在宏观上具有多个进程同时执行的效果。但在微观上并不是同时执行，只是把时间分成若干段，使多个任务快速交替地执行。
1.1.2.1 并发的两大特性 1.单进程。 2.逻辑上同时发生的过程。
1.1.2.2 时间片轮转 举例解释：一个 CPU 给一个任务分配 1 秒的时间处理任务，1 秒后不再处理此任务而去处理另一个任务，由此轮转着进行。也就是，一个 CPU 处理任务的时间，根据这个时间，间隔交替执行多个任务。 CPU 处理任务的效率极高，通常是几毫秒内（甚至只是几纳秒）就能处理完一个任务，几毫秒的时间切换，人的肉眼是看不出交替的过程，也就是看起来感觉像是并行的。 并发是技术层面的工作：在有限的资源内，高效地利用 CPU 资源。
1.1.2.3 并发的简要示例图 1.2 使用咖啡机理解并行与并发 拿现实生活中咖啡机的例子，初步理解并行与并发。
1.2.1 并行演示 有两台咖啡机，两个队列同时使用两台咖啡机。 1.2.2 并发演示 两个队列交替使用同一台咖啡机。 只有一台咖啡机，一个队列的一个人拿完咖啡，另一个队列的另一个人拿咖啡。交替着进行！ 1.3 Go 语言的并发机制 所谓并发，就是交替着执行多个几个任务。 Golang 为并发编程而内置的上层 API 基于 CSP （Communicating Sequential Processes, 顺序通信进程）模型，显示锁是可以避免的。 Golang 使用了 goroutine （微线程，也可以称呼为：Go协程）来实现并发机制。 Golang 通过安全的通道发送和接收数据以实现同步。'>
<title>Golang学习之并发编程</title>

<link rel='canonical' href='https://360rce.github.io/p/1ypylhrh/'>

<link rel="stylesheet" href="/scss/style.min.efe1e773d779dbe0d478a3345bc5ad949fed81363c53bfa8984135f20bf7841d.css"><meta property='og:title' content='Golang学习之并发编程'>
<meta property='og:description' content='一、并发编程概述 1.1 并行和并发 1.1.1 并行 parallel 在同一时刻，有多条指令在多个处理器上同时执行。
1.1.1.1 并行的两大特性 1.多进程、多核心。 2.物理上同时发生的过程。
1.1.1.2 并行的简要示例图 并行需要硬件的支持，有块 128 核的 CPU 就能同时处理 128 个任务。
1.1.2 并发 concurrency 并发是时间片轮转。在同一时刻只能有一条指令执行，但多个进程指令被快速地轮换执行，使得在宏观上具有多个进程同时执行的效果。但在微观上并不是同时执行，只是把时间分成若干段，使多个任务快速交替地执行。
1.1.2.1 并发的两大特性 1.单进程。 2.逻辑上同时发生的过程。
1.1.2.2 时间片轮转 举例解释：一个 CPU 给一个任务分配 1 秒的时间处理任务，1 秒后不再处理此任务而去处理另一个任务，由此轮转着进行。也就是，一个 CPU 处理任务的时间，根据这个时间，间隔交替执行多个任务。 CPU 处理任务的效率极高，通常是几毫秒内（甚至只是几纳秒）就能处理完一个任务，几毫秒的时间切换，人的肉眼是看不出交替的过程，也就是看起来感觉像是并行的。 并发是技术层面的工作：在有限的资源内，高效地利用 CPU 资源。
1.1.2.3 并发的简要示例图 1.2 使用咖啡机理解并行与并发 拿现实生活中咖啡机的例子，初步理解并行与并发。
1.2.1 并行演示 有两台咖啡机，两个队列同时使用两台咖啡机。 1.2.2 并发演示 两个队列交替使用同一台咖啡机。 只有一台咖啡机，一个队列的一个人拿完咖啡，另一个队列的另一个人拿咖啡。交替着进行！ 1.3 Go 语言的并发机制 所谓并发，就是交替着执行多个几个任务。 Golang 为并发编程而内置的上层 API 基于 CSP （Communicating Sequential Processes, 顺序通信进程）模型，显示锁是可以避免的。 Golang 使用了 goroutine （微线程，也可以称呼为：Go协程）来实现并发机制。 Golang 通过安全的通道发送和接收数据以实现同步。'>
<meta property='og:url' content='https://360rce.github.io/p/1ypylhrh/'>
<meta property='og:site_name' content='iceH&#39;s Blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='Golang' /><meta property='article:published_time' content='2021-01-10T09:36:55&#43;00:00'/><meta property='article:modified_time' content='2021-01-10T09:36:55&#43;00:00'/><meta property='og:image' content='https://w.wallhaven.cc/full/2y/wallhaven-2y2or6.png' />
<meta name="twitter:title" content="Golang学习之并发编程">
<meta name="twitter:description" content="一、并发编程概述 1.1 并行和并发 1.1.1 并行 parallel 在同一时刻，有多条指令在多个处理器上同时执行。
1.1.1.1 并行的两大特性 1.多进程、多核心。 2.物理上同时发生的过程。
1.1.1.2 并行的简要示例图 并行需要硬件的支持，有块 128 核的 CPU 就能同时处理 128 个任务。
1.1.2 并发 concurrency 并发是时间片轮转。在同一时刻只能有一条指令执行，但多个进程指令被快速地轮换执行，使得在宏观上具有多个进程同时执行的效果。但在微观上并不是同时执行，只是把时间分成若干段，使多个任务快速交替地执行。
1.1.2.1 并发的两大特性 1.单进程。 2.逻辑上同时发生的过程。
1.1.2.2 时间片轮转 举例解释：一个 CPU 给一个任务分配 1 秒的时间处理任务，1 秒后不再处理此任务而去处理另一个任务，由此轮转着进行。也就是，一个 CPU 处理任务的时间，根据这个时间，间隔交替执行多个任务。 CPU 处理任务的效率极高，通常是几毫秒内（甚至只是几纳秒）就能处理完一个任务，几毫秒的时间切换，人的肉眼是看不出交替的过程，也就是看起来感觉像是并行的。 并发是技术层面的工作：在有限的资源内，高效地利用 CPU 资源。
1.1.2.3 并发的简要示例图 1.2 使用咖啡机理解并行与并发 拿现实生活中咖啡机的例子，初步理解并行与并发。
1.2.1 并行演示 有两台咖啡机，两个队列同时使用两台咖啡机。 1.2.2 并发演示 两个队列交替使用同一台咖啡机。 只有一台咖啡机，一个队列的一个人拿完咖啡，另一个队列的另一个人拿咖啡。交替着进行！ 1.3 Go 语言的并发机制 所谓并发，就是交替着执行多个几个任务。 Golang 为并发编程而内置的上层 API 基于 CSP （Communicating Sequential Processes, 顺序通信进程）模型，显示锁是可以避免的。 Golang 使用了 goroutine （微线程，也可以称呼为：Go协程）来实现并发机制。 Golang 通过安全的通道发送和接收数据以实现同步。"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://w.wallhaven.cc/full/2y/wallhaven-2y2or6.png' />
    <link rel="shortcut icon" href="/favicon.ico" />
<style>
    :root {
     
    --sys-font-family: "HarmonyOS_Sans_SC_Medium", Georgia, -apple-system, 'Nimbus Roman No9 L', 'PingFang SC', 'Hiragino Sans GB', 'Noto Serif SC', 'Microsoft Yahei', 'WenQuanYi Micro Hei', 'ST Heiti', sans-serif;
    --code-font-family: "JetBrainsMono Regular", Menlo, Monaco, Consolas, "Courier New";
    --article-font-family: "HarmonyOS_Sans_SC_Medium", var(--base-font-family);
  }
</style>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://npm.elemecdn.com/irithys-cdn@1.0.4/font/font.css";
        customFont.type = "text/css";
        customFont.rel = "stylesheet";
         document.head.appendChild(customFont);
}());
</script>
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended">


        <div id="article-toolbar" style="position: sticky;top: 5px;z-index: 1000;">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>返回</span>
            </a>
        </div>
    

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
			<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" stroke="currentColor" fill="#BDBDBF"><path d="M512 256C512 397.4 397.4 512 256 512C114.6 512 0 397.4 0 256C0 114.6 114.6 0 256 0C397.4 0 512 114.6 512 256zM176 168V344C176 352.7 180.7 360.7 188.3 364.9C195.8 369.2 205.1 369 212.5 364.5L356.5 276.5C363.6 272.1 368 264.4 368 256C368 247.6 363.6 239.9 356.5 235.5L212.5 147.5C205.1 142.1 195.8 142.8 188.3 147.1C180.7 151.3 176 159.3 176 168V168z"></path></svg>
            
        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#一并发编程概述">一、并发编程概述</a>
      <ol>
        <li><a href="#11-并行和并发">1.1 并行和并发</a>
          <ol>
            <li><a href="#111-并行-parallel">1.1.1 并行 <code>parallel</code></a></li>
            <li><a href="#112-并发-concurrency">1.1.2 并发 <code>concurrency</code></a></li>
          </ol>
        </li>
        <li><a href="#12-使用咖啡机理解并行与并发">1.2 使用咖啡机理解并行与并发</a>
          <ol>
            <li><a href="#121-并行演示">1.2.1 并行演示</a></li>
            <li><a href="#122-并发演示">1.2.2 并发演示</a></li>
          </ol>
        </li>
        <li><a href="#13-go-语言的并发机制">1.3 Go 语言的并发机制</a></li>
      </ol>
    </li>
    <li><a href="#二goroutine">二、<code>goroutine</code></a>
      <ol>
        <li><a href="#21-创建goroutine">2.1 创建goroutine</a>
          <ol>
            <li><a href="#211-最基本的示例">2.1.1 最基本的示例</a></li>
          </ol>
        </li>
        <li><a href="#22-主协程退出子协程也一起退出">2.2 主协程退出，子协程也一起退出</a>
          <ol>
            <li><a href="#221-示例1主协程结束子协程跟着一起结束">2.2.1 示例1：主协程结束，子协程跟着一起结束</a></li>
            <li><a href="#222-示例2主协程先退出导致子协程没来得及调用">2.2.2 示例2：主协程先退出，导致子协程没来得及调用</a></li>
          </ol>
        </li>
        <li><a href="#23-runtime-包">2.3 runtime 包</a>
          <ol>
            <li><a href="#231-runtimegosched">2.3.1 <code>runtime.Gosched</code></a></li>
            <li><a href="#232-runtimegoexit">2.3.2 runtime.Goexit</a></li>
            <li><a href="#233-runtimegomaxprocs">2.3.3 <code>runtime.GOMAXPROCS</code></a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#三多任务资源竞争的问题">三、多任务资源竞争的问题</a></li>
    <li><a href="#四channel">四、<code>channel</code></a>
      <ol>
        <li><a href="#41-channel-类型概述">4.1 <code>channel</code> 类型概述</a></li>
        <li><a href="#42-channel-创建">4.2 <code>channel</code> 创建</a>
          <ol>
            <li><a href="#421-基本语法">4.2.1 基本语法</a></li>
            <li><a href="#422-channel-的操作符-">4.2.2 <code>channel</code> 的操作符：<code>&lt;-</code></a></li>
          </ol>
        </li>
        <li><a href="#43-使用-channel-实现同步">4.3 使用 <code>channel</code> 实现同步</a></li>
        <li><a href="#44-通过-channel-实现同步和数据交互">4.4 通过 <code>channel</code> 实现同步和数据交互</a>
          <ol>
            <li><a href="#441-死锁错误演示1">4.4.1 死锁错误演示1</a></li>
            <li><a href="#442-死锁错误演示2">4.4.2 死锁错误演示2</a></li>
            <li><a href="#443-解决死锁错误的方案给管道写入数据">4.4.3 解决死锁错误的方案：给管道写入数据</a></li>
          </ol>
        </li>
        <li><a href="#45-无缓冲-channel">4.5 无缓冲 <code>channel</code></a>
          <ol>
            <li><a href="#451-创建无缓冲-channel">4.5.1 创建无缓冲 <code>channel</code></a></li>
            <li><a href="#452-计算channel的函数">4.5.2 计算channel的函数</a></li>
            <li><a href="#453-示例">4.5.3 示例</a></li>
            <li><a href="#454-通过-channel-共享-goroutine-的变量">4.5.4 通过 <code>channel</code> 共享 <code>goroutine</code> 的变量</a></li>
          </ol>
        </li>
        <li><a href="#46-有缓冲的-channel">4.6 有缓冲的 <code>channel</code></a>
          <ol>
            <li><a href="#461-创建有缓冲的-channel">4.6.1 创建有缓冲的 <code>channel</code></a></li>
            <li><a href="#462-示例">4.6.2 示例</a></li>
          </ol>
        </li>
        <li><a href="#47-两个类型-channel-的总结">4.7 两个类型 <code>channel</code> 的总结</a></li>
        <li><a href="#48-关闭-channel">4.8 关闭 <code>channel</code></a></li>
        <li><a href="#49-通过range遍历channel">4.9 通过range遍历channel</a></li>
        <li><a href="#410-单向channel">4.10 单向channel</a>
          <ol>
            <li><a href="#4101-单向channel变量的声明">4.10.1 单向channel变量的声明</a></li>
            <li><a href="#4102-单向-channel-的特点">4.10.2 单向 <code>channel</code> 的特点</a></li>
            <li><a href="#4103-单向-channel-的应用">4.10.3 单向 <code>channel</code> 的应用</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#五定时器">五、定时器</a>
      <ol>
        <li><a href="#51-timer">5.1 <code>Timer</code></a>
          <ol>
            <li><a href="#511-创建一个-timer">5.1.1 创建一个 <code>Timer</code></a></li>
            <li><a href="#512-timer-只会产生一次事件">5.1.2 <code>Timer</code> 只会产生一次事件</a></li>
            <li><a href="#513-timer-实现延时功能">5.1.3 <code>Timer</code> 实现延时功能</a></li>
            <li><a href="#514-timer注意事项">5.1.4 Timer注意事项</a></li>
            <li><a href="#515-timer停止">5.1.5 Timer停止</a></li>
            <li><a href="#516-timer重置">5.1.6 Timer重置</a></li>
          </ol>
        </li>
        <li><a href="#52-ticker">5.2 Ticker</a></li>
        <li><a href="#53-timer和ticker区别">5.3 Timer和Ticker区别</a></li>
      </ol>
    </li>
    <li><a href="#六select">六、<code>select</code></a>
      <ol>
        <li><a href="#61-select-大致结构">6.1 <code>select</code> 大致结构</a>
          <ol>
            <li><a href="#611-注意事项1">6.1.1 注意事项1</a></li>
            <li><a href="#612-注意事项2">6.1.2 注意事项2</a></li>
          </ol>
        </li>
        <li><a href="#62-使用-select-实现斐波那契数列">6.2 使用 <code>select</code> 实现斐波那契数列</a></li>
        <li><a href="#63-select实现超时机制">6.3 select实现超时机制</a></li>
        <li><a href="#64-使用-select-输出几个偶数">6.4 使用 <code>select</code> 输出几个偶数</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/1ypylhrh/">
                
                    <img src="https://w.wallhaven.cc/full/2y/wallhaven-2y2or6.png" loading="lazy" alt="Featured image of post Golang学习之并发编程" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E5%90%B9%E6%A2%A6%E5%88%B0%E8%A5%BF%E5%B7%9E/" >
                吹梦到西州
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/1ypylhrh/">Golang学习之并发编程</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" stroke="currentColor" fill="#BDBDBF"><path d="M326.1 160l127.4-127.4C451.7 32.39 449.9 32 448 32h-86.06l-128 128H326.1zM166.1 160l128-128H201.9l-128 128H166.1zM497.7 56.19L393.9 160H512V96C512 80.87 506.5 67.15 497.7 56.19zM134.1 32H64C28.65 32 0 60.65 0 96v64h6.062L134.1 32zM0 416c0 35.35 28.65 64 64 64h384c35.35 0 64-28.65 64-64V192H0V416z"></path></svg>
                
                <time class="article-time--published">2021/01/10</time>
            </div>
        

        
            <div>
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" stroke="currentColor" fill="#BDBDBF"><path d="M256 512C114.6 512 0 397.4 0 256S114.6 0 256 0S512 114.6 512 256s-114.6 256-256 256zM232 120V256c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2V120c0-13.3-10.7-24-24-24s-24 10.7-24 24z"></path></svg>
                
                <time class="article-time--reading">
                    阅读时长: 20 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h2 id="一并发编程概述">一、并发编程概述</h2>
<h3 id="11-并行和并发">1.1 并行和并发</h3>
<h4 id="111-并行-parallel">1.1.1 并行 <code>parallel</code></h4>
<p>在同一时刻，有多条指令在多个处理器上<strong>同时</strong>执行。</p>
<h5 id="1111-并行的两大特性">1.1.1.1 并行的两大特性</h5>
<p>1.多进程、多核心。
2.<strong>物理上</strong>同时发生的过程。</p>
<h5 id="1112-并行的简要示例图">1.1.1.2 并行的简要示例图</h5>
<p><img src="/p/1ypylhrh/01.jpg"
	width="387"
	height="218"
	srcset="/p/1ypylhrh/01_huf0f1158b747f874e0241167ae92c16d1_14515_480x0_resize_q75_box.jpg 480w, /p/1ypylhrh/01_huf0f1158b747f874e0241167ae92c16d1_14515_1024x0_resize_q75_box.jpg 1024w"
	loading="lazy"
	
		alt="并行简要示例图"
	
	
		class="gallery-image" 
		data-flex-grow="177"
		data-flex-basis="426px"
	
>
并行需要硬件的支持，有块 128 核的 CPU 就能同时处理 128 个任务。</p>
<h4 id="112-并发-concurrency">1.1.2 并发 <code>concurrency</code></h4>
<p>并发是时间片轮转。在同一时刻只能有一条指令执行，但多个进程指令被快速地轮换执行，使得在宏观上具有多个进程同时执行的效果。但在微观上并不是同时执行，只是把时间分成若干段，使多个任务快速交替地执行。</p>
<h5 id="1121-并发的两大特性">1.1.2.1 并发的两大特性</h5>
<p>1.单进程。
2.<strong>逻辑上</strong>同时发生的过程。</p>
<h5 id="1122-时间片轮转">1.1.2.2 时间片轮转</h5>
<p>举例解释：一个 CPU 给一个任务分配 1 秒的时间处理任务，1 秒后不再处理此任务而去处理另一个任务，由此轮转着进行。也就是，一个 CPU 处理任务的时间，根据这个时间，间隔交替执行多个任务。
CPU 处理任务的效率极高，通常是几毫秒内（甚至只是几纳秒）就能处理完一个任务，几毫秒的时间切换，人的肉眼是看不出交替的过程，也就是看起来感觉像是并行的。
并发是技术层面的工作：在有限的资源内，高效地利用 CPU 资源。</p>
<h5 id="1123-并发的简要示例图">1.1.2.3 并发的简要示例图</h5>
<p><img src="/p/1ypylhrh/02.jpg"
	width="366"
	height="218"
	srcset="/p/1ypylhrh/02_hud80dcecaddbfb35409958a98a8e0cedc_16981_480x0_resize_q75_box.jpg 480w, /p/1ypylhrh/02_hud80dcecaddbfb35409958a98a8e0cedc_16981_1024x0_resize_q75_box.jpg 1024w"
	loading="lazy"
	
		alt="并发简要示例图"
	
	
		class="gallery-image" 
		data-flex-grow="167"
		data-flex-basis="402px"
	
></p>
<h3 id="12-使用咖啡机理解并行与并发">1.2 使用咖啡机理解并行与并发</h3>
<p>拿现实生活中咖啡机的例子，初步理解并行与并发。</p>
<h4 id="121-并行演示">1.2.1 并行演示</h4>
<p>有两台咖啡机，两个队列<strong>同时</strong>使用两台咖啡机。
<img src="/p/1ypylhrh/03.jpg"
	width="600"
	height="232"
	srcset="/p/1ypylhrh/03_hufa9aa6ea828b7042f4f7b2f977d7b7d1_21635_480x0_resize_q75_box.jpg 480w, /p/1ypylhrh/03_hufa9aa6ea828b7042f4f7b2f977d7b7d1_21635_1024x0_resize_q75_box.jpg 1024w"
	loading="lazy"
	
		alt="并行咖啡机示例图"
	
	
		class="gallery-image" 
		data-flex-grow="258"
		data-flex-basis="620px"
	
></p>
<h4 id="122-并发演示">1.2.2 并发演示</h4>
<p>两个队列<strong>交替</strong>使用同一台咖啡机。
只有一台咖啡机，一个队列的一个人拿完咖啡，另一个队列的另一个人拿咖啡。<strong>交替着进行</strong>！
<img src="/p/1ypylhrh/04.jpg"
	width="600"
	height="177"
	srcset="/p/1ypylhrh/04_hue826148770c998266124d6b7f7752569_17817_480x0_resize_q75_box.jpg 480w, /p/1ypylhrh/04_hue826148770c998266124d6b7f7752569_17817_1024x0_resize_q75_box.jpg 1024w"
	loading="lazy"
	
		alt="并发咖啡机示例图"
	
	
		class="gallery-image" 
		data-flex-grow="338"
		data-flex-basis="813px"
	
></p>
<h3 id="13-go-语言的并发机制">1.3 Go 语言的并发机制</h3>
<p>所谓并发，就是交替着执行多个几个任务。
Golang 为并发编程而内置的上层 API 基于 <code>CSP</code> （Communicating Sequential Processes, 顺序通信进程）模型，显示锁是可以避免的。
Golang 使用了 <code>goroutine</code> （微线程，也可以称呼为：Go协程）来实现并发机制。
Golang 通过安全的通道发送和接收数据以实现同步。</p>
<h2 id="二goroutine">二、<code>goroutine</code></h2>
<p>和传统基于 OS 进程和线程不同，Go 语言的并发是基于用户态的并发，使用 <code>goroutine</code> 协程模型。
<code>goroutine</code> 其实是 <code>协程</code> —— Go 协程，Go 语言的运行时（也就是 <code>runtime</code>）会参与调度 goroutine，并将 goroutine 合理地分配到每个 CPU 中，最大限度地使用 CPU 的性能。
可以把一个 <code>goroutine</code> 当做一个任务，一个 <code>goroutine</code> 就是一个新的任务。
协程比线程更小，十几个 <code>goroutine</code> 可能体现在底层就是 5、6 个线程，执行 <code>goroutine</code> 只需极少的栈内存(4 ~ 5 KB)，并根据实际数据进行伸缩。</p>
<h3 id="21-创建goroutine">2.1 创建goroutine</h3>
<p>只需要在函数调用语句前添加 <code>go</code> 关键字，就可以创建并发执行单元，调度器会自动将其安排到合适的系统线程上执行。
通过 <code>go</code> 关键字创建的 <code>goroutine</code>，可以称为子协程、工作协程。
可以把 <code>func main() {}</code> 理解成主协程，<code>main()</code> 主函数是一个 <code>main goroutine</code>。</p>
<h4 id="211-最基本的示例">2.1.1 最基本的示例</h4>
<p>新建一个 go 协程（新建一个新任务）。
示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">newTask</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;this is newTask&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 不能放到 for 语句块的下面，不然程序就一直在执行 for 死循环，永远不会去开启 go 协程。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 新建一个 go 协程，新建一个任务。这个是新建的任务，原来的任务就是这个主函数：main 主协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 任务创建完毕后，程序继续往下走。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="nf">newTask</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;this is main&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">this is main
</span></span></span><span class="line"><span class="cl"><span class="cm">this is newTask
</span></span></span><span class="line"><span class="cl"><span class="cm">this is newTask
</span></span></span><span class="line"><span class="cl"><span class="cm">this is main
</span></span></span><span class="line"><span class="cl"><span class="cm">this is main
</span></span></span><span class="line"><span class="cl"><span class="cm">this is newTask
</span></span></span><span class="line"><span class="cl"><span class="cm">this is newTask
</span></span></span><span class="line"><span class="cl"><span class="cm">this is main
</span></span></span><span class="line"><span class="cl"><span class="cm">...
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>打印顺序不可控是因为任务调度的原因造成：
遇到 <code>go</code> 关键字，系统就会新建一个 go 协程。子协程是一个新任务，主函数本身就是一个任务。两个任务交替着执行，就看谁先被调度器调度。两个任务轮转着执行。</p>
<h3 id="22-主协程退出子协程也一起退出">2.2 主协程退出，子协程也一起退出</h3>
<p>主协程退出，子协程也一起退出。也可以称：主协程结束，子协程跟着一起结束。
<code>main()</code> 函数是主协程；其他由 <code>go</code> 关键字创建的协程叫子协程。</p>
<h4 id="221-示例1主协程结束子协程跟着一起结束">2.2.1 示例1：主协程结束，子协程跟着一起结束</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 新建一个新任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">i</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;sub-goroutine, i=&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span> <span class="c1">// 匿名函数别忘了加圆括号()调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 主任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">i</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;this is main, i=&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 2 秒后退出这个 for 循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">this is main, i= 1
</span></span></span><span class="line"><span class="cl"><span class="cm">sub-goroutine, i= 1
</span></span></span><span class="line"><span class="cl"><span class="cm">this is main, i= 2
</span></span></span><span class="line"><span class="cl"><span class="cm">sub-goroutine, i= 2
</span></span></span><span class="line"><span class="cl"><span class="cm">sub-goroutine, i= 3
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>2 秒后，主协程内的 for 循环退出，接下来也没有其他代码，主协程（<code>main()</code> 函数）就结束了。此时，虽然子协程是一个死循环，但主协程已经结束了，那么子协程也跟着结束。</p>
<h4 id="222-示例2主协程先退出导致子协程没来得及调用">2.2.2 示例2：主协程先退出，导致子协程没来得及调用</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 新建一个新任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">i</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;sub-goroutine, i=&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>运行结果什么都没有的原因：
程序从 <code>main()</code> 函数入口处进入，<code>main()</code> 函数就是一个主协程。看到 <code>go</code> 关键字，就会去新建一个新的子协程。新建完后程序就会往下走，发现没有代码了，走到了主协程（<code>main()</code> 函数）的结束处，那么主协程（<code>main()</code> 函数）就结束了。<code>main()</code> 结束，整个程序结束，子协程只是被创建了但还没来得及运行，整个程序就已经结束了。整个程序结束了，子协程也就不复存在了！就相当于：想玩电脑游戏，刚启动游戏，游戏画面都还没有出来，跳闸断电关机了，游戏还能继续在电脑上运行吗？</p>
<h3 id="23-runtime-包">2.3 runtime 包</h3>
<h4 id="231-runtimegosched">2.3.1 <code>runtime.Gosched</code></h4>
<p><code>runtime.Gosched()</code>，让出时间片。用于让出 CPU 时间片（让出当前 <code>goroutine</code> 的执行权限），调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。
简而言之：遇到 <code>runtime.Gosched()</code> 这行代码，让其他协程先执行完，然后再回到原来的调用者协程中，继续往下执行。
示例1：先看一个反面例子，程序执行完就结束，子协程没来得及执行就已经退出了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;go, i=&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;main, i=&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">main, i= 0
</span></span></span><span class="line"><span class="cl"><span class="cm">main, i= 1
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意：因为调度的原因，有时候是可以打印出子协程的内容，甚至偶尔能让子协程运行完成。这是因为底层调度器的关系，先调度了子协程那么就先运行子协程的代码，先调度主协程那么就运行主协程。主协程运行结束，系统资源要回收前那一瞬间，调度器又调度了子协程，所以能运行子协程，但是当调度器再次回到主协程时，主协程因为之前已执行完毕，所以退出了。主协程退出，整个程序结束，子协程跟着结束。
接下来使用 <code>runtime.Gosched()</code>，让其他的协程先运行完：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;runtime&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;go, i=&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">runtime</span><span class="p">.</span><span class="nf">Gosched</span><span class="p">()</span> <span class="c1">// 让出时间片，让其他协程先执行完，然后再回来执行此协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;main, i=&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">go, i= 0
</span></span></span><span class="line"><span class="cl"><span class="cm">go, i= 1
</span></span></span><span class="line"><span class="cl"><span class="cm">go, i= 2
</span></span></span><span class="line"><span class="cl"><span class="cm">go, i= 3
</span></span></span><span class="line"><span class="cl"><span class="cm">go, i= 4
</span></span></span><span class="line"><span class="cl"><span class="cm">main, i= 0
</span></span></span><span class="line"><span class="cl"><span class="cm">main, i= 1
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>此时，就不会发生示例 1 中的情况。这里，遇到 <code>runtime.Gosched()</code> 就先不执行主协程，让子协程先执行，子协程执行完了，回来后，再继续执行主协程。</p>
<h4 id="232-runtimegoexit">2.3.2 runtime.Goexit</h4>
<p><code>runtime.Goexit()</code>，立即终止当前 <code>goroutine</code> 执行。调度器确保所有已注册 <code>defer</code> 延迟调用被执行。
示例1：普通写法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;test cccccccc&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;dddddd&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;aaaaa&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nf">test</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;bbbbb&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//死循环的目的是为了不让主协程结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">aaaaa
</span></span></span><span class="line"><span class="cl"><span class="cm">dddddd
</span></span></span><span class="line"><span class="cl"><span class="cm">test cccccccc
</span></span></span><span class="line"><span class="cl"><span class="cm">bbbbb
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>程序正常执行，开启一个子协程，第一步打印出&quot;a…&quot;，调用函数test，第二步打印&quot;d…&quot;，test函数结束前执行第三步打印&quot;test c…&quot;，最后打印&quot;b…&quot;
示例2：<code>return</code> 终止函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;test cccccccc&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="c1">//终止函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;dddddd&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;aaaaa&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nf">test</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;bbbbb&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//死循环的目的是为了不让主协程结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">aaaaa
</span></span></span><span class="line"><span class="cl"><span class="cm">test cccccccc
</span></span></span><span class="line"><span class="cl"><span class="cm">bbbbb
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>test() 函数中，<code>return</code> 会终止这个test函数，所以&quot;d…&ldquo;不会打印出来。
示例3：<code>runtime.Goexit</code> 退出当前整个协程</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;runtime&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;test cccccccc&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">runtime</span><span class="p">.</span><span class="nf">Goexit</span><span class="p">()</span>	<span class="c1">//终止当前整个协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;dddddd&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;aaaaa&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nf">test</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;bbbbb&#34;</span><span class="p">)</span>	<span class="c1">//因为被终止，所以不执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 死循环的目的是为了不让主协程结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">aaaaa
</span></span></span><span class="line"><span class="cl"><span class="cm">test cccccccc
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>return</code> 和 <code>runtime.Goexit()</code> 的区别：<code>return</code> 只是终止当前这个函数；<code>runtime.Goexit()</code> 终止的是当前整个协程。
示例4：<code>runtime.Goexit()</code> 终止当前整个协程，它不会追溯到其他的协程</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;runtime&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//由gor1()协程中的代码调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;test ccc&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">runtime</span><span class="p">.</span><span class="nf">Goexit</span><span class="p">()</span> <span class="c1">//终止gor1()整个协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;test ddd&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">gor1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">i</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;gor1..., i=&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">test</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;gor1..., finished.&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//新建一个子协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;aaa&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">//又新建一个子协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">go</span> <span class="nf">gor1</span><span class="p">()</span> <span class="c1">//新建后代码往下走，并不会立即调度执行这个协程里的代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;bbb&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//死循环的目的是为了不让主协程结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">aaa
</span></span></span><span class="line"><span class="cl"><span class="cm">bbb
</span></span></span><span class="line"><span class="cl"><span class="cm">gor1..., i= 1
</span></span></span><span class="line"><span class="cl"><span class="cm">gor1..., i= 2
</span></span></span><span class="line"><span class="cl"><span class="cm">test ccc
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>新建的第一个协程是匿名函数的协程，当新建第二个协程的时候，它们就是两个独立的协程了。<code>runtime.Goexit()</code> 终止的是当前整个协程，而不会追溯到其他的协程。看起来，gor1() 这个协程是在匿名函数协程中的，被匿名函数包裹起来了，感觉上是 gor1() 终止了，匿名函数也会被终止。但是，它们是两个独立的协程。所以当gor1()这个协程结束的时候，只会结束当前gor1() 这个协程，不会追溯到匿名函数这个协程。</p>
<h4 id="233-runtimegomaxprocs">2.3.3 <code>runtime.GOMAXPROCS</code></h4>
<p><code>runtime.GOMAXPROCS(int)</code> 设置可以并行计算的 CPU 核数的最大值，并返回之前有几个 CPU 参与运算。
就是：使用多少核来运行程序。设置多个 CPU，让时间片轮转速度更快一些，执行效率更高。
示例1：以单核 CPU 运算</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;runtime&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cores</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 指定以单核 CPU 运算，返回之前有几个 CPU 参与运算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;how many cores:&#34;</span><span class="p">,</span> <span class="nx">cores</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>只有单核运算的情况下，时间片轮转是：这个任务运行一段时间，另一个任务运行一段时间，交替着运行任务。所以，能看到下图中，同一时间只会输出一个值，因为在那个时间中，只处理那一个任务：
<img src="/p/1ypylhrh/05.jpg"
	width="1374"
	height="622"
	srcset="/p/1ypylhrh/05_hu3008567444c8757aeb81e7db6423f485_57320_480x0_resize_q75_box.jpg 480w, /p/1ypylhrh/05_hu3008567444c8757aeb81e7db6423f485_57320_1024x0_resize_q75_box.jpg 1024w"
	loading="lazy"
	
		alt="单核 CPU 运算"
	
	
		class="gallery-image" 
		data-flex-grow="220"
		data-flex-basis="530px"
	
>
示例2：多核 CPU 运算</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;runtime&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cores</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// 指定 2 个 CPU 运算，返回之前有几个 CPU 在参与运算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;how many cores:&#34;</span><span class="p">,</span> <span class="nx">cores</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>不会出现示例 1 中，一大坨 0、1 的情况。因为是两个 CPU 在同时处理任务。
<img src="/p/1ypylhrh/06.jpg"
	width="1412"
	height="588"
	srcset="/p/1ypylhrh/06_hu60b22eec40e4e7d7374f708bb632df2c_62100_480x0_resize_q75_box.jpg 480w, /p/1ypylhrh/06_hu60b22eec40e4e7d7374f708bb632df2c_62100_1024x0_resize_q75_box.jpg 1024w"
	loading="lazy"
	
		alt="多核 CPU 运算"
	
	
		class="gallery-image" 
		data-flex-grow="240"
		data-flex-basis="576px"
	
></p>
<h2 id="三多任务资源竞争的问题">三、多任务资源竞争的问题</h2>
<p>场景模拟：两个人在用同一台打印机，打印内容。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 模拟一个打印机，按字符串的顺序打印每个字符
</span></span></span><span class="line"><span class="cl"><span class="c1">// 这个打印机属于公共资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Printer</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">str</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%c&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="c1">//Print(c)打印的是每个字符的ASCII码值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">person1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Printer</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">person2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Printer</span><span class="p">(</span><span class="s">&#34;world&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 新建 2 个子协程，模拟 2 个人同时使用打印机
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="nf">person1</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">person2</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 为了不让主协程结束，特意放了一个死循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">hweolrllod
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>多任务时经常遇到的问题：资源竞争，抢着用同一个资源。
如下图所示，两个子协程同时在使用一个资源，person1() 打印了 “h”，person2() 打印了 “w”，person1() 又来打印了 “e”，person2() 又来打印了 “o” …… 两个协程抢着用同一个资源，所以最终结果就乱了。
<img src="/p/1ypylhrh/07.jpg"
	width="1229"
	height="756"
	srcset="/p/1ypylhrh/07_hu968e8d2ebb7afb143ba7ab482920cb11_53226_480x0_resize_q75_box.jpg 480w, /p/1ypylhrh/07_hu968e8d2ebb7afb143ba7ab482920cb11_53226_1024x0_resize_q75_box.jpg 1024w"
	loading="lazy"
	
		alt="资源竞争"
	
	
		class="gallery-image" 
		data-flex-grow="162"
		data-flex-basis="390px"
	
>
解决方案：同步。一个执行完了再执行另外一个，互斥。互斥需要用到 <code>channel</code>。</p>
<h2 id="四channel">四、<code>channel</code></h2>
<p><code>channel</code> 主要解决资源竞争的问题，以及两个协程之间的数据交互。实现：同步和数据交互。
<code>goroutine</code> 运行在相同的地址空间，访问共享内存必须做好同步。<code>goroutine</code> 之间的数据交互需要用到 <code>channel</code>。
<code>goroutine</code> 奉行：<strong>通过通信来共享内存，而不是共享内存来通信</strong>。
<code>channel</code> 是 <code>CSP</code> 模型的具体实现，用于多个 <code>goroutine</code> 之间的通讯，其内部实现了同步，确保并发的安全。
<code>channel</code> 是引用类型，函数参数传递时，是引用传递(传址)。</p>
<h3 id="41-channel-类型概述">4.1 <code>channel</code> 类型概述</h3>
<p><code>channel</code> 是一个对应 <code>make()</code> 创建的底层数据结构的引用。
<code>channel</code> 属于引用传递(传址)，<strong>调用者和被调用者引用的是同一个 channel</strong>。
定义一个 <code>channel</code> 时，必须指定发送到 <code>channel</code> 的值的类型。</p>
<h3 id="42-channel-创建">4.2 <code>channel</code> 创建</h3>
<h4 id="421-基本语法">4.2.1 基本语法</h4>
<p>1.<code>make(chan Type)</code>
2.<code>make(chan Type, capacity)</code>
当 <code>capacity=0</code> 的时候，<code>channel</code> 是无缓冲、阻塞读写的。
当 <code>capacity&gt;0</code> 的时候，<code>channel</code> 有缓冲、非阻塞的。</p>
<h4 id="422-channel-的操作符-">4.2.2 <code>channel</code> 的操作符：<code>&lt;-</code></h4>
<p><code>channel</code> 通过操作符 <code>&lt;-</code> 来接收和发送数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">channel</span> <span class="o">&lt;-</span> <span class="nx">value</span> <span class="c1">// 发送 value 到 channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">&lt;-</span><span class="nx">channel</span> <span class="c1">// 接收数据并将其丢弃
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">x</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">channel</span> <span class="c1">// 从 channel 中接收数据，并赋值给变量x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">x</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">channel</span> <span class="c1">// 接收数据赋值给x，同时检查通道是否已关闭或是否为空
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当 <code>capacity=0</code> 或不指定的时候，<code>channel</code> 接收和发送数据都是阻塞的（没数据之前，它就等着写入数据才往下走），除非另一端已经准备好。这样使得 <code>goroutine</code> 同步变得更加的简单，不需要显示的 <code>ok</code>。</p>
<h3 id="43-使用-channel-实现同步">4.3 使用 <code>channel</code> 实现同步</h3>
<p>同步：有先后顺序地执行，一个执行完再执行另外一个。通道没有数据就会阻塞！
以解决第 3 部分打印机的问题为例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 管道全局变量，方便调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="c1">// 管道传递的数据类型根据实际需要来指明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 模拟一个打印机，按字符串的顺序打印每个字符
</span></span></span><span class="line"><span class="cl"><span class="c1">// 这个打印机属于公共资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Printer</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">str</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%c&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="c1">// Print(c) 打印的是每个字符的 ASCII 码值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">person1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Printer</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">1</span> <span class="c1">// 给管道写数据，发送
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">person2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">&lt;-</span><span class="nx">ch</span> <span class="c1">// 从管道取数据，接收。如果管道没有数据就会阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">Printer</span><span class="p">(</span><span class="s">&#34;world&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 新建2个子协程，模拟2个人同时使用打印机
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="nf">person1</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">person2</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 为了不让主协程结束，特意放了一个死循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">hello
</span></span></span><span class="line"><span class="cl"><span class="cm">world
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">Process finished with exit code 2
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="44-通过-channel-实现同步和数据交互">4.4 通过 <code>channel</code> 实现同步和数据交互</h3>
<h4 id="441-死锁错误演示1">4.4.1 死锁错误演示1</h4>
<p>程序走完了，但依然没有给管道写数据，管道中没有数据能够接收到，那么程序永远阻塞在那里不会往下走，引发了死锁错误。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;main-goroutine finished.&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 新建一个子协程，懒得写函数调用可以使用匿名函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;sub-goroutine, i=&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;sub-goroutine finished.&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">str</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span> <span class="c1">// 管道中取不到数据，就会永远卡在这里，造成死锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;main-goroutine, str=&#34;</span><span class="p">,</span> <span class="nx">str</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">sub-goroutine, i= 0
</span></span></span><span class="line"><span class="cl"><span class="cm">sub-goroutine, i= 1
</span></span></span><span class="line"><span class="cl"><span class="cm">sub-goroutine finished.
</span></span></span><span class="line"><span class="cl"><span class="cm">fatal error: all goroutines are asleep - deadlock!
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">goroutine 1 [chan receive]:
</span></span></span><span class="line"><span class="cl"><span class="cm">main.main()
</span></span></span><span class="line"><span class="cl"><span class="cm">	F:/goProject/src/myTest/main.go:19 +0x112
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">Process finished with exit code 2
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="442-死锁错误演示2">4.4.2 死锁错误演示2</h4>
<p>不论是有缓冲通道还是无缓冲通道，通道中任意一方永久性阻塞，就会引发死锁错误。
<img src="/p/1ypylhrh/08.jpg"
	width="806"
	height="193"
	srcset="/p/1ypylhrh/08_hu84470b89052ffb269d7da0d40ef290de_55835_480x0_resize_q75_box.jpg 480w, /p/1ypylhrh/08_hu84470b89052ffb269d7da0d40ef290de_55835_1024x0_resize_q75_box.jpg 1024w"
	loading="lazy"
	
		alt="死锁错误演示"
	
	
		class="gallery-image" 
		data-flex-grow="417"
		data-flex-basis="1002px"
	
>
<img src="/p/1ypylhrh/09.jpg"
	width="1110"
	height="495"
	srcset="/p/1ypylhrh/09_hu73cbd0ae6416aef83f14d28e5a2d6577_142890_480x0_resize_q75_box.jpg 480w, /p/1ypylhrh/09_hu73cbd0ae6416aef83f14d28e5a2d6577_142890_1024x0_resize_q75_box.jpg 1024w"
	loading="lazy"
	
		alt="死锁错误演示"
	
	
		class="gallery-image" 
		data-flex-grow="224"
		data-flex-basis="538px"
	
></p>
<h4 id="443-解决死锁错误的方案给管道写入数据">4.4.3 解决死锁错误的方案：给管道写入数据</h4>
<p>往管道里写入数据，Golang 内部立马能够检测到。管道接收到了数据就不会阻塞了，就能往下走了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;main-goroutine finished.&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 新建一个子协程，懒得写函数调用可以使用匿名函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;sub-goroutine closed.&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;sub-goroutine, i=&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&#34;sub-goroutine has finished work.&#34;</span> <span class="c1">// 给管道写入数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">str</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span> <span class="c1">// 能从管道中取到数据了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;main-goroutine, str=&#34;</span><span class="p">,</span> <span class="nx">str</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">sub-goroutine, i= 0
</span></span></span><span class="line"><span class="cl"><span class="cm">sub-goroutine, i= 1
</span></span></span><span class="line"><span class="cl"><span class="cm">sub-goroutine closed.
</span></span></span><span class="line"><span class="cl"><span class="cm">main-goroutine, str= sub-goroutine has finished work.
</span></span></span><span class="line"><span class="cl"><span class="cm">main-goroutine finished.
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="45-无缓冲-channel">4.5 无缓冲 <code>channel</code></h3>
<p>无缓冲的通道 <code>unbuffered channel</code> 是指在接收前没有能力保存任何值的通道。
无缓冲的通道要求发送 <code>goroutine</code> 和接收 <code>goroutine</code> 同时准备好，才能完成发送和接收操作。如果两个 <code>goroutine</code> 没有同时准备好，通道会导致先执行发送或接收操作的 <code>goroutine</code> 阻塞等待。这种交互行为就是同步的，任意一个操作都无法离开另一个操作，不能单独存在。
特点：</p>
<ul>
<li>两边都阻塞</li>
<li>管道中不能存东西</li>
<li>交互之前阻塞，交互过程中阻塞，交互完成了才往下走
<img src="/p/1ypylhrh/10.jpg"
	width="861"
	height="798"
	srcset="/p/1ypylhrh/10_hua0baec765f4b3f4577546b56e1a257b6_61733_480x0_resize_q75_box.jpg 480w, /p/1ypylhrh/10_hua0baec765f4b3f4577546b56e1a257b6_61733_1024x0_resize_q75_box.jpg 1024w"
	loading="lazy"
	
		alt="无缓冲channel"
	
	
		class="gallery-image" 
		data-flex-grow="107"
		data-flex-basis="258px"
	
></li>
</ul>
<h4 id="451-创建无缓冲-channel">4.5.1 创建无缓冲 <code>channel</code></h4>
<p>语法：<code>make(chan Type)</code>。不要写 <code>capacity</code>，或者 <code>capacity=0</code>。</p>
<h4 id="452-计算channel的函数">4.5.2 计算channel的函数</h4>
<p><code>len(ch)</code> 缓冲区剩余数据的数量。
<code>cap(ch)</code> 缓冲区大小。</p>
<h4 id="453-示例">4.5.3 示例</h4>
<p>之前的例子都是无缓冲的 <code>channel</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 定义一个无缓冲的channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;len(ch)=%d, cap(ch)=%d\n&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ch</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">ch</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 新建一个子协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;sub-goroutine, i=&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">i</span> <span class="c1">// 往管道中放入内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">num</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span> <span class="c1">// 从管道中取内容，没有内容前会阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;main-goroutine, num=&#34;</span><span class="p">,</span> <span class="nx">num</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">len(ch)=0, cap(ch)=0
</span></span></span><span class="line"><span class="cl"><span class="cm">sub-goroutine, i= 0
</span></span></span><span class="line"><span class="cl"><span class="cm">sub-goroutine, i= 1
</span></span></span><span class="line"><span class="cl"><span class="cm">main-goroutine, num= 0
</span></span></span><span class="line"><span class="cl"><span class="cm">main-goroutine, num= 1
</span></span></span><span class="line"><span class="cl"><span class="cm">sub-goroutine, i= 2
</span></span></span><span class="line"><span class="cl"><span class="cm">main-goroutine, num= 2
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="454-通过-channel-共享-goroutine-的变量">4.5.4 通过 <code>channel</code> 共享 <code>goroutine</code> 的变量</h4>
<p>多个 <code>goroutine</code> 之间的变量共享示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 生产者模型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Produce</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s&#39;s product code: %d&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 消费者模型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Customer</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">ch</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s cost %s\n&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 两个子协程用来生产
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="nf">Produce</span><span class="p">(</span><span class="s">&#34;Sally&#34;</span><span class="p">,</span> <span class="nx">ch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">Produce</span><span class="p">(</span><span class="s">&#34;Rita&#34;</span><span class="p">,</span> <span class="nx">ch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 启动消费者模型，避免主协程提前退出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">Customer</span><span class="p">(</span><span class="s">&#34;Barry&#34;</span><span class="p">,</span> <span class="nx">ch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">Barry cost Rita&#39;s product code: 1601643297
</span></span></span><span class="line"><span class="cl"><span class="cm">Barry cost Sally&#39;s product code: 1601643297
</span></span></span><span class="line"><span class="cl"><span class="cm">Barry cost Sally&#39;s product code: 1601643298
</span></span></span><span class="line"><span class="cl"><span class="cm">Barry cost Rita&#39;s product code: 1601643298
</span></span></span><span class="line"><span class="cl"><span class="cm">Barry cost Rita&#39;s product code: 1601643299
</span></span></span><span class="line"><span class="cl"><span class="cm">Barry cost Sally&#39;s product code: 1601643299
</span></span></span><span class="line"><span class="cl"><span class="cm">Barry cost Sally&#39;s product code: 1601643300
</span></span></span><span class="line"><span class="cl"><span class="cm">Barry cost Rita&#39;s product code: 1601643300
</span></span></span><span class="line"><span class="cl"><span class="cm">Barry cost Sally&#39;s product code: 1601643301
</span></span></span><span class="line"><span class="cl"><span class="cm">Barry cost Rita&#39;s product code: 1601643301
</span></span></span><span class="line"><span class="cl"><span class="cm">...
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="46-有缓冲的-channel">4.6 有缓冲的 <code>channel</code></h3>
<p>有缓冲的通道 <code>buffered channel</code> 是一种在被接收前能存储一个或多个值的通道。
给定了一个缓冲区容量的通道，这个通道就是异步的。只要缓冲区未满还可以用于发送数据，或者接收方还能接收到数据，那么通信就可以无阻塞地进行。
有缓冲的 <code>channel</code> 发生阻塞的两种情况：
1.缓冲区满了，放不下任务数据了，发送方就会阻塞，等待接收方去取出至少一个数据。
2.缓冲区里面还没有任何的数据，接收方没办法接收到数据，接收方阻塞等待发送方把数据放入管道。
<img src="/p/1ypylhrh/11.jpg"
	width="770"
	height="504"
	srcset="/p/1ypylhrh/11_hu16a03ed65011f968e4d9cb1e571b8a0b_41178_480x0_resize_q75_box.jpg 480w, /p/1ypylhrh/11_hu16a03ed65011f968e4d9cb1e571b8a0b_41178_1024x0_resize_q75_box.jpg 1024w"
	loading="lazy"
	
		alt="有缓冲channel"
	
	
		class="gallery-image" 
		data-flex-grow="152"
		data-flex-basis="366px"
	
></p>
<h4 id="461-创建有缓冲的-channel">4.6.1 创建有缓冲的 <code>channel</code></h4>
<p>语法：<code>make(chan Type, capacity)</code>，并且 <code>capaciy&gt;0</code> 即可。</p>
<h4 id="462-示例">4.6.2 示例</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 定义一个有缓冲的 channel，里面能放 3 个东西
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;len(ch)=%d, cap(ch)=%d\n&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ch</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">ch</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 新建一个子协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;sub-goroutine [%d], len(ch)=%d, cap(ch)=%d\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ch</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">ch</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">i</span> <span class="c1">// 管道中一次性可以放入3个东西
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">num</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span> <span class="c1">// 从管道中也可以一次性取 3 个东西
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;main-goroutine, num=&#34;</span><span class="p">,</span> <span class="nx">num</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">len(ch)=0, cap(ch)=3
</span></span></span><span class="line"><span class="cl"><span class="cm">sub-goroutine [0], len(ch)=1, cap(ch)=3
</span></span></span><span class="line"><span class="cl"><span class="cm">sub-goroutine [1], len(ch)=2, cap(ch)=3
</span></span></span><span class="line"><span class="cl"><span class="cm">sub-goroutine [2], len(ch)=3, cap(ch)=3
</span></span></span><span class="line"><span class="cl"><span class="cm">main-goroutine, num= 0
</span></span></span><span class="line"><span class="cl"><span class="cm">main-goroutine, num= 1
</span></span></span><span class="line"><span class="cl"><span class="cm">main-goroutine, num= 2
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="47-两个类型-channel-的总结">4.7 两个类型 <code>channel</code> 的总结</h3>
<p>1.无缓冲的通道保证进行发送和接收的 <code>goroutine</code> 会在同一时间进行数据交互；有缓冲的通道没有这样的保证。
2.无缓冲通道，发送方会阻塞直到接收方从通道中接收了值。
3.有缓冲的通道允许发送端的数据发送和接收端的数据获取处于异步状态，发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。
4.由于缓冲区的大小是有限的，所以还是必须要有接收端来接收数据。否则缓冲区一满，发送端就无法再发送数据了。
5.有缓冲的通道，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。
6.有缓冲的通道，只要通道没满，放几个就可以拿几个。通道满了，就必须取出一个才能继续往里面放数据。</p>
<h3 id="48-关闭-channel">4.8 关闭 <code>channel</code></h3>
<p>内部能够检查到通道是否被关闭了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">i</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 没有数据写入通道时，必须关闭通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 不然调用者接收不到数据就会引发死锁错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 不需要再指定 5 次了，通过判断通道是否被关闭来结束程序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 如果 ok 为 true，表明管道没有被关闭
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">num</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">;</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;num=&#34;</span><span class="p">,</span> <span class="nx">num</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;channel has been closed.&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">num= 0
</span></span></span><span class="line"><span class="cl"><span class="cm">num= 1
</span></span></span><span class="line"><span class="cl"><span class="cm">num= 2
</span></span></span><span class="line"><span class="cl"><span class="cm">num= 3
</span></span></span><span class="line"><span class="cl"><span class="cm">num= 4
</span></span></span><span class="line"><span class="cl"><span class="cm">channel has been closed.
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意事项：
1.<code>channel</code> 不像文件那样需要经常关闭，只有当确定没有任何发送数据了，或者想显示地结束 <code>range</code> 循环之类的采取关闭 <code>channel</code>。
2.关闭 <code>channel</code> 后，无法再向 <code>channel</code> 发送数据，否则引发 <code>panic</code> 错误且导致接收立即返回零值。
3.管道关闭后，可以继续向 <code>channel</code> 接收数据。
4.对于 <code>nil</code> 的 <code>channel</code>，无论收发都会被永久阻塞，引发死锁错误。</p>
<h3 id="49-通过range遍历channel">4.9 通过range遍历channel</h3>
<p>更加简便，遍历时检测到管道被关闭了，就自动跳出循环。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">i</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 没有数据写入通道时，必须关闭通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 不然其他goroutine接收不到数据就会引发死锁错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 无需显示判断，遍历channel时会自动检测，如果管道被关闭了，则自动跳出循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">num</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;num=&#34;</span><span class="p">,</span> <span class="nx">num</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">num= 0
</span></span></span><span class="line"><span class="cl"><span class="cm">num= 1
</span></span></span><span class="line"><span class="cl"><span class="cm">num= 2
</span></span></span><span class="line"><span class="cl"><span class="cm">num= 3
</span></span></span><span class="line"><span class="cl"><span class="cm">num= 4
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="410-单向channel">4.10 单向channel</h3>
<p>管道默认是双向的，可读可写。</p>
<h4 id="4101-单向channel变量的声明">4.10.1 单向channel变量的声明</h4>
<p>就看 <code>&lt;-</code> 箭头放在 <code>chan</code> 这个关键字的哪一边。
没放就是普通的双向通道，放在左边是只读（<code>&lt;-ch</code> 表示取数据），放在右边是只写（<code>ch&lt;-</code> 表示放入数据）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">ch1</span> <span class="kd">chan</span> <span class="kt">int</span> <span class="c1">// 正常的双向通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">ch2</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">float64</span> <span class="c1">// 单向channel，只用于写float64数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">ch3</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span> <span class="c1">// 单向channel，只用于读取int数据
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="4102-单向-channel-的特点">4.10.2 单向 <code>channel</code> 的特点</h4>
<p>1.可以将普通的双向通道隐式转换为单向通道，<strong>不能将单向通道转换为普通的双向通道</strong>。
2.只写的只做写入数据的事情，只读的只做取数据的事情。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 普通的双向通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ch1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">writeCh</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span> <span class="p">=</span> <span class="nx">ch1</span>
</span></span><span class="line"><span class="cl">	<span class="nx">writeCh</span> <span class="o">&lt;-</span> <span class="mi">999</span>
</span></span><span class="line"><span class="cl">	<span class="o">&lt;-</span><span class="nx">writeCh</span> <span class="c1">// 报错：invalid operation: &lt;-writeCh (receive from send-only type chan&lt;- int)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">readCh</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span> <span class="p">=</span> <span class="nx">ch1</span>
</span></span><span class="line"><span class="cl">	<span class="o">&lt;-</span><span class="nx">readCh</span>
</span></span><span class="line"><span class="cl">	<span class="nx">readCh</span> <span class="o">&lt;-</span> <span class="mi">999</span> <span class="c1">// 报错：invalid operation: readCh &lt;- 999 (send to receive-only type &lt;-chan int)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">ch2</span> <span class="kd">chan</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch2</span> <span class="p">=</span> <span class="nx">writeCh</span> <span class="c1">// 报错：cannot use writeCh (type chan&lt;- int) as type chan int in assignment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="4103-单向-channel-的应用">4.10.3 单向 <code>channel</code> 的应用</h4>
<p>生产者&amp;消费者模型：生产一个消费一个。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">producer</span><span class="p">(</span><span class="nx">write</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 此通道只写，不能读取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">write</span> <span class="o">&lt;-</span> <span class="nx">i</span> <span class="o">*</span> <span class="nx">i</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">consumer</span><span class="p">(</span><span class="nx">read</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 此通道只读，不能写入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">data</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">read</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;consumer, data=&#34;</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 生产者，生产数字并放入管道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="nf">producer</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span> <span class="c1">//channel是引用传递(传址)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 消费者，从channel中读取数字并打印消费
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="nf">consumer</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span> <span class="c1">//channel是引用传递(传址)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 为了不让主协程退出，特意写了死循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">consumer, data= 0
</span></span></span><span class="line"><span class="cl"><span class="cm">consumer, data= 1
</span></span></span><span class="line"><span class="cl"><span class="cm">consumer, data= 4
</span></span></span><span class="line"><span class="cl"><span class="cm">consumer, data= 9
</span></span></span><span class="line"><span class="cl"><span class="cm">consumer, data= 16
</span></span></span><span class="line"><span class="cl"><span class="cm">consumer, data= 25
</span></span></span><span class="line"><span class="cl"><span class="cm">consumer, data= 36
</span></span></span><span class="line"><span class="cl"><span class="cm">consumer, data= 49
</span></span></span><span class="line"><span class="cl"><span class="cm">consumer, data= 64
</span></span></span><span class="line"><span class="cl"><span class="cm">consumer, data= 81
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">Process finished with exit code 2
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>取数据的时候，没有数据就会在那边阻塞。等0*0放入管道的时候，内部立马检测到了有数据可以去取，才能去取到数据并打印出来。以此类推循环 10 次：放入一个，读取一个。</p>
<h2 id="五定时器">五、定时器</h2>
<h3 id="51-timer">5.1 <code>Timer</code></h3>
<p><code>Timer</code>是一个定时器，代表未来的一个单一事件。告诉<code>timer</code>需要等待多长时间，它提供了一个<code>channel</code>，时间到往这个<code>channel</code>写入当前的时间值。</p>
<h4 id="511-创建一个-timer">5.1.1 创建一个 <code>Timer</code></h4>
<p>需要用到内建的 <code>time</code> 包。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;current time:&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个Timer，设定2秒。2秒后，往timer通道发送当前的时间值（当前时间）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 2 秒后会往timer通道写入数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 需要手动地显示地获取数据，不写这行代码就不会产生延时效果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">timer</span><span class="p">.</span><span class="nx">C</span> <span class="c1">// .C 表示读取数据，没有数据写入之前会阻塞在这里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;t=&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">current time: 2020-02-22 10:22:14.3789342 +0800 CST m=+0.001995101
</span></span></span><span class="line"><span class="cl"><span class="cm">t= 2020-02-22 10:22:16.3890326 +0800 CST m=+2.012093501
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>NewTimer()</code> 是过一段时间后，往管道中写入数据。如果没有显示地 <code>&lt;-</code> 去取数据，内部检测不到取数据的操作，既然你不想要拿数据，那它也就不会往管道里放数据了。有了取值操作 <code>&lt;-</code>，内部就知道你想要过一段时间后，从管道中取数据，定时器才会生效。</p>
<h4 id="512-timer-只会产生一次事件">5.1.2 <code>Timer</code> 只会产生一次事件</h4>
<p><code>Timer</code>只会响应一次。时间到了，只会产生一次事件，只会写入一次数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="o">&lt;-</span><span class="nx">timer</span><span class="p">.</span><span class="nx">C</span> <span class="c1">// 报错：死锁错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;时间到&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">时间到
</span></span></span><span class="line"><span class="cl"><span class="cm">fatal error: all goroutines are asleep - deadlock!
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">goroutine 1 [chan receive]:
</span></span></span><span class="line"><span class="cl"><span class="cm">main.main()
</span></span></span><span class="line"><span class="cl"><span class="cm">	F:/goProject/src/myTest/main.go:11 +0x54
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">Process finished with exit code 2
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>只写入了一次数据，那也只能拿到一次数据。第二次开始一直阻塞在取数据的地方，程序永远不会往下走，引发死锁错误。</p>
<h4 id="513-timer-实现延时功能">5.1.3 <code>Timer</code> 实现延时功能</h4>
<p>有3种方式可以实现延时功能：<code>Sleep()</code>, <code>time.NewTimer()</code>, <code>time.After()</code>
示例1：<code>Sleep()</code>，最简单粗暴的方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;当前时间：&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;时间到，当前时间：&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">当前时间： 2020-02-22 10:38:33.8267119 +0800 CST m=+0.001994701
</span></span></span><span class="line"><span class="cl"><span class="cm">时间到，当前时间： 2020-02-22 10:38:35.8363347 +0800 CST m=+2.011617501
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>示例2：<code>time.NewTimer()</code>，会产生一个值写入管道 <code>C</code>，需要手动从管道 <code>C</code> 中接收时间值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;当前时间：&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 没有这行语句，就不会有延时效果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">timer</span><span class="p">.</span><span class="nx">C</span> <span class="c1">// 内部会把延时后的当前时间写入管道C中，需要手动&lt;-从管道C中读取出来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;时间到，当前时间：&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">当前时间： 2020-02-22 10:42:10.0294307 +0800 CST m=+0.001995601
</span></span></span><span class="line"><span class="cl"><span class="cm">时间到，当前时间： 2020-02-22 10:42:12.0387286 +0800 CST m=+2.011293501
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>示例3：<code>time.After()</code>，常用于超时处理</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;当前时间：&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置 2 秒延时，阻塞 2 秒。2 秒后产生一个事件（就是往管道里写入延时后的当前时间）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 直接使用&lt;-操作符取值即可
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span> <span class="c1">// 没有 &lt;- 去取值，就不会有延时的效果，不要忘了写上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;时间到，当前时间：&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">当前时间： 2020-02-22 11:02:20.2412903 +0800 CST m=+0.001994901
</span></span></span><span class="line"><span class="cl"><span class="cm">时间到，当前时间： 2020-02-22 11:02:22.2522149 +0800 CST m=+2.012919501
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="514-timer注意事项">5.1.4 Timer注意事项</h4>
<p><code>Timer</code> 需要手动地显示地使用操作符 <code>&lt;-</code> 去管道 <code>C</code> 中接收数据，否则就不会有延时的效果。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;当前时间：&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//t := &lt;-timer.C //内部会把延时后的当前时间写入管道C中，需要手动从管道C中读取出来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;timer=&#34;</span><span class="p">,</span> <span class="nx">timer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;时间到，当前时间：&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">当前时间： 2020-02-22 10:47:51.8096677 +0800 CST m=+0.001994301
</span></span></span><span class="line"><span class="cl"><span class="cm">timer= &amp;{0xc0000ae000 {5797568 0 432376605941300 0 0x491d10 0xc0000ae000 0}}
</span></span></span><span class="line"><span class="cl"><span class="cm">时间到，当前时间： 2020-02-22 10:47:51.8176459 +0800 CST m=+0.009972501
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上例中，根本没有预期的 2 秒钟的延时。
个人自己猜测了一下原因：操作符 <code>&lt;-</code> 取值时，没有数据的时候是会阻塞的。计时器是时间到了，就把当前时间将往管道 <code>C</code> 中发送。如果没有操作符 <code>&lt;-</code> 去取值，Golang 内部会认为你不要这个值，既然你不要这个值，那我为什么还要费力等一段时间后再往管道中放入数据？
<code>timer.C</code> 手动地显示地获取一下，就实现效果了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;当前时间：&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">t</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">timer</span><span class="p">.</span><span class="nx">C</span> <span class="c1">// 内部会把延时后的当前时间写入管道C中，需要手动从管道C中读取出来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;时间到，当前时间：&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">当前时间： 2020-02-22 10:56:08.9670945 +0800 CST m=+0.001995701
</span></span></span><span class="line"><span class="cl"><span class="cm">时间到，当前时间： 2020-02-22 10:56:10.9765383 +0800 CST m=+2.011439501
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="515-timer停止">5.1.5 Timer停止</h4>
<p><code>timer.Stop()</code> 将定时器停止、作废，使定时器失效。
示例1：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;current time:&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="o">&lt;-</span><span class="nx">timer</span><span class="p">.</span><span class="nx">C</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;定时器时间到，子协程可以打印了. current time:&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span> <span class="c1">// 停止定时器，定时器无效了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;1&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">current time: 2020-02-22 15:07:58.7841598 +0800 CST m=+0.001995101
</span></span></span><span class="line"><span class="cl"><span class="cm">1
</span></span></span><span class="line"><span class="cl"><span class="cm">1
</span></span></span><span class="line"><span class="cl"><span class="cm">1
</span></span></span><span class="line"><span class="cl"><span class="cm">1
</span></span></span><span class="line"><span class="cl"><span class="cm">1
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">Process finished with exit code 2
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上例中：主协程中让定时器失效，定时器永远不会往子协程中的管道 <code>C</code> 发送数据。主协程和子协程是两个独立的任务：主协程只是个死循环，调度器调度主协程时，每隔2秒无限打印。而调度子协程时，因为没有任何数据可以接收到，所以就一直阻塞在 <code>&lt;-timer.C</code> 那里。个人猜想，因为有两个任务在不停切换，所以它并不会引发死锁错误。
示例2：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;current time:&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span> <span class="c1">// 停止定时器，定时器无效了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">timer</span><span class="p">.</span><span class="nx">C</span> <span class="c1">// 定时器在这之前就已失效，就接收不到任何值了，永远阻塞在此，引发死锁错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;定时器时间到. t=&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">current time: 2020-02-22 15:00:37.0752347 +0800 CST m=+0.001987401
</span></span></span><span class="line"><span class="cl"><span class="cm">fatal error: all goroutines are asleep - deadlock!
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">goroutine 1 [chan receive]:
</span></span></span><span class="line"><span class="cl"><span class="cm">main.main()
</span></span></span><span class="line"><span class="cl"><span class="cm">	F:/goProject/src/myTest/main.go:13 +0x154
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">Process finished with exit code 2
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上例中，可能因为只有一条主协程的原因，而引发了死锁错误。</p>
<h4 id="516-timer重置">5.1.6 Timer重置</h4>
<p><code>timer.Reset()</code> 重新设定一个 <code>Timer</code> 的过期时间，会把之前设定的时间给覆盖掉。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;current time:&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">timer</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span> <span class="c1">// 重新设定为1秒钟过期，会覆盖原有的时间限定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="o">&lt;-</span><span class="nx">timer</span><span class="p">.</span><span class="nx">C</span> <span class="c1">// 取值，为了让它阻塞在此
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;时间到，current time:&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">current time: 2020-02-22 14:54:52.7534029 +0800 CST m=+0.001994501
</span></span></span><span class="line"><span class="cl"><span class="cm">时间到，current time: 2020-02-22 14:54:53.7637002 +0800 CST m=+1.012291801
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="52-ticker">5.2 Ticker</h3>
<p><code>Ticker</code> 是一个定时触发的计时器，它会以一个间隔 <code>interval</code> 往 <code>channel</code> 发送一个事件(当前时间)，<code>channel</code> 的接收者可以以固定的时间间隔从 <code>channel</code> 中读取事件(当前时间)。
<code>Ticker</code> 是时间到就产生一个事件，一直如此循环。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 定义一个Ticker，每隔2秒循环一个事件(往管道C中写入当前时间值)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ticker</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTicker</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">i</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;current time:&#34;</span><span class="p">,</span> <span class="o">&lt;-</span><span class="nx">ticker</span><span class="p">.</span><span class="nx">C</span><span class="p">)</span> <span class="c1">// 从管道C中读取事件(当前时间)，不然计时器无法生效
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">		<span class="c1">// i=5 的时候，计时器停止，并退出循环。退出循环后，没有接下来的代码了，就是结束程序了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">5</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ticker</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">current time: 2020-02-22 15:27:03.2978298 +0800 CST m=+2.002727901
</span></span></span><span class="line"><span class="cl"><span class="cm">current time: 2020-02-22 15:27:05.2976192 +0800 CST m=+4.002517301
</span></span></span><span class="line"><span class="cl"><span class="cm">current time: 2020-02-22 15:27:07.2972701 +0800 CST m=+6.002168201
</span></span></span><span class="line"><span class="cl"><span class="cm">current time: 2020-02-22 15:27:09.2989453 +0800 CST m=+8.003843401
</span></span></span><span class="line"><span class="cl"><span class="cm">current time: 2020-02-22 15:27:11.2977031 +0800 CST m=+10.002601201
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="53-timer和ticker区别">5.3 Timer和Ticker区别</h3>
<p><code>Timer</code> 时间到了，只会产生一次事件。
<code>Ticker</code> 会循环产生事件。</p>
<h2 id="六select">六、<code>select</code></h2>
<p>通过 <code>select</code> 可以<strong>监听 channel 上的数据流动</strong>（数据流动方向），用来处理异步 IO。特别注意：<code>select</code> 中，每个 <code>case</code> 语句都必须是一个 IO 操作。
在一个 <code>select</code> 语句块中，Golang 会按顺序从头到尾评估每一个发送和接收的语句。如果其中的任意一条语句可以继续执行（即没有阻塞），那么就从那些可以执行的语句中任意选择一条来使用。
如果没有任意一条语句可以执行（即所有的通道都被阻塞），那么有两种情况：
1.如果给出了 <code>default</code> 语句，那么就会执行 <code>default</code> 语句，同时程序的执行会从 <code>select</code> 语句后的语句中恢复。
2.如果没有 <code>default</code> 语句，那么 <code>select</code> 语句将被阻塞，直到至少一个通信到达后，才会执行下去。</p>
<h3 id="61-select-大致结构">6.1 <code>select</code> 大致结构</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="o">&lt;-</span><span class="nx">chan1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//如果chan1成功读到数据，则进入本条case语句
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">case</span> <span class="nx">chan2</span> <span class="o">&lt;-</span> <span class="mi">111</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//如果成功向chan2写入数据，则进入本条case语句
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//如果上面都没有成功，则进入default语句
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="611-注意事项1">6.1.1 注意事项1</h4>
<p><strong>写入数据成功指的是数据写入了，并且有读取了它</strong>。
向管道中写入数据未必能够写成功！向管道中写入数据，那么就必须要有个地方可以拿取它。有写入，且有个地方读取了，那么才算是写入成功！
反面案例：写入了，只是表明有写的这个操作，而不代表写成功的结果！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;this is a sub-goroutine&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">666</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 为了不让主协程退出，特意写了一个死循环放在这里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">this is a sub-goroutine
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">Process finished with exit code 2
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下例是写成功的案例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;this is a sub-goroutine&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">666</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">value</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;get value from ch, value=&#34;</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">this is a sub-goroutine
</span></span></span><span class="line"><span class="cl"><span class="cm">get value from ch, value= 666
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="612-注意事项2">6.1.2 注意事项2</h4>
<p>1.<code>select</code> 中的每个 <code>case</code> 语句里必须是一个 IO 操作。
2.<strong>不能</strong>像 <code>switch</code> 语句中的 <code>case</code> 那样写逻辑运算符，比如 <code>&lt;</code> <code>&gt;</code> <code>==</code> <code>!=</code></p>
<h3 id="62-使用-select-实现斐波那契数列">6.2 使用 <code>select</code> 实现斐波那契数列</h3>
<p>使用生产者消费者模型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 生产者函数，不停地生产数字，并放入管道中去
</span></span></span><span class="line"><span class="cl"><span class="c1">// ch管道只写，quit管道只读
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">fibo</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">quit</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 这里，生产者会一直生产数字。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 当消费者未消费满10个的时候。quit管道是空的，不会接收到数据，由于是无缓冲通道，下面case语句的quit管道就会发生阻塞。Golang内部选择本条case语句。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 当消费者消费满了10个后，消费者那边就不再从管道里取数字了。由于是无缓冲通道，消费者那边不取数字，这里把数字放入管道的时候就会发生阻塞。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 这里发送阻塞的时候，由于下面一条case收到了quit管道中放入了数据这一个信息，而且也从quit管道中去读取数据了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 那边放入，这里取出，完成了写入成功。下面一条的case就不再阻塞了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 这条case阻塞，下面那条case不阻塞，内部就会立马选择下面那条case语句。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">case</span> <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">x</span><span class="p">:</span> <span class="c1">// x的值放入管道中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">=</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="o">+</span><span class="nx">y</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 消费者未消费满10个之前，quit管道是空的。只要通道是空的，没有数据，这里就会阻塞。Golang内部会选择上面那条case语句。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 当消费满10个了，消费者那边会往quit管道中放入一个值。 一旦放入了值，Golang内部就能立马检测到有数据发送过来了，而且这里也执行了取数据的操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 由于消费满10个之后，消费者那边不取值了，因为管道没有缓冲区，上面那条case语句就会阻塞。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 上面的case阻塞，这里的case即有数据放入也有取值操作，所以不再阻塞了，Golang内部选择本条case语句。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">case</span> <span class="nx">flag</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">quit</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;got quit command. flag=&#34;</span><span class="p">,</span> <span class="nx">flag</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="c1">// 终止整个函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>    <span class="c1">// 数字通信的管道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">quit</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span> <span class="c1">// 标记是否退出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 生产者，产生数字并放入管道中，同时检测是否有退出指令写入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 新建一个子协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="nf">fibo</span><span class="p">(</span><span class="nx">ch</span><span class="p">,</span> <span class="nx">quit</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 消费者匿名函数，从管道中读取数字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 让主协程让处理这个消费者的任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 我只要消费10个就够了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">num</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span> <span class="c1">// ch&lt;-x 数据放入管道的时候，这里没有读出来的时候，还是会阻塞在这里。只是 CPU 执行速度实在太快，一放一读几乎瞬间完成，人类的肉眼看不出阻塞的现象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">quit</span> <span class="o">&lt;-</span> <span class="kc">true</span> <span class="c1">// 消费完后，给 quit 管道写入数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">1
</span></span></span><span class="line"><span class="cl"><span class="cm">1
</span></span></span><span class="line"><span class="cl"><span class="cm">2
</span></span></span><span class="line"><span class="cl"><span class="cm">3
</span></span></span><span class="line"><span class="cl"><span class="cm">5
</span></span></span><span class="line"><span class="cl"><span class="cm">8
</span></span></span><span class="line"><span class="cl"><span class="cm">13
</span></span></span><span class="line"><span class="cl"><span class="cm">21
</span></span></span><span class="line"><span class="cl"><span class="cm">34
</span></span></span><span class="line"><span class="cl"><span class="cm">55
</span></span></span><span class="line"><span class="cl"><span class="cm">got quit command. flag= true
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="63-select实现超时机制">6.3 select实现超时机制</h3>
<p>有时候会出现 <code>goroutine</code> 阻塞的情况，如何避免整个程序陷入阻塞的情况？可以利用 <code>select</code> 来设置延时。
比如登陆网银后，一段时间不操作，就自动退出登陆状态了，这就是超时机制。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;current time:&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>    <span class="c1">// 无缓冲的双向管道，可读可写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">quit</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span> <span class="c1">// 是否已退出的标记
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 新建一个子协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 不停地检测两个管道中的数据流动放向
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="c1">// 另外一个子协程每隔1秒往ch管道中放入数据，一旦放入数据，Golang内部就能立马检测到这一信息，这里便能读取出数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// 能读取出数据，数据就是在流动的，这里就不会阻塞。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">case</span> <span class="nx">num</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;num=&#34;</span><span class="p">,</span> <span class="nx">num</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="c1">// 3 秒后，定时器触发事件。在此之前，定时器没有触发，都是处于阻塞状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// 5 个放完后就不再往ch管道中放数据了，而是给quit管道放入了一个数据。此时上面case接收不到数据，上面的case就会阻塞。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// 上面一直阻塞着，阻塞了3秒钟后，定时器被触发了，打印信息，并往quit管道中发送数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">):</span> <span class="c1">// 和Sleep()是同时在发生的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;已超时.&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="nx">quit</span> <span class="o">&lt;-</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 新建另一个子协程，用来往ch管道中放入数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 每隔 1 秒，往 ch 管道中放入数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">i</span>
</span></span><span class="line"><span class="cl">			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;sub-goroutine, loop finished. current time:&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 主协程在没有数据放入quit管道之前，就阻塞在这里。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 一旦有数据放入管道中，Golang检测到了，并读取到了，这里才不会阻塞。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">q</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">quit</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;current time:&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;got quit command, system quit. quit=&#34;</span><span class="p">,</span> <span class="nx">q</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">current time: 2020-02-23 10:53:12.2591937 +0800 CST m=+0.002025201
</span></span></span><span class="line"><span class="cl"><span class="cm">num= 0
</span></span></span><span class="line"><span class="cl"><span class="cm">num= 1
</span></span></span><span class="line"><span class="cl"><span class="cm">num= 2
</span></span></span><span class="line"><span class="cl"><span class="cm">num= 3
</span></span></span><span class="line"><span class="cl"><span class="cm">num= 4
</span></span></span><span class="line"><span class="cl"><span class="cm">sub-goroutine, loop finished. current time: 2020-02-23 10:53:17.2709789 +0800 CST m=+5.013810401
</span></span></span><span class="line"><span class="cl"><span class="cm">已超时.
</span></span></span><span class="line"><span class="cl"><span class="cm">current time: 2020-02-23 10:53:19.2717308 +0800 CST m=+7.014562301
</span></span></span><span class="line"><span class="cl"><span class="cm">got quit command, system quit. quit= true
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">Process finished with exit code 0
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>总共用了7秒是因为：当最后一次往 ch 管道放入数据后（放入后子协程会去执行睡1秒的操作），<code>&lt;-ch</code> 接收完了这个数据，就再也接收不到其他任何数据了，就处于阻塞的状态了。5次for循环确实是用了5秒，当子协程在睡1秒的同时，定时器也开始从3秒倒计时了，此时倒计时3秒和睡1秒是同时在发生的事情。睡了1秒之后，定时器也只剩下了2秒。总耗时：5秒+2秒&gt;7秒，因为程序执行也是需要耗费时间的。
注：Golang 的 <code>time.Now()</code> 是以纳秒（十亿分之一秒）来呈现。</p>
<h3 id="64-使用-select-输出几个偶数">6.4 使用 <code>select</code> 输出几个偶数</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 缓冲区大小为1，要么是空的，要么是满的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">x</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">:</span> <span class="c1">// 缓冲区中有数据了，才会选择这个分支
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">i</span><span class="p">:</span> <span class="c1">// 缓冲区空的时候，才会选择这个分支
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// do nothing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果：
</span></span></span><span class="line"><span class="cl"><span class="cm">0 2 4 6 8
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div>
</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/golang/">Golang</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="has-image">
    <a href="/p/xb9uhh7c/">
        
        
            <div class="article-image">
                
                    <img src="https://w.wallhaven.cc/full/gp/wallhaven-gpd95q.png" loading="lazy" data-key="xb9uhh7c" data-hash="https://w.wallhaven.cc/full/gp/wallhaven-gpd95q.png"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">Golang学习之异常与文本文件处理</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/giabprkd/">
        
        
            <div class="article-image">
                
                    <img src="https://w.wallhaven.cc/full/zy/wallhaven-zydldy.jpg" loading="lazy" data-key="giabprkd" data-hash="https://w.wallhaven.cc/full/zy/wallhaven-zydldy.jpg"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">Golang学习之面向对象编程</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/wknjbadw/">
        
        
            <div class="article-image">
                
                    <img src="https://w.wallhaven.cc/full/zy/wallhaven-zy9gwv.png" loading="lazy" data-key="wknjbadw" data-hash="https://w.wallhaven.cc/full/zy/wallhaven-zy9gwv.png"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">Golang学习之复合类型</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/gryrnn22/">
        
        
            <div class="article-image">
                
                    <img src="https://w.wallhaven.cc/full/d6/wallhaven-d6o97j.png" loading="lazy" data-key="gryrnn22" data-hash="https://w.wallhaven.cc/full/d6/wallhaven-d6o97j.png"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">Golang学习之函数与工程管理</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/nn24jprl/">
        
        
            <div class="article-image">
                
                    <img src="https://w.wallhaven.cc/full/kx/wallhaven-kxdz96.jpg" loading="lazy" data-key="nn24jprl" data-hash="https://w.wallhaven.cc/full/kx/wallhaven-kxdz96.jpg"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">Golang学习之基本类型与流程控制</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    <script src="https://utteranc.es/client.js" 
        repo="360rce/blog-comment"
        issue-term="pathname"
        
        label="utterances"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    let utterancesLoaded = false;

    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;

        
        utterancesLoaded = true;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        if (!utterancesLoaded) return;
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2023 本博客所有文章除特别声明外，均采用 CC BY-SA 4.0 协议 ，转载请注明出处！
    </section>
    <i class="powerby">
    <span id="busuanzi_container_site_pv">
        访问量&nbsp;-&nbsp;<span id="busuanzi_value_site_pv"></span>
    </span>&nbsp;
    <span id="busuanzi_container_site_uv">
        访客数&nbsp;-&nbsp;<span id="busuanzi_value_site_uv"></span>人次
      </span>
    </i>


</footer>
<script>
    (function(u, c) {
      var d = document, t = 'script', o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function(e) { c(e); }); }
      s.parentNode.insertBefore(o, s);
    })('//cdn.bootcss.com/pangu/4.0.7/pangu.min.js', function() {
      pangu.spacingPage();
    });
</script>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>


    </body>
</html>
